=== START FILE: ./vite.config.ts ===
=== TYPE: ts ===

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
  optimizeDeps: {
    esbuildOptions: {
      target: 'esnext'
    }
  },
  build: {
    target: 'esnext',
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          'ui-vendor': ['@headlessui/vue', '@heroicons/vue', 'lucide-vue-next'],
          'highlight': ['highlight.js'],
          'prism': ['prismjs'],
          'marked': ['marked'],
          'dompurify': ['dompurify'],
          'monaco': ['@monaco-editor/loader']
        }
      }
    }
  }
})
=== END FILE: ./vite.config.ts ===


=== START FILE: ./src/App.vue ===
=== TYPE: vue ===

// src/App.vue
<script setup lang="ts">
import { ref } from 'vue';
import { Settings } from 'lucide-vue-next';
import InfiniteCanvas from './components/canvas/InfiniteCanvas.vue';
import ThemeToggle from './components/theme/ThemeToggle.vue';
import TangentLogo from './components/logo/TangentLogo.vue';
import ModelSelector from './components/models/ModelSelector.vue';
import TaskManager from './components/manager/TaskManager.vue';
import type { Model } from './components/models/ModelSelector.vue';
import { useCanvasStore } from './stores/canvasStore';

// State - load from localStorage if present
const selectedModel = ref<Model | null>(
  localStorage.getItem('selectedModel')
    ? JSON.parse(localStorage.getItem('selectedModel')!)
    : null
);
const modelType = ref<string>(localStorage.getItem('modelType') || '');
const settingsDialog = ref<HTMLDialogElement | null>(null);
const openRouterApiKey = ref(localStorage.getItem('openRouterApiKey') || '');
const activeTab = ref<'api' | 'tasks'>('api');
const canvasStore = useCanvasStore();
const customApiUrl = ref<string | null>(localStorage.getItem('customApiUrl') || null);

// Methods
const handleModelSelect = (model: Model) => {
  console.log('Previous model:', selectedModel.value);
  console.log('New model:', model);

  selectedModel.value = model;
  modelType.value = model.source;

  try {
    localStorage.setItem('selectedModel', JSON.stringify(model));
    localStorage.setItem('modelType', model.source);
  } catch (e) {
    console.error('Error storing model:', e);
  }
};

const openSettings = () => {
  settingsDialog.value?.showModal();
};

const closeSettings = () => {
  settingsDialog.value?.close();
  if (openRouterApiKey.value) {
    localStorage.setItem('openRouterApiKey', openRouterApiKey.value);
  } else {
    localStorage.removeItem('openRouterApiKey');
  }
  canvasStore.setCustomApiUrl(customApiUrl.value)
};
</script>

<template>
  <div class="min-h-screen bg-background">
    <!-- Logo - Centered at top -->
    <div class="fixed top-4 left-1/2 -translate-x-1/2 z-10">
      <TangentLogo />
    </div>

    <!-- Settings Modal -->
    <dialog ref="settingsDialog" class="modal">
      <div class="modal-box max-w-lg">
        <div class="flex items-center space-x-2 mb-4">
          <button 
            class="btn btn-sm"
            :class="{ 'btn-active': activeTab === 'api' }"
            @click="activeTab = 'api'"
          >
            API Settings
          </button>
          <button 
            class="btn btn-sm"
            :class="{ 'btn-active': activeTab === 'tasks' }"
            @click="activeTab = 'tasks'"
          >
            Tasks
          </button>
        </div>

        <div v-if="activeTab === 'api'" class="space-y-4">
          <div class="form-control">
            <label class="label">
              <span class="label-text">OpenRouter API Key</span>
            </label>
            <input
              v-model="openRouterApiKey"
              type="password"
              placeholder="sk-or-..."
              class="input input-bordered w-full"
            />
            <label class="label">
            <span class="label-text">Custom API URL</span>
          </label>
          <input
            v-model="customApiUrl"
            type="url"
            placeholder="http://localhost:8080/v1/chat/completions"
            class="input input-bordered w-full"
          />
          </div>
        </div>

        <div v-else-if="activeTab === 'tasks'">
          <TaskManager />
        </div>

        <div class="modal-action">
          <button class="btn" @click="closeSettings">Close</button>
        </div>
      </div>
    </dialog>

    <!-- Model Selection Header -->
    <div class="fixed top-0 right-0 p-4 z-20 flex items-center gap-2">
      <button
        @click="openSettings"
        class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800"
      >
        <Settings class="w-5 h-5" />
      </button>

      <ModelSelector
        :api-key="openRouterApiKey"
        :selected-model="selectedModel"
        @select="handleModelSelect"
      />

      <ThemeToggle />
    </div>

    <!-- Canvas -->
    <InfiniteCanvas
      :selected-model="selectedModel?.id || ''"
      :open-router-api-key="openRouterApiKey"
      :model-type="modelType"
    />
  </div>
</template>
=== END FILE: ./src/App.vue ===


=== START FILE: ./src/types/message.ts ===
=== TYPE: ts ===

// types/message.ts
export interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  isStreaming?: boolean;
  modelId?: string;
}

export interface ContentPart {
  type: 'text' | 'code';
  content: string;
  language?: string;
  complete?: boolean;
}

export interface Node {
  id: string;
  x: number;
  y: number;
  title?: string;
  parentId: string | null;
  messages: Message[];
  type: 'main' | 'branch';
  branchMessageIndex: number | null;
  streamingContent?: string | null;
}
=== END FILE: ./src/types/message.ts ===


=== START FILE: ./src/types/vue-shims.d.ts ===
=== TYPE: ts ===

// src/types/vue-shims.d.ts
declare module '*.vue' {
    import type { DefineComponent } from 'vue';
    const component: DefineComponent<{}, {}, any>;
    export default component;
}
=== END FILE: ./src/types/vue-shims.d.ts ===


=== START FILE: ./src/main.ts ===
=== TYPE: ts ===

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import 'highlight.js/styles/github-dark.css';
import router from './router'
import App from './App.vue'
import './assets/main.css'

const app = createApp(App)
app.use(createPinia())
app.use(router)
app.mount('#app')

=== END FILE: ./src/main.ts ===


=== START FILE: ./src/stores/canvasStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Message, Node } from '../types/message';

// Helper types for model info
type ModelSource = 'ollama' | 'openrouter' | 'custom';
interface ModelInfo {
  id: string;
  name: string;
  source: ModelSource;
  provider?: string;
}

export const useCanvasStore = defineStore('canvas', () => {
  // Main state
  const nodes = ref<Node[]>([{
    id: '1',
    x: 100,
    y: 100,
    title: 'Root Thread',
    parentId: null,
    messages: [],
    type: 'main',
    branchMessageIndex: null,
    streamingContent: null
  }]);

  // UI state
  const activeNode = ref<string | null>(null);
  const isDragging = ref(false);
  const dragOffset = ref({ x: 0, y: 0 });
  const viewMode = ref<'2d' | '3d'>('2d');
  const isTransitioning = ref(false);
  const customApiUrl = ref<string | null>(localStorage.getItem('customApiUrl') || null);

  // Constants
  const CARD_WIDTH = 672;
  const CARD_HEIGHT = 80;
  const HORIZONTAL_SPACING = 100;

  // Topic clustering state
  const topicClusters = ref(new Map());
  const nodeTopics = ref(new Map());

  // Helper function to process SSE lines
  const processSSELine = (line: string, source: ModelSource) => {
    // Skip empty lines and known control messages
    if (!line || line === 'data: [DONE]' || line === '[DONE]' || 
        (source === 'openrouter' && line.startsWith(': OPENROUTER PROCESSING'))) {
      return null;
    }

    // Remove 'data: ' prefix and handle different formats
    const jsonData = line.startsWith('data: ') ? line.slice(5) : line;

    try {
      const data = JSON.parse(jsonData);
      if (source === 'openrouter') {
        return data.choices?.[0]?.delta?.content || '';
      } else {
        return data.content || '';
      }
    } catch (e) {
      // Only log actual parsing errors for non-control messages
      if (!line.includes('[DONE]') && !line.includes('OPENROUTER PROCESSING')) {
        console.error(`Error parsing ${source} response:`, e, line);
      }
      return null;
    }
  };

  // Helper function to handle streaming responses
  const handleStreamingResponse = async (
    reader: ReadableStreamDefaultReader<Uint8Array>,
    nodeId: string,
    modelSource: ModelSource
  ) => {
    let buffer = '';
    let accumulatedContent = '';
    const decoder = new TextDecoder();

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          const content = processSSELine(line, modelSource);
          if (content) {
            accumulatedContent += content;
            setStreamingContent(nodeId, accumulatedContent);
          }
        }
      }

      // Process any remaining buffer content
      if (buffer) {
        const content = processSSELine(buffer, modelSource);
        if (content) {
          accumulatedContent += content;
          setStreamingContent(nodeId, accumulatedContent);
        }
      }

      return accumulatedContent;
    } catch (error) {
      console.error('Error in streaming response:', error);
      throw error;
    }
  };

  // Computed properties for 3D view
  const graphData = computed(() => {
    const clusters = Array.from(topicClusters.value.entries()).map(([topicId, nodeSet]) => ({
      id: `cluster-${topicId}`,
      type: 'cluster',
      nodes: Array.from(nodeSet),
      size: nodeSet.size
    }));

    const graphNodes = nodes.value.map(node => ({
      id: node.id,
      title: node.title || 'Untitled Thread',
      clusterId: nodeTopics.value.get(node.id),
      messageCount: node.messages?.length || 0,
      lastActive: node.messages?.[node.messages.length - 1]?.timestamp || '',
      branchPoint: node.branchMessageIndex
    }));

    const links = connections.value.map(conn => ({
      source: conn.parent?.id || '',
      target: conn.child.id,
      branchPoint: nodes.value.find(n => n.id === conn.child.id)?.branchMessageIndex
    }));

    return {
      nodes: [...graphNodes, ...clusters],
      links
    };
  });

  // Connections computed property
  const connections = computed(() => {
    return nodes.value
      .filter(node => node.parentId)
      .map(node => {
        const parent = nodes.value.find(n => n.id === node.parentId);
        return { parent, child: node };
      });
  });

  const parseModelInfo = (selectedModel: string): ModelInfo => {
    if (selectedModel.includes('/')) {
      const [provider, name] = selectedModel.split('/');
      return {
        id: selectedModel,
        name,
        source: 'openrouter',
        provider
      };
    } else if (customApiUrl.value) {
      return {
        id: selectedModel,
        name: selectedModel,
        source: 'custom'
      };
    } else {
      return {
        id: selectedModel,
        name: selectedModel,
        source: 'ollama'
      };
    }
  };

  const sendMessage = async (
    nodeId: string,
    message: string,
    selectedModel: string,
    openRouterApiKey: string,
    addUserMessage = true
  ) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (!node) return;

    const systemPrompt = `
      You are a helpful AI assistant who can engage in natural conversation while also helping with code. 
      When sharing code examples, always format them in markdown using fenced blocks with the appropriate language.
    `;

    try {
      const modelInfo = parseModelInfo(selectedModel);

      if (addUserMessage) {
        const userMessage: Message = {
          role: 'user',
          content: message,
          timestamp: new Date().toISOString(),
          isStreaming: false
        };
        addMessage(nodeId, userMessage);
      }

      const messageContext = node.messages.map(msg => ({
        role: msg.role,
        content: msg.content
      }));

      const { endpoint, headers, requestBody } = prepareRequest(
        modelInfo,
        messageContext,
        systemPrompt,
        openRouterApiKey
      );

      const response = await fetch(endpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await getErrorText(response);
        throw new Error(errorText);
      }

      const reader = response.body?.getReader();
      if (!reader) throw new Error('Response body is null');

      const accumulatedContent = await handleStreamingResponse(reader, nodeId, modelInfo.source);

      // Store final message
      const assistantMessage: Message = {
        role: 'assistant',
        content: accumulatedContent,
        timestamp: new Date().toISOString(),
        modelId: modelInfo.id,
        isStreaming: false
      };
      addMessage(nodeId, assistantMessage);
      setStreamingContent(nodeId, null);

      return true;
    } catch (error) {
      console.error('Error sending message:', error);
      setStreamingContent(nodeId, null);
      return false;
    }
  };

  const prepareRequest = (
    modelInfo: ModelInfo,
    messageContext: Array<{ role: string; content: string }>,
    systemPrompt: string,
    openRouterApiKey: string
  ) => {
    let endpoint = 'http://localhost:11434/api/chat';
    let headers: HeadersInit = {
      'Content-Type': 'application/json'
    };

    if (modelInfo.source === 'openrouter') {
      endpoint = 'https://openrouter.ai/api/v1/chat/completions';
      headers = {
        ...headers,
        'Authorization': `Bearer ${openRouterApiKey}`,
        'HTTP-Referer': window.location.origin,
        'X-Title': 'Tangent Chat'
      };
    } else if (modelInfo.source === 'custom' && customApiUrl.value) {
      endpoint = customApiUrl.value;
    }

    const requestBody = modelInfo.source === 'custom' && customApiUrl.value
      ? {
          prompt: `${messageContext.map(m => `${m.role}: ${m.content}`).join('\n')}`,
          stream: true,
          model: modelInfo.id
        }
      : {
          model: modelInfo.id,
          messages: [
            { role: 'system', content: systemPrompt },
            ...messageContext
          ],
          stream: true
        };

    return { endpoint, headers, requestBody };
  };

  const getErrorText = async (response: Response) => {
    let errorText = `API error: ${response.status}`;
    try {
      const errorData = await response.json();
      errorText += ` - ${JSON.stringify(errorData)}`;
    } catch (e) {
      console.error('Could not parse error body', e);
    }
    return errorText;
  };

  // Node management functions
  const addNode = (parentId: string, branchMessageIndex: number, position: { x: number, y: number }, initialData = {}) => {
    const newId = (Math.max(...nodes.value.map(n => parseInt(n.id))) + 1).toString();
    const parentNode = nodes.value.find(n => n.id === parentId);
    const existingChildren = nodes.value.filter(n => n.parentId === parentId).length;

    const parentMessages = parentNode?.messages || [];
    const contextMessages = parentMessages.slice(0, branchMessageIndex + 1).map(msg => ({
      ...msg,
      timestamp: new Date().toISOString()
    }));

    const newNode: Node = {
      id: newId,
      x: position.x,
      y: position.y + (existingChildren * (CARD_HEIGHT + 20)),
      parentId,
      messages: contextMessages,
      type: 'branch',
      branchMessageIndex,
      streamingContent: null,
      ...initialData
    };

    nodes.value.push(newNode);
    return newNode;
  };

  const addMessage = (nodeId: string, message: string | Message) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node) {
      const newMessage: Message = typeof message === 'string' 
        ? {
            role: 'assistant',
            content: message,
            timestamp: new Date().toISOString(),
            isStreaming: false
          } 
        : {
            ...message,
            role: message.role as 'user' | 'assistant',
            isStreaming: message.isStreaming ?? false
          };

      node.messages = [...(node.messages || []), newMessage];
    }
  };

  const removeMessage = (nodeId: string, messageIndex: number) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node && node.messages) {
      node.messages = [
        ...node.messages.slice(0, messageIndex),
        ...node.messages.slice(messageIndex + 1)
      ];

      const childNodes = nodes.value.filter(n => n.parentId === nodeId);
      childNodes.forEach(childNode => {
        if (childNode.branchMessageIndex && childNode.branchMessageIndex >= messageIndex) {
          childNode.branchMessageIndex--;
        }
      });
    }
  };

  const updateNodePosition = (id: string, position: { x: number, y: number }) => {
    const node = nodes.value.find(n => n.id === id);
    if (node) {
      node.x = position.x;
      node.y = position.y;
    }
  };

  const removeNode = (id: string) => {
    const topicId = nodeTopics.value.get(id);
    if (topicId !== undefined) {
      const cluster = topicClusters.value.get(topicId);
      if (cluster) {
        cluster.delete(id);
        if (cluster.size === 0) {
          topicClusters.value.delete(topicId);
        }
      }
      nodeTopics.value.delete(id);
    }
    nodes.value = nodes.value.filter(n => n.id !== id && n.parentId !== id);
  };

  const updateNodeTitle = (id: string, title: string) => {
    const node = nodes.value.find(n => n.id === id);
    if (node) {
      node.title = title;
    }
  };

  const setStreamingContent = (nodeId: string, content: string | null) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node) {
      node.streamingContent = content;
    }
  };

  const setCustomApiUrl = (url: string | null) => {
    customApiUrl.value = url;
    if (url) {
      localStorage.setItem('customApiUrl', url);
    } else {
      localStorage.removeItem('customApiUrl');
    }
  };

  return {
    // State
    nodes,
    activeNode,
    isDragging,
    dragOffset,
    viewMode,
    isTransitioning,
    topicClusters,
    nodeTopics,
    customApiUrl,

    // Computed
    connections,
    graphData,

    // Constants
    CARD_WIDTH,
    CARD_HEIGHT,
    HORIZONTAL_SPACING,

    // Methods
    addNode,
    updateNodePosition,
    removeNode,
    updateNodeTitle,
    addMessage,
    setStreamingContent,
    removeMessage,
    sendMessage,
    setCustomApiUrl
  };
});
=== END FILE: ./src/stores/canvasStore.ts ===


=== START FILE: ./src/utils/api.ts ===
=== TYPE: ts ===


=== END FILE: ./src/utils/api.ts ===


=== START FILE: ./src/components/ui/Card.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Card.vue -->
<template>
    <div 
      class="rounded-lg border bg-card text-card-foreground shadow"
      :class="className"
    >
      <slot />
    </div>
  </template>
  
  <script setup>
  defineProps({
    className: {
      type: String,
      default: ''
    }
  });
  </script>
=== END FILE: ./src/components/ui/Card.vue ===


=== START FILE: ./src/components/ui/alert/Alert.vue ===
=== TYPE: vue ===

<template>
  <div :class="[
    'relative w-full rounded-lg border p-4',
    variantStyles[variant || 'default'],
    className
  ]" role="alert">
    <slot />
  </div>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'default' | 'destructive',
  className?: string
}

withDefaults(defineProps<Props>(), {
  variant: 'default',
  className: ''
})

const variantStyles = {
  default: 'bg-background text-foreground',
  destructive: 'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive'
}
</script>
=== END FILE: ./src/components/ui/alert/Alert.vue ===


=== START FILE: ./src/components/ui/alert/AlertDescription.vue ===
=== TYPE: vue ===

<!-- src/components/ui/AlertDescription.vue -->
<template>
    <div
      class="text-sm [&_p]:leading-relaxed"
      :class="className"
    >
      <slot />
    </div>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    className?: string
  }>()
  </script>
=== END FILE: ./src/components/ui/alert/AlertDescription.vue ===


=== START FILE: ./src/components/ui/alert/AlertTitle.vue ===
=== TYPE: vue ===

<!-- src/components/ui/AlertTitle.vue -->
<template>
    <h5
      class="mb-1 font-medium leading-none tracking-tight"
      :class="className"
    >
      <slot />
    </h5>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    className?: string
  }>()
  </script>
=== END FILE: ./src/components/ui/alert/AlertTitle.vue ===


=== START FILE: ./src/components/ui/Badge.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Badge.vue -->
<template>
  <div 
    class="inline-flex items-center rounded-md px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
    :class="{
      'bg-primary text-primary-foreground hover:bg-primary/80': variant === 'default',
      'bg-secondary text-secondary-foreground hover:bg-secondary/80': variant === 'secondary',
      'bg-destructive text-destructive-foreground hover:bg-destructive/80': variant === 'destructive',
      'border border-primary/20 bg-primary/10 text-primary hover:bg-primary/20': variant === 'outline'
    }"
  >
    <slot />
  </div>
</template>

<script setup>
defineProps({
  variant: {
    type: String,
    default: 'default',
    validator: (value) => ['default', 'secondary', 'destructive', 'outline'].includes(value)
  }
});
</script>
=== END FILE: ./src/components/ui/Badge.vue ===


=== START FILE: ./src/components/ui/Button.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Button.vue -->
<template>
    <button
      class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
      :class="[
        variantStyles[variant],
        sizeStyles[size],
        className
      ]"
      :disabled="disabled"
      :type="type"
      @click="$emit('click', $event)"
    >
      <slot />
    </button>
  </template>
  
  <script setup lang="ts">
  interface Props {
    variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link'
    size?: 'default' | 'sm' | 'lg' | 'icon'
    className?: string
    disabled?: boolean
    type?: 'button' | 'submit' | 'reset'
  }
  
  withDefaults(defineProps<Props>(), {
    variant: 'default',
    size: 'default',
    className: '',
    disabled: false,
    type: 'button'
  })
  
  defineEmits<{
    (e: 'click', event: MouseEvent): void
  }>()
  
  const variantStyles = {
    default: 'bg-primary text-primary-foreground shadow hover:bg-primary/90',
    destructive: 'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',
    outline: 'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',
    secondary: 'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',
    ghost: 'hover:bg-accent hover:text-accent-foreground',
    link: 'text-primary underline-offset-4 hover:underline'
  }
  
  const sizeStyles = {
    default: 'h-9 px-4 py-2',
    sm: 'h-8 rounded-md px-3 text-xs',
    lg: 'h-10 rounded-md px-8',
    icon: 'h-9 w-9'
  }
  </script>
=== END FILE: ./src/components/ui/Button.vue ===


=== START FILE: ./src/components/messages/MessageInput.vue ===
=== TYPE: vue ===

<!-- src/components/MessageInput.vue -->
<template>
  <div class="message-input-container border-t border-gray-200 dark:border-gray-700 mt-4 pt-4">
    <div class="relative">
      <textarea
        ref="textareaRef"
        v-model="messageInput"
        rows="1"
        class="w-full px-4 py-2.5 resize-none bg-white dark:bg-gray-800 
               border border-gray-200 dark:border-gray-700 rounded-lg pr-24
               text-gray-800 dark:text-gray-200 placeholder-gray-500
               focus:ring-2 focus:ring-primary focus:ring-opacity-50 focus:border-transparent"
        :class="{ 'opacity-50': isLoading }"
        placeholder="Type your message..."
        @keydown.enter.prevent="handleSubmit"
        @input="autoResize"
      ></textarea>
      
      <div class="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-2">
        <!-- The button toggles between "Send" and "Stop" based on isLoading -->
        <button
          class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 
                 transition-colors disabled:opacity-50"
          :disabled="!isLoading && !messageInput.trim()"
          @click="handleToggleButton"
        >
          <!-- If isLoading, show Stop icon; otherwise show Send icon -->
          <template v-if="isLoading">
            <!-- Stop Icon (any you prefer, e.g. XCircle, or lucide StopCircle, etc.) -->
            <StopCircle class="w-5 h-5 text-red-600" />
          </template>
          <template v-else>
            <Send class="w-5 h-5 text-primary" />
          </template>
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue';
import { Send, StopCircle } from 'lucide-vue-next';

const props = defineProps({
  isLoading: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['send', 'stop']);

const messageInput = ref('');
const textareaRef = ref(null);

/**
 * Dynamically resize the text area.
 */
const autoResize = () => {
  const textarea = textareaRef.value;
  if (!textarea) return;
  
  textarea.style.height = 'auto';
  textarea.style.height = `${textarea.scrollHeight}px`;
};

/**
 * Called on Enter or Send button click.
 */
const handleSubmit = async () => {
  const message = messageInput.value.trim();
  if (!message || props.isLoading) return;

  emit('send', message);
  messageInput.value = '';
  
  await nextTick();
  autoResize();
};

/**
 * Called if isLoading is true (currently streaming).
 * Emitted up so parent can stop the generation and update store.
 */
const handleStop = () => {
  emit('stop');
};

/**
 * Toggle function for the button click:
 * - If we are loading/streaming => "Stop"
 * - Otherwise => "Send"
 */
const handleToggleButton = () => {
  if (props.isLoading) {
    handleStop();
  } else {
    handleSubmit();
  }
};
</script>

=== END FILE: ./src/components/messages/MessageInput.vue ===


=== START FILE: ./src/components/messages/CodePreview.vue ===
=== TYPE: vue ===

<template>
  <div class="relative mt-3 mb-3">
    <div class="absolute right-2 top-2 flex gap-2">
      <button 
        class="p-1.5 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors shadow-sm"
        @click="copyToClipboard"
      >
        <Clipboard class="w-4 h-4 text-gray-600 dark:text-gray-300" />
      </button>
    </div>
    <pre 
      ref="previewRef"
      :class="[
        'p-4 rounded-lg overflow-x-auto border',
        'bg-gray-100 dark:bg-gray-800',
        'border-gray-200 dark:border-gray-700',
        isDark ? 'hljs-dark' : 'hljs-light'
      ]"
    >
      <code 
        ref="codeRef"
        :class="`language-${props.language} hljs text-sm`"
        v-html="highlightedCode"
      />
    </pre>
    <div v-if="props.isStreaming" class="mt-2 flex gap-1">
      <span class="animate-bounce w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-75 w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-150 w-1.5 h-1.5 bg-primary rounded-full"></span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';
import hljs from 'highlight.js';
import DOMPurify from 'dompurify';
import { Clipboard } from 'lucide-vue-next';

interface Props {
  content: string;
  isStreaming: boolean;
  language?: string;
}

const props = withDefaults(defineProps<Props>(), {
  language: 'javascript'
});

const previewRef = ref<HTMLElement | null>(null);
const codeRef = ref<HTMLElement | null>(null);
const isDark = ref(false);

// Watch for theme changes
const updateTheme = () => {
  isDark.value = document.documentElement.classList.contains('dark');
};

onMounted(() => {
  // Initialize hljs
  hljs.configure({ 
    ignoreUnescapedHTML: true,
    languages: ['javascript', 'python', 'bash', 'typescript', 'json']
  });

  // Set initial theme
  updateTheme();

  // Watch for theme changes using MutationObserver
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        updateTheme();
      }
    });
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class']
  });

  // Cleanup
  onUnmounted(() => {
    observer.disconnect();
  });
});

const highlightedCode = computed(() => {
  try {
    // First ensure language is registered
    if (!hljs.getLanguage(props.language)) {
      console.warn(`Language ${props.language} not found, falling back to plaintext`);
      return DOMPurify.sanitize(props.content);
    }

     const result = hljs.highlight(props.content, {
        language: props.language,
      });


    return DOMPurify.sanitize(result.value);
  } catch (err) {
    console.error('Highlighting error:', err);
    return DOMPurify.sanitize(props.content);
  }
});

const copyToClipboard = () => {
  navigator.clipboard.writeText(props.content);
};
</script>

<style>
/* Light theme styles */
:root:not(.dark) .hljs-light {
  --hljs-background: transparent;
  --hljs-comment: #54575a;
  --hljs-keyword: #d73a49;
  --hljs-string: #032f62;
  --hljs-number: #005cc5;
  --hljs-function: #2c0f60;
  --hljs-title: #240b53;
  --hljs-params: #24292e;
  --hljs-built_in: #005cc5;
  --hljs-literal: #005cc5;
  --hljs-variable: #24292e;
  --hljs-type: #d73a49;
  --hljs-attr: #005cc5;
  --hljs-selector: #125f24;
}

/* Dark theme styles */
.dark .hljs-dark {
  --hljs-background: transparent;
  --hljs-comment: #8b949e;
  --hljs-keyword: #ff7b72;
  --hljs-string: #a5d6ff;
  --hljs-number: #79c0ff;
  --hljs-function: #d2a8ff;
  --hljs-title: #d2a8ff;
  --hljs-params: #c9d1d9;
  --hljs-built_in: #79c0ff;
  --hljs-literal: #79c0ff;
  --hljs-variable: #c9d1d9;
  --hljs-type: #ff7b72;
  --hljs-attr: #79c0ff;
  --hljs-selector: #7ee787;
}

/* Common styles */
.hljs {
  background: var(--hljs-background) !important;
  color: var(--hljs-params);
}

.hljs-comment { color: var(--hljs-comment); }
.hljs-keyword { color: var(--hljs-keyword); }
.hljs-string { color: var(--hljs-string); }
.hljs-number { color: var(--hljs-number); }
.hljs-function { color: var(--hljs-function); }
.hljs-title { color: var(--hljs-title); }
.hljs-params { color: var(--hljs-params); }
.hljs-built_in { color: var(--hljs-built_in); }
.hljs-literal { color: var(--hljs-literal); }
.hljs-variable { color: var(--hljs-variable); }
.hljs-type { color: var(--hljs-type); }
.hljs-attr { color: var(--hljs-attr); }
.hljs-selector { color: var(--hljs-selector); }

pre {
  margin: 0;
  white-space: pre-wrap;
  word-break: break-word;
  tab-size: 2;
}

code {
  font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, 'Courier New', monospace;
}
</style>
=== END FILE: ./src/components/messages/CodePreview.vue ===


=== START FILE: ./src/components/messages/MessageContent.vue ===
=== TYPE: vue ===

<template>
  <div class="message-content">
    <!-- If streaming, show chunked output as it arrives -->
    <template v-if="isStreaming">
      <div v-for="(part, index) in streamingParts" :key="index" class="first:mt-0 mt-4">
        <CodePreview v-if="part.type === 'code'" :content="part.content" :is-streaming="!part.complete"
          :language="part.language || 'plaintext'" />
        <div v-else v-html="part.content" class="text-base-content whitespace-pre-wrap" />
      </div>
    </template>

    <!-- Otherwise, render the fully parsed content (once complete) -->
    <template v-else>
      <div v-for="(part, index) in parsedContent" :key="index" class="first:mt-0 mt-4">
        <CodePreview v-if="part.type === 'code'" :content="part.content" :is-streaming="false"
          :language="part.language" />
        <div v-else v-html="part.content" class="text-base-content whitespace-pre-wrap" />
      </div>
    </template>

    <!-- Optional "AI typing" indicator -->
    <div v-if="isStreaming" class="mt-2 flex gap-1">
      <span class="animate-bounce w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-75 w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-150 w-1.5 h-1.5 bg-primary rounded-full"></span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import CodePreview from './CodePreview.vue'
import { marked } from 'marked'
import DOMPurify from 'dompurify'

interface Props {
  content: string
  isStreaming?: boolean
}

interface ContentPart {
  type: 'text' | 'code'
  content: string
  language?: string
  complete?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  isStreaming: false
})

// Store the last complete content
const lastCompleteContent = ref('')

// Keep track of streaming parts
const streamingParts = ref<ContentPart[]>([])

// Watch for content changes during streaming
watch(
  () => props.content,
  async (newContent) => {
    if (!props.isStreaming) {
      // Store the complete content when streaming ends
      lastCompleteContent.value = newContent
      return
    }

    const parts: ContentPart[] = []
    let inCodeBlock = false
    let codeLanguage = ''
    let currentBuffer = ''
    let i = 0

    while (i < newContent.length) {
      if (newContent.slice(i, i + 3) === '```') {
        if (!inCodeBlock) {
          if (currentBuffer) {
            const html = await marked(currentBuffer)
            const safeHTML = DOMPurify.sanitize(html as string)
            parts.push({
              type: 'text',
              content: safeHTML,
              complete: true
            })
            currentBuffer = ''
          }
          let endOfLine = newContent.indexOf('\n', i + 3)
          if (endOfLine === -1) endOfLine = newContent.length
          codeLanguage = newContent.slice(i + 3, endOfLine).trim()

          inCodeBlock = true
          i = endOfLine + 1
        } else {
          parts.push({
            type: 'code',
            content: currentBuffer.trim(),
            language: codeLanguage || 'plaintext',
            complete: true
          })

          inCodeBlock = false
          codeLanguage = ''
          currentBuffer = ''
          i += 3
        }
      } else {
        currentBuffer += newContent[i]
        i++
      }
    }

    if (currentBuffer) {
      if (inCodeBlock) {
        parts.push({
          type: 'code',
          content: currentBuffer,
          language: codeLanguage || 'plaintext',
          complete: false
        })
      } else {
        const html = await marked(currentBuffer)
        const safeHTML = DOMPurify.sanitize(html)
        parts.push({
          type: 'text',
          content: safeHTML,
          complete: false
        })
      }
    }

    streamingParts.value = parts
  }
)

// Parse content for non-streaming mode
const parsedContent = computed<ContentPart[]>(() => {
  // Use the last complete content instead of props.content
  const contentToProcess = lastCompleteContent.value || props.content
  const parts: ContentPart[] = []
  let inCodeBlock = false
  let codeLanguage = ''
  let currentBuffer = ''

  const processMarkdown = (text: string) => {
    if (!text) return
    const html = marked(text)
    const safeHTML = DOMPurify.sanitize(html as string)
    parts.push({
      type: 'text',
      content: safeHTML,
      complete: true
    })
  }

  const lines = contentToProcess.split('\n')

  for (const line of lines) {
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        parts.push({
          type: 'code',
          content: currentBuffer,
          language: codeLanguage || 'plaintext',
          complete: true
        })
        currentBuffer = ''
        codeLanguage = ''
        inCodeBlock = false
      } else {
        if (currentBuffer) processMarkdown(currentBuffer)
        currentBuffer = ''
        codeLanguage = line.slice(3).trim()
        inCodeBlock = true
      }
    } else {
      currentBuffer += currentBuffer ? '\n' + line : line
    }
  }

  if (inCodeBlock) {
    parts.push({
      type: 'code',
      content: currentBuffer,
      language: codeLanguage || 'plaintext',
      complete: true
    })
  } else if (currentBuffer) {
    processMarkdown(currentBuffer)
  }

  return parts
})
</script>
=== END FILE: ./src/components/messages/MessageContent.vue ===


=== START FILE: ./src/components/messages/MessageTimestamp.vue ===
=== TYPE: vue ===


<!-- MessageTimestamp.vue -->
<template>
    <div
      class="absolute flex items-center px-3 py-1.5 gap-1.5 text-xs font-mono rounded-full 
             bg-white dark:bg-gray-800 shadow-sm border border-gray-200 dark:border-gray-700
             text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-700 
             transition-all duration-200"
      :class="side === 'right' ? 'left-[calc(100%+8px)] top-4' : 'right-[calc(100%+8px)] top-4'"
    >
      <Timer class="w-3 h-3" />
      <span>{{ formattedTime }}</span>
    </div>
  </template>
  
  <script setup lang="ts">
  // MessageTimestamp.vue
import { computed } from 'vue';
import { Timer } from 'lucide-vue-next';

const props = defineProps({
  timestamp: {
    type: String,
    required: true
  },
  side: {
    type: String,
    default: 'right',
    validator: (value: string) => ['left', 'right'].includes(value)
  }
});

const formattedTime = computed(() => {
  const date = new Date(props.timestamp);
  return `${
    date.getHours().toString().padStart(2, '0')
  }:${
    date.getMinutes().toString().padStart(2, '0')
  }:${
    date.getSeconds().toString().padStart(2, '0')
  }`;
});
  </script>
  
  <!-- Updated styles for BranchNode.vue -->
  <style>
  .message-bubble {
    @apply relative transition-all duration-200 rounded-lg p-4;
  }
  
  .message-bubble.user {
    @apply bg-blue-900/20 border-l-4 border-blue-500;
  }
  
  .message-bubble.assistant {
    @apply bg-purple-900/20 border-l-4 border-purple-500;
  }
  
  .message-bubble.inherited {
    @apply opacity-75 border-dashed;
  }
  
  .node-card {
    @apply backdrop-blur bg-gray-900/30 transition-all duration-300 border border-gray-700/50 rounded-lg;
  }
  
  .node-card:hover {
    @apply shadow-lg shadow-black/20 border-gray-600/50;
  }
  
  .selected .node-card {
    @apply ring-2 ring-blue-500/50;
  }
  
  .streaming .node-card {
    @apply relative;
  }
  
  .streaming .node-card::before {
    content: '';
    @apply absolute inset-0 rounded-lg;
    background: linear-gradient(90deg, 
      theme('colors.blue.500') 0%,
      theme('colors.purple.500') 50%,
      theme('colors.blue.500') 100%
    );
    background-size: 200% 100%;
    animation: flowBorder 4s linear infinite;
    z-index: 0;
    opacity: 0.2;
  }
  
  @keyframes flowBorder {
    0% { background-position: 100% 0; }
    100% { background-position: -100% 0; }
  }
  </style>
=== END FILE: ./src/components/messages/MessageTimestamp.vue ===


=== START FILE: ./src/components/models/ModelSelector.vue ===
=== TYPE: vue ===

<template>
  <div class="relative inline-block">
    <!-- Model Selection Button -->
    <button @click="toggleDropdown" @keydown.space.prevent="toggleDropdown" @keydown.enter.prevent="toggleDropdown"
      @keydown.m.prevent="focusModelSelector"
      class="w-64 bg-background border rounded-md px-3 py-2 text-sm flex items-center justify-between hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-950"
      ref="modelButton">
      <div class="flex items-center gap-2 overflow-hidden">
        <span v-if="selectedModel" class="flex items-center gap-2">
          <Badge
            :variant="selectedModel.source === 'ollama' ? 'default' : selectedModel.source === 'openrouter' ? 'secondary' : 'outline'"
            class="text-xs">
            {{ selectedModel.source === 'ollama' ? 'Local' : selectedModel.source === 'openrouter' ? 'Cloud' : 'Custom'
            }}
          </Badge>
          <span class="font-medium truncate">{{ selectedModel.name }}</span>
        </span>
        <span v-else>Select Model (M)</span>
      </div>
      <ChevronDown class="w-4 h-4 transition-transform" :class="{ 'rotate-180': isOpen }" />
    </button>

    <!-- Dropdown Menu -->
    <div v-show="isOpen" class="absolute right-0 mt-2 w-96 bg-white dark:bg-gray-950 border rounded-md shadow-lg z-30"
      role="dialog" aria-label="Model Selection">
      <!-- Search and Filter Bar -->
      <div class="p-3 border-b">
        <div class="relative mb-2">
          <Search class="absolute left-3 top-2.5 w-4 h-4 text-gray-400" />
          <input v-model="searchQuery" type="text" ref="searchInput"
            class="w-full pl-9 pr-3 py-2 border rounded-md bg-white dark:bg-gray-950 text-sm placeholder:text-gray-400"
            placeholder="Search models... (/)" @keydown.up.prevent="navigateList('up')"
            @keydown.down.prevent="navigateList('down')" @keydown.enter.prevent="selectHighlighted"
            @keydown.esc.prevent="closeDropdown" />
        </div>
        <!-- Price Filter -->
        <div class="flex gap-2 mt-2">
          <button v-for="filter in ['all', 'free', 'paid']" :key="filter" @click="priceFilter = filter"
            @keydown.enter="priceFilter = filter" class="px-3 py-1 text-xs rounded-md"
            :class="priceFilter === filter ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300' : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400'"
            tabindex="0">
            {{ filter.charAt(0).toUpperCase() + filter.slice(1) }}
          </button>
        </div>
      </div>

      <!-- Models List -->
      <div class="max-h-[60vh] overflow-y-auto bg-white dark:bg-gray-950" role="listbox" ref="modelsList">
        <!-- Custom Model Option -->
        <div class="border-b last:border-0 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800"
          :class="{ 'bg-blue-50 dark:bg-blue-900': highlightedIndex === filteredModels.length }"
          @click="selectCustomModel()" @keydown.enter="selectCustomModel()"
          @mouseover="highlightedIndex = filteredModels.length" role="option"
          :aria-selected="highlightedIndex === filteredModels.length" tabindex="0" ref="modelItems">
          <div class="p-3">
            <div class="flex items-center gap-2">
              <Badge variant="outline" class="text-xs">
                Custom
              </Badge>
              <span class="font-medium">Custom Model</span>
            </div>
          </div>
        </div>

        <!-- Combined Models List -->
        <div v-for="(model, index) in filteredModels" :key="model.id"
          class="border-b last:border-0 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800"
          :class="{ 'bg-blue-50 dark:bg-blue-900': highlightedIndex === index }" @click="selectModel(model)"
          @keydown.enter="selectModel(model)" @mouseover="highlightedIndex = index" role="option"
          :aria-selected="highlightedIndex === index" tabindex="0" ref="modelItems">
          <div class="p-3">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <Badge :variant="model.source === 'ollama' ? 'default' : 'secondary'" class="text-xs">
                  {{ model.source === 'ollama' ? 'Local' : model.provider }}
                </Badge>
                <span class="font-medium">{{ model.name }}</span>
              </div>
              <div v-if="isOpenRouterModel(model)" class="text-xs text-gray-500">
                ${{ model.pricing?.prompt }}/1K
              </div>
            </div>
            <p v-if="isOpenRouterModel(model) && model.description" class="mt-1 text-xs text-gray-500 line-clamp-2">
              {{ model.description }}
            </p>
            <div v-if="isOpenRouterModel(model) && model.tags?.length" class="flex gap-2 mt-2">
              <span v-for="tag in model.tags" :key="tag"
                class="px-1.5 py-0.5 text-[10px] rounded-full bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400">
                {{ tag }}
              </span>
            </div>
          </div>
        </div>

        <!-- Empty State -->
        <div v-if="filteredModels.length === 0 && searchQuery" class="p-8 text-center text-gray-500">
          <p class="text-sm">No models found matching "{{ searchQuery }}"</p>
        </div>
        <div v-else-if="filteredModels.length === 0" class="p-8 text-center text-gray-500">
          <p class="text-sm">No models available</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, nextTick, computed, onMounted, onBeforeUnmount, watch } from 'vue';
import { ChevronDown, Search } from 'lucide-vue-next';
import Badge from '../ui/Badge.vue';
import type { Model, OllamaModel, OpenRouterModel } from '../../types';

const props = defineProps<{
  apiKey?: string;
  selectedModel: Model | null;
}>();

const emit = defineEmits<{
  (e: 'select', model: Model): void;
}>();

// Refs
const isOpen = ref(false);
const searchQuery = ref('');
const priceFilter = ref<'all' | 'free' | 'paid'>('all');
const ollamaModels = ref<OllamaModel[]>([]);
const openRouterModels = ref<OpenRouterModel[]>([]);
const highlightedIndex = ref(0);
const modelButton = ref<HTMLButtonElement | null>(null);
const searchInput = ref<HTMLInputElement | null>(null);
const modelsList = ref<HTMLDivElement | null>(null);
const modelItems = ref<HTMLDivElement[]>([]);
const isChatInputFocused = ref(false);

// Navigation
const navigateList = (direction: 'up' | 'down') => {
  const maxIndex = filteredModels.value.length;
  if (direction === 'up') {
    highlightedIndex.value = highlightedIndex.value <= 0 ? maxIndex : highlightedIndex.value - 1;
  } else {
    highlightedIndex.value = highlightedIndex.value >= maxIndex ? 0 : highlightedIndex.value + 1;
  }

  // Scroll highlighted item into view
  const highlightedElement = modelItems.value[highlightedIndex.value];
  if (highlightedElement && modelsList.value) {
    highlightedElement.scrollIntoView({ block: 'nearest' });
  }
};

const selectHighlighted = () => {
  if (highlightedIndex.value === filteredModels.value.length) {
    selectCustomModel()
  } else {
    const model = filteredModels.value[highlightedIndex.value];
    if (model) {
      selectModel(model);
    }
  }
};

// Toggle and focus management
const focusModelSelector = () => {
  toggleDropdown();
  nextTick(() => {
    if (isOpen.value) {
      searchInput.value?.focus();
    }
  });
};

const toggleDropdown = () => {
  isOpen.value = !isOpen.value;
  if (isOpen.value) {
    highlightedIndex.value = 0;
    nextTick(() => {
      searchInput.value?.focus();
    });
  }
};

const closeDropdown = () => {
  isOpen.value = false;
  searchQuery.value = '';
  modelButton.value?.focus();
};

// Model selection
const selectModel = (model: Model) => {
  emit('select', model);
  closeDropdown();
};


const selectCustomModel = () => {
  emit('select', {
    id: 'custom_model', // A generic ID for custom models
    name: 'Custom Model',
    source: 'custom'
  });
  closeDropdown();
};

// Computed and utilities
const filteredModels = computed(() => {
  const query = searchQuery.value.toLowerCase();
  const allModels = [...ollamaModels.value, ...openRouterModels.value];

  return allModels
    .filter(model => {
      const matchesSearch = model.name.toLowerCase().includes(query) ||
        (model.source === 'openrouter' &&
          ((model as OpenRouterModel).description?.toLowerCase().includes(query) ||
            (model as OpenRouterModel).provider.toLowerCase().includes(query)));

      if (priceFilter.value === 'all') return matchesSearch;

      if (model.source === 'ollama') {
        return priceFilter.value === 'free' && matchesSearch;
      } else {
        const openRouterModel = model as OpenRouterModel;
        const isFree = openRouterModel.pricing.prompt === "0";
        return (
          (priceFilter.value === 'free' && isFree && matchesSearch) ||
          (priceFilter.value === 'paid' && !isFree && matchesSearch)
        );
      }
    })
    .sort((a, b) => {
      if (a.source !== b.source) {
        return a.source === 'ollama' ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
});

const isOpenRouterModel = (model: Model): model is OpenRouterModel => {
  return model.source === 'openrouter';
};

const handleGlobalKeydown = (e: KeyboardEvent) => {
  // Check if any input or textarea is focused
  const activeElement = document.activeElement;
  const isInputFocused = activeElement instanceof HTMLInputElement ||
    activeElement instanceof HTMLTextAreaElement;

  // Immediately prevent model selector if we're typing in an input
  if (isInputFocused) {
    // Still allow Escape to close the dropdown if it's open
    if (e.key === 'Escape' && isOpen.value) {
      closeDropdown();
    }
    return;
  }

  // Handle model selector shortcuts only if no input is focused
  if (e.key === 'm' && !isOpen.value) {
    e.preventDefault();
    focusModelSelector();
  }

  // Focus search with '/' key
  if (e.key === '/' && isOpen.value) {
    e.preventDefault();
    searchInput.value?.focus();
  }

  // Close with Escape
  if (e.key === 'Escape' && isOpen.value) {
    closeDropdown();
  }
};

// Remove the chat input focus tracking since we're now checking actively
onMounted(() => {
  document.addEventListener('keydown', handleGlobalKeydown);
  fetchOllamaModels();
  if (props.apiKey) {
    fetchOpenRouterModels();
  }
});

onBeforeUnmount(() => {
  document.removeEventListener('keydown', handleGlobalKeydown);
});
// Reset highlighted index when filtered models change
watch(filteredModels, () => {
  highlightedIndex.value = 0;
});

// API calls
const fetchOllamaModels = async () => {
  try {
    const response = await fetch('http://localhost:11434/api/tags');
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const data = await response.json();
    if (Array.isArray(data.models)) {
      ollamaModels.value = data.models.map((model: any) => ({
        id: model.name,
        name: model.name,
        source: 'ollama' as const
      }));
    }
  } catch (error) {
    console.error('Error fetching Ollama models:', error);
    ollamaModels.value = [];
  }
};

const fetchOpenRouterModels = async () => {
  if (!props.apiKey) return;

  try {
    const response = await fetch('https://openrouter.ai/api/v1/models', {
      headers: {
        'Authorization': `Bearer ${props.apiKey}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const data = await response.json();
    openRouterModels.value = data.data.map((model: any) => ({
      id: model.id,
      name: model.name.split(':')[1]?.trim() || model.name,
      source: 'openrouter' as const,
      provider: model.name.split(':')[0],
      description: model.description,
      pricing: {
        prompt: model.pricing.prompt,
        completion: model.pricing.completion
      },
      tags: [
        `${model.context_length}k context`,
        model.pricing.prompt === "0" ? "Free" : "Paid",
      ],
      context_length: model.context_length
    }));
  } catch (error) {
    console.error('Error fetching OpenRouter models:', error);
    openRouterModels.value = [];
  }
};
</script>
=== END FILE: ./src/components/models/ModelSelector.vue ===


=== START FILE: ./src/components/canvas/InfiniteCanvas.vue ===
=== TYPE: vue ===

// src/components/canvas/InfiniteCanvas.vue
<template>
  <div class="fixed inset-0 w-full h-full overflow-hidden bg-background">
    <!-- Main Canvas -->
    <div ref="canvasRef" class="absolute inset-0 transition-transform duration-500 ease-in-out"
      :class="{ '-translate-x-1/2': store.viewMode === '3d' }" @mousemove="handleMouseMove" @mouseup="handleMouseUp"
      @mouseleave="handleMouseUp" @mousedown="handleCanvasMouseDown" tabindex="0" @keydown="handleKeyDown">
      <!-- Canvas Transform Container -->
      <div class="absolute transform-gpu" :style="transformStyle">
        <!-- SVG Layer for Connections -->
        <svg class="absolute pointer-events-none overflow-visible" style="z-index: 1" :style="svgStyle"
          viewBox="0 0 100000 100000" preserveAspectRatio="none">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" class="fill-primary" />
            </marker>
          </defs>

          <template v-for="connection in store.connections" :key="`${connection.parent.id}-${connection.child.id}`">
            <SplineConnector :start-node="connection.parent" :end-node="connection.child" :card-width="store.CARD_WIDTH"
              :card-height="store.CARD_HEIGHT" :is-active="isConnectionActive(connection)" :zoom-level="zoom" />
          </template>
        </svg>

        <!-- Nodes Layer -->
        <div class="absolute" :style="nodesLayerStyle" style="z-index: 2">
          <BranchNode v-for="node in store.nodes" :key="node.id" :open-router-api-key="openRouterApiKey" :node="node"
            :is-selected="isNodeFocused(node.id)" :selected-model="selectedModel" :zoom="zoom"
            :model-registry="modelRegistry" @select="handleNodeSelect(node.id)" @drag-start="handleDragStart"
            @create-branch="handleCreateBranch" @update-title="store.updateNodeTitle"
            @resend="(userMessageIndex) => handleResend(node.id, userMessageIndex)"
            @delete="() => store.removeNode(node.id)" :style="{
              transform: `translate(${node.x}px, ${node.y}px)`,
              transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
            }" />
        </div>
      </div>
    </div>

    <!-- Zoom Level Display -->
    <div
      class="fixed bottom-4 left-1/2 transform -translate-x-1/2 px-3 py-1.5 bg-base-200/90 backdrop-blur rounded-full border border-base-300 shadow-lg">
      <span class="text-sm font-medium text-base-content">
        {{ Math.round(zoom * 100) }}%
      </span>
    </div>

    <button
      class="fixed bottom-4 right-4 px-3 py-1.5 bg-base-200/90 backdrop-blur rounded-full border border-base-300 shadow-lg hover:bg-base-300/90 transition-colors"
      @click="autoZoomEnabled = !autoZoomEnabled">
      <span class="text-sm font-medium text-base-content">
        Auto-center: {{ autoZoomEnabled ? 'On' : 'Off' }}
      </span>
    </button>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount, watch } from 'vue';
import { useCanvasStore } from '../../stores/canvasStore';
import BranchNode from './node/BranchNode.vue';
import SplineConnector from './spline/SplineConnector.vue';

const props = defineProps({
  selectedModel: {
    type: String,
    required: true,
    default: ''
  },
  openRouterApiKey: {
    type: String,
    required: true
  },
  modelType: {
    type: String,
    required: true,
    default: ''
  }
});

// Add near the top with other refs
const modelRegistry = ref(new Map<string, ModelInfo>());

// Add the ModelInfo interface
interface ModelInfo {
  id: string;
  name: string;
  source: 'ollama' | 'openrouter' | 'custom';
  provider?: string;
}

const store = useCanvasStore();
const canvasRef = ref(null);

// State
const zoom = ref(1);
const panX = ref(0);
const panY = ref(0);
const isPanning = ref(false);
const lastPanPosition = ref({ x: 0, y: 0 });
const focusedNodeId = ref(null);

const lastActivityTimestamp = ref(Date.now());
const autoZoomEnabled = ref(true);
const isAutoZooming = ref(false);
const AUTO_CENTER_DELAY = 30000; // 5 seconds
const inactivityTimer = ref(null);

// Helper Functions
const getNodeCenter = (node) => ({
  x: node.x + store.CARD_WIDTH / 2,
  y: node.y + store.CARD_HEIGHT / 2
});



const transformStyle = computed(() => ({
  transform: `scale(${zoom.value}) translate(${panX.value / zoom.value}px, ${panY.value / zoom.value}px)`,
  transformOrigin: '0 0',
  width: '100000px',
  height: '100000px',
  background: 'transparent', // Changed from 'inherit'
  transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
}));

// Add new computed properties for SVG and nodes layer
const svgStyle = computed(() => ({
  width: '100000px',
  height: '100000px'
}));

const nodesLayerStyle = computed(() => ({
  width: '100000px',
  height: '100000px',
  left: 0,
  top: 0
}));

const handleNodeSelect = (nodeId: string) => {
  // Center the view on the selected node
  centerOnNode(nodeId);
  // Update the focused node
  focusedNodeId.value = nodeId;
};

const handleWheel = (e) => {
  resetInactivityTimer();
  // If it's a zoom event (Ctrl/Cmd + wheel)
  if (e.metaKey || e.ctrlKey) {
    e.preventDefault();

    const ZOOM_SENSITIVITY = 0.001; // Increased for smoother zoom
    const ZOOM_MIN = 0.1;
    const ZOOM_MAX = 5;

    const rect = canvasRef.value.getBoundingClientRect();

    // Get mouse position relative to viewport
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Calculate mouse position relative to content
    const mouseContentX = (mouseX - panX.value) / zoom.value;
    const mouseContentY = (mouseY - panY.value) / zoom.value;

    // Calculate new zoom level
    const delta = -e.deltaY;
    const newZoom = Math.min(
      Math.max(zoom.value * (1 + delta * ZOOM_SENSITIVITY), ZOOM_MIN),
      ZOOM_MAX
    );

    // Update the zoom level
    zoom.value = newZoom;

    // Adjust pan to keep mouse position fixed
    panX.value = mouseX - mouseContentX * newZoom;
    panY.value = mouseY - mouseContentY * newZoom;
  } else {
    // Regular panning
    panX.value -= e.deltaX;
    panY.value -= e.deltaY;
  }
};

onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
  if (canvasRef.value) {
    canvasRef.value.addEventListener('wheel', handleWheel, { passive: false });
  }

  // Initial centering of nodes
  if (store.nodes.length) {
    autoFitNodes();
  }

  // Start inactivity timer
  resetInactivityTimer();
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyDown);
  if (canvasRef.value) {
    canvasRef.value.removeEventListener('wheel', handleWheel);
  }
  if (inactivityTimer.value) {
    clearTimeout(inactivityTimer.value);
  }
});

watch(() => store.nodes.length, () => {
  resetInactivityTimer();
});


const centerOnNode = (nodeId) => {
  const node = store.nodes.find(n => n.id === nodeId);
  if (!node) return;

  store.isTransitioning = true;
  const center = getNodeCenter(node);

  const rect = canvasRef.value.getBoundingClientRect();
  // Center the node in the viewport
  panX.value = (rect.width / 2) - (center.x * zoom.value);
  panY.value = (rect.height / 2) - (center.y * zoom.value);

  focusedNodeId.value = nodeId;

  setTimeout(() => {
    store.isTransitioning = false;
  }, 300);
};

const handleResend = async (nodeId: string, userMessageIndex: number) => {
  const node = store.nodes.find(n => n.id === nodeId);
  if (!node || !node.messages) return;

  const userMsg = node.messages[userMessageIndex];
  if (!userMsg || userMsg.role !== 'user') return;

  // Remove the AI response that follows this user message
  store.removeMessage(nodeId, userMessageIndex + 1);

  // Set up model info in registry before sending
  let modelInfo: ModelInfo;
   if(props.selectedModel === 'custom_model'){
    modelInfo = {
      id: 'custom_model',
      name: 'Custom Model',
      source: 'custom'
    };
  } else {
      modelInfo = {
          id: props.selectedModel,
          name: props.selectedModel.includes('/') ? props.selectedModel.split('/')[1] : props.selectedModel,
          source: props.modelType === 'ollama' ? 'ollama' : 'openrouter',
          provider: props.modelType === 'openrouter' ? props.selectedModel.split('/')[0] : undefined
      };
  }

  modelRegistry.value.set(props.selectedModel, modelInfo);

  // Pass false for addUserMessage since we're reusing the existing message
  await store.sendMessage(nodeId, userMsg.content, props.selectedModel, props.openRouterApiKey, false);
};

const findNodeInDirection = (currentNode, connections, direction) => {
  const connectedNodes = connections
    .filter(conn =>
      conn.parent.id === currentNode.id ||
      conn.child.id === currentNode.id
    )
    .map(conn =>
      conn.parent.id === currentNode.id ? conn.child : conn.parent
    );

  const currentCenter = getNodeCenter(currentNode);

  return connectedNodes
    .filter(node => {
      const nodeCenter = getNodeCenter(node);
      return direction === 'up'
        ? nodeCenter.y < currentCenter.y
        : nodeCenter.y > currentCenter.y;
    })
    .sort((a, b) => {
      const aCenter = getNodeCenter(a);
      const bCenter = getNodeCenter(b);
      const aDist = Math.abs(aCenter.y - currentCenter.y);
      const bDist = Math.abs(bCenter.y - currentCenter.y);
      return aDist - bDist;
    })[0]?.id;
};


const handleMouseUp = () => {
  store.isDragging = false;
  store.activeNode = null;
  isPanning.value = false;
};

const handleCanvasMouseDown = (e) => {
  if (e.button === 0 && !store.isDragging) {
    isPanning.value = true;
    lastPanPosition.value = { x: e.clientX - panX.value, y: e.clientY - panY.value };
  }
};

const handleKeyDown = (e) => {
  if (store.isTransitioning) return;

  const currentNode = store.nodes.find(n => n.id === focusedNodeId.value);
  if (!currentNode) return;

  const connections = store.connections;
  let targetNodeId = null;

  switch (e.key) {
    case 'ArrowUp':
      targetNodeId = findNodeInDirection(currentNode, connections, 'up');
      break;
    case 'ArrowDown':
      targetNodeId = findNodeInDirection(currentNode, connections, 'down');
      break;
    case 'ArrowRight':
      targetNodeId = currentNode.parentId;
      break;
    case 'ArrowLeft':
      targetNodeId = connections
        .find(conn => conn.parent.id === currentNode.id)?.child.id;
      break;
  }

  if (targetNodeId) {
    centerOnNode(targetNodeId);
  }
};

// Event Handlers
const calculateNodesBounds = () => {
  if (!store.nodes.length) return null;

  const bounds = store.nodes.reduce((acc, node) => {
    const nodeWidth = store.CARD_WIDTH;
    const nodeHeight = store.CARD_HEIGHT;

    return {
      minX: Math.min(acc.minX, node.x),
      maxX: Math.max(acc.maxX, node.x + nodeWidth),
      minY: Math.min(acc.minY, node.y),
      maxY: Math.max(acc.maxY, node.y + nodeHeight)
    };
  }, {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  });

  return bounds;
};

// Function to auto-center and zoom to fit all nodes
const autoFitNodes = () => {
  if (!canvasRef.value || !autoZoomEnabled.value || store.isDragging || isPanning.value) return;

  const bounds = calculateNodesBounds();
  if (!bounds) return;

  const rect = canvasRef.value.getBoundingClientRect();
  const padding = 100; // Padding around the nodes

  // Calculate required zoom to fit all nodes
  const contentWidth = bounds.maxX - bounds.minX + (padding * 2);
  const contentHeight = bounds.maxY - bounds.minY + (padding * 2);
  const scaleX = rect.width / contentWidth;
  const scaleY = rect.height / contentHeight;
  const newZoom = Math.min(scaleX, scaleY, 1); // Cap zoom at 1 to prevent too much zoom

  // Calculate center point of all nodes
  const centerX = (bounds.minX + bounds.maxX) / 2;
  const centerY = (bounds.minY + bounds.maxY) / 2;

  isAutoZooming.value = true;
  store.isTransitioning = true;

  // Animate to new position and zoom
  zoom.value = newZoom;
  panX.value = (rect.width / 2) - (centerX * newZoom);
  panY.value = (rect.height / 2) - (centerY * newZoom);

  setTimeout(() => {
    isAutoZooming.value = false;
    store.isTransitioning = false;
  }, 300);
};

// Function to reset inactivity timer
const resetInactivityTimer = () => {
  if (inactivityTimer.value) {
    clearTimeout(inactivityTimer.value);
  }

  lastActivityTimestamp.value = Date.now();

  inactivityTimer.value = setTimeout(() => {
    if (Date.now() - lastActivityTimestamp.value >= AUTO_CENTER_DELAY) {
      autoFitNodes();
    }
  }, AUTO_CENTER_DELAY);
};


const handleMouseMove = (e) => {
  resetInactivityTimer();
  
  if (store.isDragging && store.activeNode) {
    // Handle node dragging
    const canvasRect = canvasRef.value.getBoundingClientRect();
    
    // Calculate the new position in canvas space
    const canvasX = (e.clientX - canvasRect.left - panX.value) / zoom.value;
    const canvasY = (e.clientY - canvasRect.top - panY.value) / zoom.value;
    
    // Update node position accounting for the initial click offset
    store.updateNodePosition(store.activeNode, {
      x: canvasX - store.dragOffset.x,
      y: canvasY - store.dragOffset.y
    });
  } else if (isPanning.value) {
    // Handle canvas panning
    const dx = e.clientX - lastPanPosition.value.x;
    const dy = e.clientY - lastPanPosition.value.y;
    panX.value = dx;
    panY.value = dy;
  }
};

const handleDragStart = (e, node) => {
  store.isDragging = true;
  store.activeNode = node.id;

  const canvasRect = canvasRef.value.getBoundingClientRect();

  // Calculate the initial click position in canvas space
  const canvasX = (e.clientX - canvasRect.left - panX.value) / zoom.value;
  const canvasY = (e.clientY - canvasRect.top - panY.value) / zoom.value;

  // Calculate offset from the node's position
  store.dragOffset = {
    x: canvasX - node.x,
    y: canvasY - node.y
  };
};

const handleCreateBranch = (parentId: string, messageIndex: number, position: { x: number, y: number }, initialData: any) => {
  const parentNode = store.nodes.find(n => n.id === parentId);
  if (!parentNode) return;

  // Find existing branches from this parent
  const existingBranches = store.nodes.filter(n => n.parentId === parentId);

  // Determine initial vertical offset based on number of existing branches
  const verticalOffset = existingBranches.length * (store.CARD_HEIGHT + 20);

  // Update position
  const adjustedPosition = {
    x: position.x,
    y: parentNode.y + verticalOffset
  };

  // Create the new node
  const newNode = store.addNode(parentId, messageIndex, adjustedPosition, {
    ...initialData,
    // Ensure vertical offset is preserved in node data
    y: adjustedPosition.y
  });

  // Center the view on the new node
  centerOnNode(newNode.id);
};

// Active State Checks
const isNodeFocused = (nodeId) => focusedNodeId.value === nodeId;

const isConnectionActive = (connection) => {
  if (!focusedNodeId.value) return false;
  return connection.parent.id === focusedNodeId.value ||
    connection.child.id === focusedNodeId.value;
};

// Lifecycle
onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
  canvasRef.value?.focus();

  if (store.nodes.length) {
    centerOnNode(store.nodes[0].id);
  }
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyDown);
});
</script>

<style scoped>
.transform-gpu {
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
  perspective: 1000px;
  overflow: hidden;
  /* Add this line */
}

div:focus {
  outline: none;
}

div:focus-visible {
  outline: none;
  box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.1);
}

/* Add these new styles */
.fixed {
  overflow: hidden;
}

.absolute {
  overflow: visible;
}
</style>
=== END FILE: ./src/components/canvas/InfiniteCanvas.vue ===


=== START FILE: ./src/components/canvas/spline/SplineConnector.vue ===
=== TYPE: vue ===

<template>
  <g>
    <!-- Shadow path -->
    <path :d="pathData" stroke="#94a3b8" stroke-width="4" fill="none" opacity="0.2" />
    <!-- Main path -->
    <path :d="pathData" :stroke="isActive ? '#2563eb' : '#94a3b8'" :stroke-width="isActive ? 3 : 2" fill="none"
      marker-end="url(#arrowhead)" class="transition-all duration-200" />

    <!-- Hidden path for text alignment -->
    <path :id="`connection-path-${startNode.id}-${endNode.id}`" :d="isLeftBranch ? reversedPathData : pathData" 
      fill="none" stroke="none" />

    <!-- Label Container -->
    <g class="label-container">
      <!-- Background for better readability -->
      <text class="text-container">
        <textPath :href="`#connection-path-${startNode.id}-${endNode.id}`" 
                  startOffset="50%" 
                  text-anchor="middle"
                  :side="isLeftBranch ? 'right' : 'left'"
                  :class="{ 'reversed': isLeftBranch }">
          <tspan :dy="-12" class="label-text" :style="labelStyle">
            <tspan @dblclick.stop.prevent="handleLabelDoubleClick" 
                   class="label-background" 
                   v-if="!isEditing">
              {{ getLabelText() }}
            </tspan>
          </tspan>
        </textPath>
      </text>

      <!-- Edit Input -->
      <foreignObject v-if="isEditing" 
                     :x="calculateLabelPosition().x" 
                     :y="calculateLabelPosition().y"
                     :width="300 / Math.min(1, zoomLevel)" 
                     :height="50 / Math.min(1, zoomLevel)" 
                     @dblclick.stop.prevent>
        <div xmlns="http://www.w3.org/2000/svg" class="flex items-center justify-center w-full h-full">
          <input ref="inputRef" 
                 v-model="labelInput" 
                 @blur="handleLabelBlur" 
                 @keydown="handleKeyDown"
                 class="bg-base-100 border border-base-300 rounded px-3 py-2 text-center w-full" 
                 :style="inputStyle" />
        </div>
      </foreignObject>
    </g>
  </g>
</template>

<script setup>
import { ref, computed, nextTick } from 'vue';

const props = defineProps({
  startNode: {
    type: Object,
    required: true
  },
  endNode: {
    type: Object,
    required: true
  },
  cardWidth: {
    type: Number,
    required: true
  },
  cardHeight: {
    type: Number,
    required: true
  },
  isActive: {
    type: Boolean,
    default: false
  },
  zoomLevel: {
    type: Number,
    default: 1
  }
});

const isEditing = ref(false);
const labelInput = ref('');
const customLabel = ref('');
const inputRef = ref(null);

const isLeftBranch = computed(() => {
  return props.endNode.type === 'left-branch';
});

// Compute font size based on zoom level
const fontSize = computed(() => {
  const baseSize = 14;
  const scaleFactor = 1 / Math.min(1, props.zoomLevel);
  return Math.max(baseSize * scaleFactor, baseSize);
});

const labelStyle = computed(() => ({
  fontSize: `${fontSize.value}px`,
  fontWeight: 500
}));

const inputStyle = computed(() => ({
  fontSize: `${fontSize.value}px`,
  fontWeight: 500,
  transform: `scale(${1 / props.zoomLevel})`,
  transformOrigin: 'center'
}));

const calculateConnectionPoints = () => {
  const messageIndex = props.endNode.branchMessageIndex || 0;
  const messageYOffset = messageIndex * 120 + 40; // Base message height plus padding

  const startPoint = {
    x: isLeftBranch.value
      ? props.startNode.x - 48 // Position for left branch button
      : props.startNode.x + props.cardWidth + 48, // Position for right branch button
    y: props.startNode.y + messageYOffset
  };

  const endPoint = {
    x: props.endNode.x + (isLeftBranch.value ? props.cardWidth : 0),
    y: props.endNode.y + props.cardHeight / 2
  };

  return { startPoint, endPoint };
};

const pathData = computed(() => {
  const { startPoint, endPoint } = calculateConnectionPoints();

  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  // Adjust control points based on branch direction and distance
  const controlPointDistance = Math.min(80, distance * 0.4);

  const controlPoint1 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y
  };

  const controlPoint2 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y
  };

  return `M ${startPoint.x} ${startPoint.y} 
          C ${controlPoint1.x} ${controlPoint1.y},
            ${controlPoint2.x} ${controlPoint2.y},
            ${endPoint.x} ${endPoint.y}`;
});

const reversedPathData = computed(() => {
  const { startPoint, endPoint } = calculateConnectionPoints();
  
  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const controlPointDistance = Math.min(80, distance * 0.4);

  const controlPoint1 = {
    x: endPoint.x + controlPointDistance,
    y: endPoint.y
  };

  const controlPoint2 = {
    x: startPoint.x - controlPointDistance,
    y: startPoint.y
  };

  return `M ${endPoint.x} ${endPoint.y} 
          C ${controlPoint1.x} ${controlPoint1.y},
            ${controlPoint2.x} ${controlPoint2.y},
            ${startPoint.x} ${startPoint.y}`;
});

const calculateLabelPosition = () => {
  const { startPoint, endPoint } = calculateConnectionPoints();
  const midX = startPoint.x + (endPoint.x - startPoint.x) / 2;
  const midY = startPoint.y + (endPoint.y - startPoint.y) / 2;
  
  return {
    x: midX - (150 / Math.min(1, props.zoomLevel)),
    y: midY - (25 / Math.min(1, props.zoomLevel))
  };
};

const getLabelText = () => {
  if (customLabel.value) {
    return customLabel.value;
  }

  const messageIndex = props.endNode.branchMessageIndex;
  const message = props.startNode.messages?.[messageIndex];

  if (message?.content) {
    const words = message.content.split(' ').slice(0, 3).join(' ');
    return words.length > 20 ? words.substring(0, 20) + '...' : words;
  }

  return `Branch ${messageIndex + 1}`;
};

const handleLabelDoubleClick = (event) => {
  event.stopPropagation();
  event.preventDefault();

  if (!isEditing.value) {
    isEditing.value = true;
    labelInput.value = customLabel.value || getLabelText();
    nextTick(() => {
      inputRef.value?.focus();
    });
  }
};

const handleLabelBlur = () => {
  if (labelInput.value.trim()) {
    customLabel.value = labelInput.value.trim();
  }
  isEditing.value = false;
};

const handleKeyDown = (event) => {
  if (event.key === 'Enter') {
    handleLabelBlur();
  } else if (event.key === 'Escape') {
    isEditing.value = false;
  }
};
</script>

<style scoped>
.text-container {
  pointer-events: none;
}

.label-text {
  pointer-events: none;
  fill: var(--color-base-content);
  opacity: 0.8;
}

.label-background {
  pointer-events: all;
  cursor: pointer;
  fill: currentColor;
  background: var(--color-base-100);
  padding: 4px 12px;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.label-background:hover {
  background: var(--color-base-200);
}

input {
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 2px var(--color-primary/0.2);
}

textPath.reversed {
  transform: scale(1, -1);
}
</style>
=== END FILE: ./src/components/canvas/spline/SplineConnector.vue ===


=== START FILE: ./src/components/canvas/node/BranchNode.vue ===
=== TYPE: vue ===

<template>
  <div class="branch-node" :data-node-id="node.id" :class="{
    'selected': isSelected,
    'streaming': node.streamingContent,
    'active': isStreaming,
    'fading-out': !node.streamingContent && isStreaming,
    'draggable': isDraggable
  }" @click="$emit('select')" @mousedown="handleMouseDown" @mousemove="handleMouseMove" @mouseup="handleMouseUp">
    <Card :class="[
      'node-card max-w-2xl w-[42rem]',
      'backdrop-blur transition-all duration-300'
    ]" :style="{
      ...nodeStyles,
      backgroundColor: `${threadColor}05`,
      '--tw-backdrop-blur': '8px',
      borderColor: `${threadColor}20`
    }">
      <!-- Model Avatars -->
      <div class="absolute -top-4 left-1/2 transform -translate-x-1/2 flex -space-x-2 px-2">
        <div v-for="model in uniqueModels" :key="model.id" class="relative group w-9 h-9">
          <img :src="getAvatarUrl(model)" alt="Provider Avatar"
            class="w-9 h-9 rounded-full border-2 border-base-100 shadow-md object-cover" />
          <div
            class="avatar-overlay transition-opacity duration-200 opacity-0 absolute inset-0 rounded-full bg-black/30 group-hover:opacity-100">
          </div>
          <div class="absolute bottom-full mb-2 hidden group-hover:block z-50"
            style="left: 50%; transform: translateX(-50%);">
            <div class="bg-base-100 border rounded-md shadow-lg px-2 py-1 text-xs whitespace-nowrap text-base-content">
              {{ model.name }}
            </div>
          </div>
        </div>
      </div>

      <div class="p-4">
        <div class="flex items-center justify-between mb-4">
          <!-- Header Content -->
          <div class="flex items-center gap-3">
            <button @click.stop="isExpanded = !isExpanded" class="p-2 rounded-full hover:bg-white/10 transition-colors"
              :style="{ color: threadColor }">
              <ChevronDown class="w-5 h-5 transition-transform duration-200" :class="{ '-rotate-90': !isExpanded }" />
            </button>

            <div class="flex flex-col">
              <!-- Title Section -->
              <div class="flex items-center gap-2">
                <template v-if="isEditing">
                  <input ref="titleInputRef" v-model="titleInput" @blur="handleTitleUpdate"
                    @keyup.enter="handleTitleUpdate" class="bg-base-100 px-2 py-1 rounded border text-base-content"
                    placeholder="Enter title..." />
                </template>
                <template v-else>
                  <span class="text-lg font-semibold truncate max-w-lg text-base-content">
                    {{ node.title || "Untitled Thread" }}
                  </span>
                  <button @click.stop="startEditing" class="p-1 rounded-full hover:bg-white/10 flex-shrink-0">
                    <Edit2 class="w-4 h-4 text-base-content/60" />
                  </button>
                </template>
              </div>

              <!-- Message Count -->
              <div class="flex items-center gap-2 mt-1">
                <MessageCircle class="w-4 h-4 text-base-content/60" />
                <span class="text-sm text-base-content/60">
                  {{ node.messages?.length || 0 }} messages
                </span>
              </div>
            </div>
          </div>

          <!-- Delete Button -->
          <button v-if="node.type !== 'main'"
            class="p-2 rounded-full hover:bg-destructive/10 text-base-content/60 hover:text-destructive flex-shrink-0"
            @click.stop="$emit('delete')">
            <X class="w-5 h-5" />
          </button>
        </div>

        <!-- Messages -->
        <div v-if="isExpanded && node.messages" class="space-y-4">
          <div v-for="(msg, i) in displayMessages" :key="i" class="relative group message-container"
            :style="getMessageStyles(i)">
            <MessageTimestamp :timestamp="msg.timestamp" :side="node.type === 'branch' ? 'left' : 'right'" />

            <!-- Branch Buttons -->
            <div
              class="absolute inset-y-0 -left-12 flex items-center opacity-0 group-hover:opacity-100 transition-all duration-200 ease-in-out z-20">
              <button @click.stop="createBranch(i, 'left')"
                class="p-2 rounded-full hover:bg-white/10 transition-colors group/btn" :style="{ color: threadColor }"
                title="Branch left">
                <div class="relative">
                  <GitBranch class="w-5 h-5 transform -scale-x-100" />
                  <div
                    class="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap opacity-0 group-hover/btn:opacity-100 transition-opacity duration-200 text-xs bg-base-300/90 backdrop-blur px-2 py-1 rounded">
                    Branch left
                  </div>
                </div>
              </button>
            </div>

            <div
              class="absolute inset-y-0 -right-12 flex items-center opacity-0 group-hover:opacity-100 transition-all duration-200 ease-in-out z-20">
              <button @click.stop="createBranch(i, 'right')"
                class="p-2 rounded-full hover:bg-white/10 transition-colors group/btn" :style="{ color: threadColor }"
                title="Branch right">
                <div class="relative">
                  <GitBranch class="w-5 h-5" />
                  <div
                    class="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap opacity-0 group-hover/btn:opacity-100 transition-opacity duration-200 text-xs bg-base-300/90 backdrop-blur px-2 py-1 rounded">
                    Branch right
                  </div>
                </div>
              </button>
            </div>

            <div class="p-4 relative z-10">
              <!-- Message Header -->
              <div class="flex items-center justify-between mb-2">
                <Badge :variant="msg.role === 'user' ? 'default' : msg.isStreaming ? 'outline' : 'secondary'"
                  class="text-xs">
                  {{ msg.role === 'user' ? 'You' : msg.isStreaming ? 'AI Typing...' : 'AI' }}
                </Badge>

                <div class="flex items-center gap-2" v-if="!msg.isStreaming">
                  <button @click.stop="expandMessage(i)" class="p-1.5 rounded-full hover:bg-white/10">
                    <component :is="expandedMessages.has(i) ? Maximize2 : Minimize2"
                      class="w-4 h-4 text-base-content/60" />
                  </button>
                </div>
              </div>

              <!-- Message Content -->
              <div class="text-sm break-words overflow-hidden" :class="{
                'line-clamp-2': expandedMessages.has(i),
                'whitespace-pre-wrap': !msg.isStreaming,
                'whitespace-normal': msg.isStreaming
              }">
                <MessageContent :content="msg.content" :is-streaming="msg.isStreaming" />
              </div>

              <!-- Message Actions -->
              <div class="mt-3 flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <button v-if="msg.isStreaming"
                    class="flex items-center gap-2 text-sm text-red-500 hover:underline opacity-0 group-hover:opacity-100 transition-opacity"
                    @click.stop="stopStreaming">
                    <XCircle class="w-4 h-4" />
                    Stop
                  </button>

                  <button v-else-if="msg.role === 'assistant'"
                    class="flex items-center gap-2 text-sm hover:underline opacity-0 group-hover:opacity-100 transition-opacity"
                    :style="{ color: threadColor }" @click.stop="$emit('resend', i - 1)">
                    <RotateCw class="w-4 h-4" />
                    Resend
                  </button>
                </div>

                <!-- Model Badge -->
                <div v-if="msg.role === 'assistant'"
                  class="model-badge opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-2 px-3 py-1 rounded-full text-xs bg-base-100/90 border border-base-200">
                  <img :src="getAvatarUrl(getModelInfo(msg.modelId))" alt="Model Avatar"
                    class="w-4 h-4 rounded-full object-cover" />
                  <span class="text-base-content">
                    {{ getModelInfo(msg.modelId)?.name || 'Unknown Model' }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Collapsed View -->
        <div v-else-if="node.messages?.length" class="mt-2 text-sm text-base-content/60">
          <div class="line-clamp-2 break-words overflow-hidden">
            Last message:
            {{ node.streamingContent || node.messages[node.messages.length - 1]?.content }}
          </div>
        </div>
      </div>

      <MessageInput :is-loading="isLoading" @send="handleMessageSend" @stop="stopStreaming" />
    </Card>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, nextTick, onBeforeUnmount, watch } from 'vue';
import type { PropType } from 'vue';
import {
  ChevronDown, MessageCircle, Edit2, X,
  Maximize2, Minimize2, XCircle, RotateCw
} from 'lucide-vue-next';

import MessageInput from '../../messages/MessageInput.vue';
import { useCanvasStore } from '../../../stores/canvasStore';
import Card from '../../ui/Card.vue';
import Badge from '../../ui/Badge.vue';
import MessageContent from '../../messages/MessageContent.vue';
import MessageTimestamp from '../../messages/MessageTimestamp.vue';
import type { Message, Node } from '../../../types/message';
import anthropic from '@/assets/anthropic.jpeg'
import openai from '@/assets/openai.jpeg'
import google from '@/assets/google.jpeg'
import meta from '@/assets/meta.jpeg'
import mistral from '@/assets/mistral.jpeg'
import unknownAvatar from '@/assets/unknown.jpeg'
import ollama from '@/assets/ollama.jpeg'
import { GitBranch } from 'lucide-vue-next';

interface ModelInfo {
  id: string;
  name: string;
  source: 'ollama' | 'openrouter';
  provider?: string;
}

interface ExtendedMessage extends Message {
  modelId?: string;
}

interface ExtendedNode extends Node {
  messages: ExtendedMessage[];
  streamingContent: string | null
}

const props = defineProps({
  node: {
    type: Object as PropType<ExtendedNode>,
    required: true
  },
  isSelected: Boolean,
  selectedModel: {
    type: String,
    required: true
  },
  openRouterApiKey: {
    type: String,
    required: true
  },
  zoom: {
    type: Number,
    required: true
  },
  modelRegistry: {
    type: Object as PropType<Map<string, ModelInfo>>,
    required: true
  }
});


const emit = defineEmits(['select', 'drag-start', 'create-branch', 'update-title', 'delete', 'resend']);

// UI states
const isExpanded = ref(true);
const isEditing = ref(false);
const titleInput = ref('');
const expandedMessages = ref(new Set<number>());
const titleInputRef = ref<HTMLElement | null>(null);
const isDraggable = ref(false);
const dragStartPosition = ref({ x: 0, y: 0 });
const DRAG_THRESHOLD = 5; // Pixels to move before initiating drag
const isStreaming = ref(false);
const fadeTimeout = ref<number | null>(null);

// Store
const store = useCanvasStore();

// Loading / streaming states
const isLoading = ref(false);
// We'll store a single AbortController for the current request
let abortController: AbortController | null = null;

// Watch for title changes
watch(
  () => props.node.title,
  (newTitle) => {
    titleInput.value = newTitle || '';
  },
  { immediate: true }
);

watch(() => props.node.streamingContent, (newVal) => {
  if (newVal) {
    // Clear any existing timeout
    if (fadeTimeout.value) {
      clearTimeout(fadeTimeout.value);
    }
    isStreaming.value = true;
  } else if (isStreaming.value) {
    // Only start fade out if we were streaming
    fadeTimeout.value = setTimeout(() => {
      isStreaming.value = false;
    }, 1000); // Match this to your transition duration
  }
});

const threadColor = computed(() => {
  const hues = [210, 330, 160, 280, 40, 190];
  // Simple pseudo-random approach based on the node ID
  const index = Math.abs(Math.floor(Number(props.node.id) * Math.sin(Number(props.node.id))) % hues.length);
  return `hsl(${hues[index]}, 85%, 45%)`;
});

const displayMessages = computed((): Message[] => {
  if (!props.node.messages) return [];
  return props.node.streamingContent
    ? [
      ...props.node.messages,
      {
        role: 'assistant',
        content: props.node.streamingContent,
        isStreaming: true,
        timestamp: new Date().toISOString()
      }
    ]
    : props.node.messages;
});

const providerAvatars: Record<string, string> = {
  Anthropic: anthropic,
  OpenAI: openai,
  Google: google,
  Meta: meta,
  Mistral: mistral,
  Unknown: unknownAvatar,
  ollama: ollama
};

function getAvatarUrl(model?: ModelInfo): string {
  if (!model) return providerAvatars['Unknown'];

  if (model.source === 'ollama') {
    return providerAvatars['ollama'];
  }

  // For openrouter models
  const avatar = model.provider ? providerAvatars[model.provider] : providerAvatars['Unknown'];
  return avatar || providerAvatars['Unknown'];
}

const uniqueModels = computed(() => {
  const models = new Set<ModelInfo>();
  if (!props.node.messages) return [];

  props.node.messages.forEach((msg) => {
    if (msg.modelId) {
      const model = getModelInfo(msg.modelId);
      if (model) models.add(model);
    }
  });
  return Array.from(models);
});


function getModelInfo(modelId?: string): ModelInfo | undefined {
  if (!modelId) return undefined;

  // First try to get from registry
  const registryModel = props.modelRegistry.get(modelId);
  if (registryModel) return registryModel;

  // Fallback: Parse from model ID if not in registry
  if (modelId.includes('/')) {
    const [provider, name] = modelId.split('/');
    return {
      id: modelId,
      name,
      source: 'openrouter',
      provider
    };
  }

  return {
    id: modelId,
    name: modelId,
    source: 'ollama'
  };
}

const nodeStyles = computed(() => ({
  '--border-color': threadColor.value,
  '--border-color-light': `${threadColor.value}50`
}));

/* ------------------
   Drag event handlers
------------------ */
const handleMouseDown = (e: MouseEvent) => {
  if (props.node.type !== 'main') {
    dragStartPosition.value = { x: e.clientX, y: e.clientY };
    isDraggable.value = true;
  }
};

const handleMouseMove = (e: MouseEvent) => {
  if (!isDraggable.value) return;
  const dx = Math.abs(e.clientX - dragStartPosition.value.x);
  const dy = Math.abs(e.clientY - dragStartPosition.value.y);

  if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
    e.stopPropagation();
    isDraggable.value = false;
    emit('drag-start', e, props.node);
  }
};

const handleMouseUp = () => {
  isDraggable.value = false;
};

/* ------------------
   Title editing
------------------ */
const startEditing = () => {
  isEditing.value = true;
  titleInput.value = props.node.title || '';
  nextTick(() => {
    if (titleInputRef.value) {
      (titleInputRef.value as HTMLInputElement).focus();
      (titleInputRef.value as HTMLInputElement).select();
    }
  });
};

const handleTitleUpdate = () => {
  if (titleInput.value.trim()) {
    emit('update-title', props.node.id, titleInput.value.trim());
  }
  isEditing.value = false;
};

/* ------------------
   Branch creation
------------------ */
const createBranch = (messageIndex: number, direction: 'left' | 'right') => {
  const horizontalOffset = direction === 'left'
    ? -store.CARD_WIDTH - 100
    : store.CARD_WIDTH + 100;

  // Calculate new branch position
  const position = {
    x: props.node.x + horizontalOffset,
    y: props.node.y  // Let handleCreateBranch handle vertical positioning
  };

  // Create initial data for the new branch
  const initialData = {
    title: `Branch from "${props.node.title || 'Untitled Thread'}"`,
    messages: props.node.messages.slice(0, messageIndex + 1),
    branchMessageIndex: messageIndex,
    // This is crucial for connector positioning
    type: direction === 'left' ? 'left-branch' : 'right-branch'
  };

  emit('create-branch', props.node.id, messageIndex, position, initialData);
};

/* ------------------
   Message sending
------------------ */

async function handleMessageSend(message: string) {
  isLoading.value = true;
  try {
    await store.sendMessage(props.node.id, message, props.selectedModel, props.openRouterApiKey);
    // Auto-generate title for new conversations
    if (props.node.messages.length === 2 && !props.node.title) {
      generateTitle();
    }
  } catch (error) {
    console.error('Error sending message:', error);
  } finally {
    isLoading.value = false;
  }
}

/* ------------------
   Title generator
------------------ */
async function generateTitle() {
  try {
    const messages = props.node.messages.slice(0, 3);
    const prompt = `Based on this conversation, suggest a concise and descriptive title (max 5 words):\n\n${messages
      .map((m) => `${m.role}: ${m.content}`)
      .join('\n')}`;

    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: props.selectedModel,
        prompt,
        system:
          'You are a helpful assistant. Respond only with the title - no explanations or additional text.',
        stream: false
      })
    });

    const data = await response.json();
    const generatedTitle = data.response.trim();
    emit('update-title', props.node.id, generatedTitle);
  } catch (error) {
    console.error('Error generating title:', error);
  }
}

/* ------------------
   Stop streaming
------------------ */
function stopStreaming() {
  if (abortController) {
    abortController.abort();
    store.setStreamingContent(props.node.id, null);
  }
}

/* ------------------
   Expand/collapse
------------------ */
const expandMessage = (index: number) => {
  const newSet = new Set(expandedMessages.value);
  if (newSet.has(index)) {
    newSet.delete(index);
  } else {
    newSet.add(index);
  }
  expandedMessages.value = newSet;
};

function getMessageStyles(index: number) {
  const isInherited =
    props.node.type === 'branch' &&
    props.node.branchMessageIndex !== null &&
    index <= props.node.branchMessageIndex;

  const baseColor = threadColor.value;
  const messageBackground = isInherited
    ? `linear-gradient(to right, ${baseColor}03, ${baseColor}08)`
    : `linear-gradient(to right, ${baseColor}08, ${baseColor}15)`;

  return {
    background: messageBackground,
    borderLeft: `4px ${isInherited ? 'dashed' : 'solid'} ${baseColor}`,
    borderRadius: '0.5rem',
    position: 'relative' as const,
    transition: 'box-shadow 0.3s ease',
    ...(isInherited && {
      boxShadow: `inset 0 0 0 1px ${baseColor}10`
    })
  };
}

onMounted(() => {
  if (!props.node.title) {
    isEditing.value = true;
  }
});

onBeforeUnmount(() => {
  isDraggable.value = false;
  if (fadeTimeout.value) {
    clearTimeout(fadeTimeout.value);
  }
});
</script>

<style scoped>
.branch-node {
  position: absolute;
  transition: transform 0.2s ease;
  user-select: none;
}

.draggable:active {
  cursor: grabbing;
}

.node-card {
  backdrop-filter: blur(8px);
  margin: 4px;
  transition: all 0.3s ease;
  position: relative;
}

.node-card:hover {
  box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1);
}

.selected .node-card {
  ring: 2px;
  ring-color: rgb(59 130 246);
}

/* Base streaming states */
.streaming .node-card::before,
.streaming .node-card::after {
  content: '';
  position: absolute;
  border-radius: inherit;
  background: linear-gradient(90deg,
      #ff1493 0%,
      #ff6347 15%,
      #ffd700 30%,
      #32cd32 45%,
      #4169e1 60%,
      #9400d3 75%,
      #ff1493 90%,
      #ff6347 100%);
  background-size: 200% 100%;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  animation: flowBorder 3s linear infinite;
  opacity: 0;
  transition: opacity 1s ease-in-out;
  z-index: 0;
}

.streaming .node-card::before {
  inset: -2px;
  /* Reduced from -4px */
  padding: 2px;
  /* Reduced from 4px */
  filter: blur(3px);
  /* Slightly reduced blur */
}

.streaming .node-card::after {
  inset: -1px;
  /* Reduced from -2px */
  padding: 1px;
  /* Reduced from 2px */
  filter: blur(1px);
  /* Reduced blur for sharper inner border */
}

/* Animation states */
.branch-node.active .node-card::before,
.branch-node.active .node-card::after {
  opacity: 1;
}

.branch-node.fading-out .node-card::before,
.branch-node.fading-out .node-card::after {
  opacity: 0;
}

@keyframes flowBorder {
  0% {
    background-position: 100% 0;
  }

  100% {
    background-position: -100% 0;
  }
}

/* Fix for child content rotation in streaming */
.streaming .node-card>* {
  position: relative;
  z-index: 1;
}

.model-badge {
  animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-container {
  position: relative;
  transition: all 0.2s ease-in-out;
}

.message-container:hover {
  transform: translateX(0);
}

.branch-button {
  transform: translateX(20px);
  opacity: 0;
  transition: all 0.2s ease-in-out;
}

.message-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: -12px;
  right: -12px;
  bottom: 0;
  z-index: -1;
}

/* Ensure branch buttons have enough hover area */
.message-container .absolute {
  padding: 0.5rem;
  margin: -0.5rem;
}

.message-container:hover .branch-button {
  transform: translateX(0);
  opacity: 1;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

.avatar-overlay {
  border-radius: 9999px;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
</style>
=== END FILE: ./src/components/canvas/node/BranchNode.vue ===


=== START FILE: ./src/components/manager/TaskManager.vue ===
=== TYPE: vue ===

<script setup lang="ts">
import { ref, onMounted, computed, watch } from 'vue';
import { Plus, X, ChevronDown, ChevronUp, Trash2 } from 'lucide-vue-next';

interface Task {
  id: string;
  title: string;
  description: string;
  status: 'todo' | 'in-progress' | 'done';
  type: 'feature' | 'bug';
  dateCreated: string;
  dateUpdated: string;
}

const tasks = ref<Task[]>([]);
const showNewTaskForm = ref(false);
const newTask = ref({
  title: '',
  description: '',
  type: 'feature' as const
});
const expandedTaskId = ref<string | null>(null);
const filterStatus = ref<Task['status'] | 'all'>('all');
const filterType = ref<Task['type'] | 'all'>('all');

const addTask = () => {
  if (!newTask.value.title.trim()) return;
  
  const now = new Date().toISOString();
  tasks.value.unshift({
    id: crypto.randomUUID(),
    title: newTask.value.title,
    description: newTask.value.description,
    status: 'todo',
    type: newTask.value.type,
    dateCreated: now,
    dateUpdated: now
  });
  
  newTask.value = {
    title: '',
    description: '',
    type: 'feature'
  };
  showNewTaskForm.value = false;
};

const cancelNewTask = () => {
  newTask.value = {
    title: '',
    description: '',
    type: 'feature'
  };
  showNewTaskForm.value = false;
};

const deleteTask = (taskId: string) => {
  tasks.value = tasks.value.filter(task => task.id !== taskId);
  if (expandedTaskId.value === taskId) {
    expandedTaskId.value = null;
  }
};

const updateTaskStatus = (task: Task, status: Task['status']) => {
  task.status = status;
  task.dateUpdated = new Date().toISOString();
};

const toggleExpand = (taskId: string) => {
  expandedTaskId.value = expandedTaskId.value === taskId ? null : taskId;
};

const filteredTasks = computed(() => {
  return tasks.value.filter(task => {
    const statusMatch = filterStatus.value === 'all' || task.status === filterStatus.value;
    const typeMatch = filterType.value === 'all' || task.type === filterType.value;
    return statusMatch && typeMatch;
  });
});

const getStatusColor = (status: Task['status']) => {
  switch (status) {
    case 'todo': return 'bg-blue-500/10 text-blue-500';
    case 'in-progress': return 'bg-yellow-500/10 text-yellow-500';
    case 'done': return 'bg-green-500/10 text-green-500';
  }
};

onMounted(() => {
  const savedTasks = localStorage.getItem('projectTasks');
  if (savedTasks) tasks.value = JSON.parse(savedTasks);
});

watch(tasks, (newTasks) => {
  localStorage.setItem('projectTasks', JSON.stringify(newTasks));
}, { deep: true });
</script>

<template>
  <div class="space-y-6">
    <!-- Header with New Task Button -->
    <div class="flex justify-between items-center">
      <div class="flex gap-2 text-sm">
        <select v-model="filterStatus" class="select select-sm select-bordered">
          <option value="all">All Status</option>
          <option value="todo">Todo</option>
          <option value="in-progress">In Progress</option>
          <option value="done">Done</option>
        </select>
        <select v-model="filterType" class="select select-sm select-bordered">
          <option value="all">All Types</option>
          <option value="feature">Features</option>
          <option value="bug">Bugs</option>
        </select>
      </div>
      
      <button 
        v-if="!showNewTaskForm"
        class="btn btn-sm btn-primary"
        @click="showNewTaskForm = true"
      >
        <Plus class="w-4 h-4" />
        New Task
      </button>
    </div>

    <!-- New Task Form (Collapsible) -->
    <div 
      v-if="showNewTaskForm"
      class="border border-base-300 rounded-lg p-4 space-y-3 bg-base-200/50"
    >
      <div class="flex justify-between items-center">
        <h3 class="font-medium">Create New Task</h3>
        <button 
          class="btn btn-ghost btn-sm btn-square"
          @click="cancelNewTask"
        >
          <X class="w-4 h-4" />
        </button>
      </div>
      
      <input
        v-model="newTask.title"
        type="text"
        placeholder="Task title..."
        class="input input-sm input-bordered w-full"
        @keyup.enter="addTask"
      />
      
      <textarea
        v-model="newTask.description"
        placeholder="Description (optional)"
        class="textarea textarea-bordered textarea-sm w-full h-20 resize-none"
      />
      
      <div class="flex gap-2">
        <select v-model="newTask.type" class="select select-sm select-bordered flex-1">
          <option value="feature">Feature</option>
          <option value="bug">Bug</option>
        </select>
        <button 
          class="btn btn-sm btn-primary"
          @click="addTask"
        >
          Create Task
        </button>
      </div>
    </div>

    <!-- Tasks List -->
    <div class="space-y-2">
      <div 
        v-for="task in filteredTasks" 
        :key="task.id" 
        class="border border-base-300 rounded-lg overflow-hidden hover:border-base-content/20 transition-colors"
      >
        <!-- Task Header -->
        <div 
          class="flex items-center justify-between p-3 cursor-pointer"
          @click="toggleExpand(task.id)"
        >
          <div class="flex items-center gap-3 min-w-0">
            <span 
              class="px-2 py-0.5 rounded-full text-xs capitalize"
              :class="getStatusColor(task.status)"
            >
              {{ task.status }}
            </span>
            <span 
              class="px-2 py-0.5 rounded-full text-xs capitalize"
              :class="task.type === 'bug' ? 'bg-red-500/10 text-red-500' : 'bg-purple-500/10 text-purple-500'"
            >
              {{ task.type }}
            </span>
            <span class="truncate">{{ task.title }}</span>
          </div>
          <component 
            :is="expandedTaskId === task.id ? ChevronUp : ChevronDown" 
            class="w-4 h-4 opacity-50"
          />
        </div>
        
        <!-- Task Details -->
        <div 
          v-if="expandedTaskId === task.id"
          class="p-3 pt-0 space-y-3 text-sm"
        >
          <p class="text-base-content/70 whitespace-pre-wrap">
            {{ task.description || 'No description provided.' }}
          </p>
          
          <div class="flex items-center gap-2">
            <select 
              v-model="task.status" 
              class="select select-sm select-bordered"
              @change="updateTaskStatus(task, $event.target.value)"
            >
              <option value="todo">Todo</option>
              <option value="in-progress">In Progress</option>
              <option value="done">Done</option>
            </select>
            
            <button 
              class="btn btn-ghost btn-sm text-error"
              @click="deleteTask(task.id)"
              title="Delete task"
            >
              <Trash2 class="w-4 h-4" />
            </button>
            
            <div class="flex-1" />
            
            <div class="text-xs text-base-content/50">
              Updated {{ new Date(task.dateUpdated).toLocaleString() }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
=== END FILE: ./src/components/manager/TaskManager.vue ===


=== START FILE: ./src/components/logo/TangentLogo.vue ===
=== TYPE: vue ===

// TangentLogo.vue
<template>
  <div
    class="w-[180px] h-[36px] relative perspective-[1000px] rounded-lg overflow-hidden"
  >
    <div
      ref="gridRef"
      class="w-full h-full grid relative gap-0"
      :style="{
        gridTemplateColumns: `repeat(${COLS}, 1fr)`,
        gridTemplateRows: `repeat(${ROWS}, 1fr)`
      }"
    >
      <div
        v-for="(_, i) in cells"
        :key="i"
        class="relative transition-transform duration-1000 ease-in-out cell"
        :style="{
          transformStyle: 'preserve-3d',
          border: 'none',
          backgroundColor: 'transparent'
        }"
      >
        <div
          class="absolute w-full h-full overflow-hidden front"
          :style="{
            backfaceVisibility: 'hidden',
            backgroundColor: 'transparent'
          }"
        >
          <div
            class="w-[180px] h-[36px] relative"
            :style="{
              transform: `translate(${-(i % COLS) * (180 / COLS)}px, ${-Math.floor(i / COLS) * (36 / ROWS)}px)`
            }"
          >
            <LogoSVG />
          </div>
        </div>
        <div
          class="absolute w-full h-full overflow-hidden back"
          :style="{
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)',
            backgroundColor: 'transparent'
          }"
        >
          <div
            class="absolute w-[180px] h-[36px]"
            :style="{
              transform: `translate(${-(i % COLS) * (180 / COLS)}px, ${-Math.floor(i / COLS) * (36 / ROWS)}px)`
            }"
          >
            <div class="font-sans text-[24px] font-bold w-full h-full ps-4 flex items-center justify-center text-foreground">
              TANGENT
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import LogoSVG from './LogoSVG.vue';

const COLS = 15;
const ROWS = 5;
const cells = Array.from({ length: ROWS * COLS });

const isShowingFront = ref(true);
const gridRef = ref<HTMLDivElement | null>(null);

const flipCell = (cell: HTMLElement, delay: number) => {
  setTimeout(() => {
    if (cell) {
      cell.style.transform = isShowingFront.value ? 'rotateY(180deg)' : 'rotateY(0deg)';
    }
  }, delay);
};

const animateFlip = () => {
  if (!gridRef.value) return;
  const cells = Array.from(gridRef.value.querySelectorAll('.cell'));

  // Organize cells into columns
  const columns: HTMLElement[][] = Array.from({ length: COLS }, () => []);
  cells.forEach((cell, index) => {
    const col = index % COLS;
    columns[col].push(cell as HTMLElement);
  });

  const delayBetweenColumns = 50;
  const middle = Math.floor(COLS / 2);
  let columnOrder = [middle];
  
  for (let offset = 1; offset <= middle; offset++) {
    if (middle - offset >= 0) columnOrder.push(middle - offset);
    if (middle + offset < COLS) columnOrder.push(middle + offset);
  }

  if (!isShowingFront.value) {
    columnOrder = columnOrder.reverse();
  }

  columnOrder.forEach((colIndex, index) => {
    setTimeout(() => {
      columns[colIndex].forEach((cell) => {
        flipCell(cell, 0);
      });
    }, index * delayBetweenColumns);
  });

  setTimeout(() => {
    isShowingFront.value = !isShowingFront.value;
  }, columnOrder.length * delayBetweenColumns + 500);
};

let intervalId: number;

onMounted(() => {
  intervalId = window.setInterval(animateFlip, 5000);
});

onBeforeUnmount(() => {
  clearInterval(intervalId);
});
</script>
=== END FILE: ./src/components/logo/TangentLogo.vue ===


=== START FILE: ./src/components/logo/LogoSVG.vue ===
=== TYPE: vue ===

// LogoSVG.vue
<template>
  <svg viewBox="0 0 200 45" class="absolute inset-0">
    <!-- Dynamic wave patterns -->
    <path
      d="M 20 22.5 C 40 22.5, 45 12, 65 12 S 90 33, 110 33 S 135 12, 155 12 S 180 22.5, 200 22.5"
      fill="none"
      class="stroke-foreground dark:stroke-foreground"
      stroke-width="1"
    />

    <!-- Fractal-like pattern -->
    <path
      d="M 100 22.5 C 105 22.5, 110 18, 120 18 S 135 27, 145 27 S 155 18, 165 18"
      fill="none"
      class="stroke-cyan-500 dark:stroke-cyan-400"
      stroke-width="1"
    />
    <path
      d="M 100 22.5 C 95 22.5, 90 27, 80 27 S 65 18, 55 18 S 45 27, 35 27"
      fill="none"
      class="stroke-rose-500 dark:stroke-rose-400"
      stroke-width="1"
    />

    <!-- Geometric accents -->
    <path
      v-for="i in 8"
      :key="`right-${i}`"
      :d="`M ${100 + i * 10} 22.5 L ${105 + i * 10} 15 L ${110 + i * 10} 22.5`"
      fill="none"
      class="stroke-emerald-500/30 dark:stroke-emerald-400/30"
      stroke-width="0.5"
    />
    <path
      v-for="i in 8"
      :key="`left-${i}`"
      :d="`M ${100 - i * 10} 22.5 L ${95 - i * 10} 30 L ${90 - i * 10} 22.5`"
      fill="none"
      class="stroke-purple-500/30 dark:stroke-purple-400/30"
      stroke-width="0.5"
    />

    <!-- Dynamic circles -->
    <circle
      v-for="i in 5"
      :key="`right-circle-${i}`"
      :cx="100 + i * 20"
      :cy="22.5 + Math.sin(i * 1.5) * 5"
      :r="1.2 - i * 0.15"
      class="fill-cyan-500 dark:fill-cyan-400"
    />
    <circle
      v-for="i in 5"
      :key="`left-circle-${i}`"
      :cx="100 - i * 20"
      :cy="22.5 + Math.cos(i * 1.5) * 5"
      :r="1.2 - i * 0.15"
      class="fill-rose-500 dark:fill-rose-400"
    />

    <!-- Central focal point -->
    <path
      d="M 95 22.5 L 105 22.5 M 100 17.5 L 100 27.5"
      class="stroke-foreground dark:stroke-foreground"
      stroke-width="1.5"
    />
    <circle
      cx="100"
      cy="22.5"
      r="2.5"
      class="fill-foreground dark:fill-foreground"
    />

    <!-- Abstract mathematical symbols -->
    <path
      d="M 160 15 A 5 5 0 0 1 170 15 A 5 5 0 0 1 160 15"
      fill="none"
      class="stroke-emerald-500/50 dark:stroke-emerald-400/50"
      stroke-width="0.75"
    />
    <path
      d="M 30 30 A 5 5 0 0 0 40 30 A 5 5 0 0 0 30 30"
      fill="none"
      class="stroke-purple-500/50 dark:stroke-purple-400/50"
      stroke-width="0.75"
    />
  </svg>
</template>
=== END FILE: ./src/components/logo/LogoSVG.vue ===


=== START FILE: ./src/components/theme/ThemeToggle.vue ===
=== TYPE: vue ===

<template>
  <div class="fixed top-4 left-4 z-20">
    <!-- Theme Dropdown -->
    <div class="relative">
      <button
        @click="isOpen = !isOpen"
        class="flex items-center gap-2 px-3 py-2 rounded-lg bg-background/80 backdrop-blur border shadow-sm hover:bg-muted/80 transition-all duration-200"
      >
        <div class="flex items-center gap-2">
          <div class="flex -space-x-1">
            <div 
              class="w-4 h-4 rounded-full border-2 border-background shadow-sm" 
              :style="{ backgroundColor: getThemeColors(currentTheme).primary }"
            />
            <div 
              class="w-4 h-4 rounded-full border-2 border-background shadow-sm" 
              :style="{ backgroundColor: getThemeColors(currentTheme).secondary }"
            />
          </div>
          <span class="text-sm font-medium">{{ currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1) }}</span>
        </div>
        <ChevronDown 
          class="w-4 h-4 transition-transform duration-200"
          :class="{ 'rotate-180': isOpen }"
        />
      </button>

      <!-- Dropdown Menu -->
      <div
        v-if="isOpen"
        class="absolute top-full left-0 mt-2 w-64 max-h-[60vh] overflow-y-auto rounded-lg border bg-background/95 backdrop-blur shadow-lg"
        @click.outside="isOpen = false"
      >
        <div class="p-2">
          <input
            v-model="search"
            type="text"
            placeholder="Search themes..."
            class="w-full px-3 py-2 text-sm rounded-md bg-muted/50 border-0 focus:ring-1 focus:ring-primary"
          />
        </div>
        
        <div class="py-1">
          <button
            v-for="theme in filteredThemes"
            :key="theme"
            @click="selectTheme(theme)"
            class="w-full px-3 py-2 flex items-center gap-3 hover:bg-muted/50 transition-colors group"
            :class="{ 'bg-primary/5': theme === currentTheme }"
          >
            <!-- Theme Preview -->
            <div class="flex items-center gap-1.5">
              <div 
                class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200" 
                :style="{ backgroundColor: getThemeColors(theme).primary }"
              />
              <div 
                class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200" 
                :style="{ backgroundColor: getThemeColors(theme).secondary }"
              />
              <div 
                class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200" 
                :style="{ backgroundColor: getThemeColors(theme).accent }"
              />
            </div>
            
            <span class="text-sm">{{ theme.charAt(0).toUpperCase() + theme.slice(1) }}</span>
            
            <Check 
              v-if="theme === currentTheme"
              class="w-4 h-4 ml-auto text-primary"
            />
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { ChevronDown, Check } from 'lucide-vue-next';

type ThemeColors = {
  primary: string;
  secondary: string;
  accent: string;
};

type ThemeName = 
  | "light" | "dark" | "cupcake" | "bumblebee" | "emerald" | "corporate"
  | "synthwave" | "retro" | "cyberpunk" | "valentine" | "halloween" | "garden"
  | "forest" | "aqua" | "lofi" | "pastel" | "fantasy" | "wireframe" | "black"
  | "luxury" | "dracula" | "cmyk" | "autumn" | "business" | "acid" | "lemonade"
  | "night" | "coffee" | "winter";

type ThemeColorMap = {
  [K in ThemeName]: ThemeColors;
};

const themes: ThemeName[] = [
  "light", "dark", "cupcake", "bumblebee", "emerald", "corporate",
  "synthwave", "retro", "cyberpunk", "valentine", "halloween",
  "garden", "forest", "aqua", "lofi", "pastel", "fantasy",
  "wireframe", "black", "luxury", "dracula", "cmyk", "autumn",
  "business", "acid", "lemonade", "night", "coffee", "winter"
];

const themeColors: ThemeColorMap = {
  // Light themes
  light: { primary: '#570DF8', secondary: '#F000B8', accent: '#37CDBE' },
  cupcake: { primary: '#65C3C8', secondary: '#EF9FBC', accent: '#EEAF3A' },
  bumblebee: { primary: '#F9D72F', secondary: '#E0A82E', accent: '#181830' },
  emerald: { primary: '#66CC8A', secondary: '#377CFB', accent: '#EA5234' },
  corporate: { primary: '#4B6BFB', secondary: '#7B92B2', accent: '#EA5234' },
  garden: { primary: '#5c7f67', secondary: '#be123c', accent: '#9CA384' },
  lofi: { primary: '#0D0D0D', secondary: '#1A1919', accent: '#4A4A4A' },
  pastel: { primary: '#d1c1d7', secondary: '#f6cbd1', accent: '#b4e9d6' },
  fantasy: { primary: '#6D0A0A', secondary: '#A65D03', accent: '#2D5A27' },
  wireframe: { primary: '#B8B8B8', secondary: '#CDCDCD', accent: '#DEDEDE' },
  lemonade: { primary: '#519903', secondary: '#E9E92E', accent: '#94CE58' },
  
  // Dark themes
  dark: { primary: '#793EF9', secondary: '#F471B5', accent: '#1FB2A5' },
  synthwave: { primary: '#E779C1', secondary: '#58C7F3', accent: '#F3CC30' },
  retro: { primary: '#EF9995', secondary: '#2CB67D', accent: '#7D5BA6' },
  cyberpunk: { primary: '#FF7598', secondary: '#75D1F0', accent: '#F7D51D' },
  valentine: { primary: '#E96D7B', secondary: '#A12E45', accent: '#F0AFC0' },
  halloween: { primary: '#F28C18', secondary: '#6B21A8', accent: '#37CDBE' },
  forest: { primary: '#1EB854', secondary: '#1DB88E', accent: '#1EA885' },
  aqua: { primary: '#09ECF3', secondary: '#0771DE', accent: '#07ABE3' },
  black: { primary: '#333333', secondary: '#666666', accent: '#999999' },
  luxury: { primary: '#DAA520', secondary: '#B8860B', accent: '#FFD700' },
  dracula: { primary: '#FF79C6', secondary: '#BD93F9', accent: '#50FA7B' },
  cmyk: { primary: '#00BCD4', secondary: '#FF4081', accent: '#FFEB3B' },
  autumn: { primary: '#8B4513', secondary: '#A0522D', accent: '#CD853F' },
  business: { primary: '#1C4E80', secondary: '#7C909A', accent: '#A6B0B5' },
  acid: { primary: '#FF00FF', secondary: '#00FF00', accent: '#FFFF00' },
  night: { primary: '#38BDF8', secondary: '#818CF8', accent: '#C084FC' },
  coffee: { primary: '#6F4E37', secondary: '#C6A880', accent: '#DAC3B3' },
  winter: { primary: '#0EA5E9', secondary: '#84CC16', accent: '#10B981' }
};

const isOpen = ref(false);
const search = ref('');
const currentTheme = ref<ThemeName>(
  (localStorage.getItem('theme') as ThemeName) || 'light'
);

const getThemeColors = (theme: ThemeName): ThemeColors => {
  return themeColors[theme];
};

const filteredThemes = computed(() => {
  const searchTerm = search.value.toLowerCase();
  return themes.filter(theme => 
    theme.toLowerCase().includes(searchTerm)
  );
});

const selectTheme = (theme: ThemeName) => {
  currentTheme.value = theme;
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('theme', theme);
  isOpen.value = false;
};

onMounted(() => {
  const savedTheme = localStorage.getItem('theme') as ThemeName || 'light';
  currentTheme.value = savedTheme;
  document.documentElement.setAttribute('data-theme', savedTheme);
});
</script>

<style scoped>
div::-webkit-scrollbar {
  width: 6px;
}

div::-webkit-scrollbar-track {
  background: transparent;
}

div::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.dark div::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.2);
}
</style>
=== END FILE: ./src/components/theme/ThemeToggle.vue ===


=== START FILE: ./src/vite-env.d.ts ===
=== TYPE: ts ===

/// <reference types="vite/client" />

=== END FILE: ./src/vite-env.d.ts ===


=== START FILE: ./src/router/index.ts ===
=== TYPE: ts ===

import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'
import InfiniteCanvas from '../components/canvas/InfiniteCanvas.vue'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: InfiniteCanvas
  },
  {
    path: '/canvas/:id',
    name: 'SpecificCanvas',
    component: InfiniteCanvas,
    props: true
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router
=== END FILE: ./src/router/index.ts ===


