=== START FILE: ./vite.config.ts ===
=== TYPE: ts ===

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
  optimizeDeps: {
    esbuildOptions: {
      target: 'esnext'
    }
  },
  build: {
    target: 'esnext',
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          'ui-vendor': ['@headlessui/vue', '@heroicons/vue', 'lucide-vue-next'],
          'highlight': ['highlight.js'],
          'prism': ['prismjs'],
          'marked': ['marked'],
          'dompurify': ['dompurify'],
          'monaco': ['@monaco-editor/loader']
        }
      }
    }
  }
})
=== END FILE: ./vite.config.ts ===


=== START FILE: ./src/App.vue ===
=== TYPE: vue ===

<template>
  <div class="min-h-screen bg-background">
    <!-- Logo Container -->
    <div class="fixed top-4 z-50 transition-all duration-300 w-[180px]" :style="{
      left: isSidePanelOpen ? 'calc(40vw + (60vw - 180px) / 2)' : 'calc(50vw - 90px)'
    }">
      <TangentLogo />
    </div>

    <!-- Side Panel -->
    <div
      class="fixed left-0 top-0 h-full w-[40vw] bg-background shadow-lg transform transition-transform duration-300 z-40 border-r border-base-300"
      :class="isSidePanelOpen ? 'translate-x-0' : '-translate-x-full'">
      <div class="h-full pt-2 px-4 pb-4 bg-background">
        <TokenOptimizer />
      </div>
    </div>

    <!-- Toggle Button -->
    <button @click="toggleSidePanel"
      class="fixed left-0 top-1/2 -translate-y-1/2 z-50 p-2 bg-background border border-l-0 border-base-300 rounded-r-md hover:bg-base-200 transition-all duration-300 shadow-md"
      :class="{ 'translate-x-[40vw]': isSidePanelOpen }">
      <ChevronRight class="w-5 h-5 transition-transform" :class="{ 'rotate-180': isSidePanelOpen }" />
    </button>

    <!-- Top Controls Container -->
    <div class="fixed top-0 z-50 transition-all duration-300 flex justify-between" :style="{
      left: isSidePanelOpen ? '40vw' : '0',
      right: '0'
    }">
      <!-- Left Controls Group -->
      <div class="flex items-center gap-4 p-4">
        <ThemeToggle />
        <div class="flex items-center gap-4">
          <!-- Zoom Level Display -->
          <div class="px-3 py-1.5 bg-base-200/90 backdrop-blur rounded-full border border-base-300 shadow-lg">
            <span class="text-sm font-medium text-base-content">{{ Math.round(canvasZoom * 100) }}%</span>
          </div>

          <div class="flex items-center gap-2">
            <button @click="graphControls.createNewConversation">New Chat</button>
            <button @click="graphControls.saveCurrentConversation">Save</button>
          </div>
          <!-- Auto-center Toggle -->
          <button
            class="px-3 py-1.5 bg-base-200/90 backdrop-blur rounded-full border border-base-300 shadow-lg hover:bg-base-300/90 transition-colors"
            @click="toggleAutoZoom">
            <span class="text-sm font-medium text-base-content">Auto-center: {{ canvasAutoZoom ? 'On' : 'Off' }}</span>
          </button>
        </div>
      </div>

      <!-- Right Controls Group -->
      <div class="flex items-center gap-2 p-4 mr-4">
        <button @click="openSettings" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800">
          <Settings class="w-5 h-5" />
        </button>
        <ModelSelector :api-key="openRouterApiKey" :selected-model="selectedModel" @select="handleModelSelect" />
      </div>
    </div>

    <!-- Canvas Container -->
    <InfiniteCanvas ref="canvasRef" :selected-model="selectedModel?.id || ''" :open-router-api-key="openRouterApiKey"
      :model-type="modelType" :side-panel-open="isSidePanelOpen" :zoom="canvasZoom" v-model:zoom="canvasZoom"
      v-model:auto-zoom-enabled="canvasAutoZoom" />

    <!-- Settings Modal -->
    <dialog ref="settingsDialog" class="modal">
      <div class="modal-box max-w-lg">
        <div class="flex items-center space-x-2 mb-4">
          <button class="btn btn-sm" :class="{ 'btn-active': activeTab === 'api' }" @click="activeTab = 'api'">
            API Settings
          </button>
          <button class="btn btn-sm" :class="{ 'btn-active': activeTab === 'tasks' }" @click="activeTab = 'tasks'">
            Tasks
          </button>
        </div>

        <div v-if="activeTab === 'api'" class="space-y-4">
          <div class="form-control">
            <label class="label">
              <span class="label-text">OpenRouter API Key</span>
            </label>
            <input v-model="openRouterApiKey" type="password" placeholder="sk-or-..."
              class="input input-bordered w-full" />
            <label class="label">
              <span class="label-text">Custom API URL</span>
            </label>
            <input v-model="customApiUrl" type="url" placeholder="http://localhost:8080/v1/chat/completions"
              class="input input-bordered w-full" />
          </div>
        </div>

        <div v-else-if="activeTab === 'tasks'">
          <TaskManager />
        </div>

        <div class="modal-action">
          <button class="btn" @click="closeSettings">Close</button>
        </div>
      </div>
    </dialog>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { Settings, ChevronRight } from 'lucide-vue-next';
import InfiniteCanvas from './components/canvas/InfiniteCanvas.vue';
import ThemeToggle from './components/theme/ThemeToggle.vue';
import TangentLogo from './components/logo/TangentLogo.vue';
import ModelSelector from './components/models/ModelSelector.vue';
import TaskManager from './components/manager/TaskManager.vue';
import TokenOptimizer from './components/tokenizer/DirectoryTokenizer.vue';
import type { Model } from './components/models/ModelSelector.vue';
import { useCanvasStore } from './stores/canvasStore';
import { useGraphControlsStore } from '@/stores/graphControlStore';

const graphControls = useGraphControlsStore();

const canvasRef = ref<InstanceType<typeof InfiniteCanvas> | null>(null);
const canvasZoom = ref(1);
const canvasAutoZoom = ref(true);

// State - load from localStorage if present
const selectedModel = ref<Model | null>(
  localStorage.getItem('selectedModel')
    ? JSON.parse(localStorage.getItem('selectedModel')!)
    : null
);
const modelType = ref<string>(localStorage.getItem('modelType') || '');
const settingsDialog = ref<HTMLDialogElement | null>(null);
const openRouterApiKey = ref(localStorage.getItem('openRouterApiKey') || '');
const activeTab = ref<'api' | 'tasks'>('api');
const canvasStore = useCanvasStore();
const customApiUrl = ref<string | null>(localStorage.getItem('customApiUrl') || null);

// Side panel state
const isSidePanelOpen = ref(false);

// Methods
const toggleSidePanel = () => {
  isSidePanelOpen.value = !isSidePanelOpen.value;
  // If panel is opening, wait for transition then center
  setTimeout(() => {
    canvasRef.value?.autoFitNodes();
  }, 300); // Match the transition duration
};

const toggleAutoZoom = () => {
  canvasAutoZoom.value = !canvasAutoZoom.value;
  if (canvasAutoZoom.value) {
    canvasRef.value?.autoFitNodes();
  }
};

const handleModelSelect = (model: Model) => {
  console.log('Previous model:', selectedModel.value);
  console.log('New model:', model);

  selectedModel.value = model;
  modelType.value = model.source;

  try {
    localStorage.setItem('selectedModel', JSON.stringify(model));
    localStorage.setItem('modelType', model.source);
  } catch (e) {
    console.error('Error storing model:', e);
  }
};

const openSettings = () => {
  settingsDialog.value?.showModal();
};

const closeSettings = () => {
  settingsDialog.value?.close();
  if (openRouterApiKey.value) {
    localStorage.setItem('openRouterApiKey', openRouterApiKey.value);
  } else {
    localStorage.removeItem('openRouterApiKey');
  }
  canvasStore.setCustomApiUrl(customApiUrl.value)
};
</script>

<style scoped>
.modal {
  background: rgba(0, 0, 0, 0.5);
  z-index: 100;
}

/* Ensure side panel is above canvas */
.side-panel {
  isolation: isolate;
}
</style>
=== END FILE: ./src/App.vue ===


=== START FILE: ./src/types/message.ts ===
=== TYPE: ts ===

// types/message.ts
export interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  isStreaming?: boolean;
  modelId?: string;
}

export interface ContentPart {
  type: 'text' | 'code';
  content: string;
  language?: string;
  complete?: boolean;
}

export interface Node {
  id: string;
  x: number;
  y: number;
  title?: string;
  parentId: string | null;
  messages: Message[];
  type: 'main' | 'branch';
  branchMessageIndex: number | null;
  streamingContent?: string | null;
}
=== END FILE: ./src/types/message.ts ===


=== START FILE: ./src/types/vue-shims.d.ts ===
=== TYPE: ts ===

// src/types/vue-shims.d.ts
declare module '*.vue' {
    import type { DefineComponent } from 'vue';
    const component: DefineComponent<{}, {}, any>;
    export default component;
}
=== END FILE: ./src/types/vue-shims.d.ts ===


=== START FILE: ./src/main.ts ===
=== TYPE: ts ===

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import 'highlight.js/styles/github-dark.css';
import router from './router'
import App from './App.vue'
import './assets/main.css'

const app = createApp(App)
app.use(createPinia())
app.use(router)
app.mount('#app')

=== END FILE: ./src/main.ts ===


=== START FILE: ./src/stores/canvasStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Message, Node } from '../types/message';

// Helper types for model info
type ModelSource = 'ollama' | 'openrouter' | 'custom';
interface ModelInfo {
  id: string;
  name: string;
  source: ModelSource;
  provider?: string;
}

export const useCanvasStore = defineStore('canvas', () => {
  // Main state
  const nodes = ref<Node[]>([{
    id: '1',
    x: 100,
    y: 100,
    title: 'Root Thread',
    parentId: null,
    messages: [],
    type: 'main',
    branchMessageIndex: null,
    streamingContent: null
  }]);

  // UI state
  const activeNode = ref<string | null>(null);
  const isDragging = ref(false);
  const dragOffset = ref({ x: 0, y: 0 });
  const viewMode = ref<'2d' | '3d'>('2d');
  const isTransitioning = ref(false);
  const customApiUrl = ref<string | null>(localStorage.getItem('customApiUrl') || null);
  const conversationId = ref<string | null>(null);
  const isLoading = ref(false);

  // Constants
  const CARD_WIDTH = 672;
  const CARD_HEIGHT = 80;
  const HORIZONTAL_SPACING = 100;

  // Topic clustering state
  const topicClusters = ref(new Map());
  const nodeTopics = ref(new Map());

  // Helper function to process SSE lines
  const processSSELine = (line: string, source: ModelSource) => {
    // Skip empty lines and known control messages
    if (!line || line === 'data: [DONE]' || line === '[DONE]' ||
      (source === 'openrouter' && line.startsWith(': OPENROUTER PROCESSING'))) {
      return null;
    }

    // Remove 'data: ' prefix and handle different formats
    const jsonData = line.startsWith('data: ') ? line.slice(5) : line;

    try {
      const data = JSON.parse(jsonData);

      // Handle different provider response structures
      switch (source) {
        case 'openrouter':
          return data.choices?.[0]?.delta?.content || '';
        case 'ollama':
          // Ollama's response structure uses 'message' field
          return data.message?.content || data.content || '';
        case 'custom':
          // Handle custom API formats
          return data.content || data.response || data.output || '';
        default:
          return data.content || '';
      }
    } catch (e) {
      // Only log actual parsing errors for non-control messages
      if (!line.includes('[DONE]') && !line.includes('OPENROUTER PROCESSING')) {
        console.error(`Error parsing ${source} response:`, e, line);
      }
      return null;
    }
  };

  // Helper function to handle streaming responses
  const handleStreamingResponse = async (
    reader: ReadableStreamDefaultReader<Uint8Array>,
    nodeId: string,
    modelSource: ModelSource
  ) => {
    let buffer = '';
    let accumulatedContent = '';
    const decoder = new TextDecoder();

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          const content = processSSELine(line, modelSource);
          if (content !== null) { // Explicit null check
            accumulatedContent += content;
            setStreamingContent(nodeId, accumulatedContent);
          }
        }
      }

      // Process any remaining buffer content
      if (buffer) {
        const content = processSSELine(buffer, modelSource);
        if (content !== null) {
          accumulatedContent += content;
          setStreamingContent(nodeId, accumulatedContent);
        }
      }

      return accumulatedContent;
    } catch (error) {
      console.error('Error in streaming response:', error);
      throw error;
    }
  };


  // Computed properties for 3D view
  const graphData = computed(() => {
    const clusters = Array.from(topicClusters.value.entries()).map(([topicId, nodeSet]) => ({
      id: `cluster-${topicId}`,
      type: 'cluster',
      nodes: Array.from(nodeSet),
      size: nodeSet.size
    }));

    const graphNodes = nodes.value.map(node => ({
      id: node.id,
      title: node.title || 'Untitled Thread',
      clusterId: nodeTopics.value.get(node.id),
      messageCount: node.messages?.length || 0,
      lastActive: node.messages?.[node.messages.length - 1]?.timestamp || '',
      branchPoint: node.branchMessageIndex
    }));

    const links = connections.value.map(conn => ({
      source: conn.parent?.id || '',
      target: conn.child.id,
      branchPoint: nodes.value.find(n => n.id === conn.child.id)?.branchMessageIndex
    }));

    return {
      nodes: [...graphNodes, ...clusters],
      links
    };
  });

  // Connections computed property
  const connections = computed(() => {
    return nodes.value
      .filter(node => node.parentId)
      .map(node => {
        const parent = nodes.value.find(n => n.id === node.parentId);
        return { parent, child: node };
      });
  });


  const loadConversation = async (id: string) => {
    isLoading.value = true;
    try {
      const response = await fetch(`http://127.0.0.1:5000/api/conversations/${id}`);
      if (!response.ok) throw new Error('Failed to load conversation');

      const data = await response.json();
      nodes.value = data.nodes;
      conversationId.value = id;
    } catch (error) {
      console.error('Error loading conversation:', error);
    } finally {
      isLoading.value = false;
    }
  };

  const saveCurrentConversation = async () => {
    if (!conversationId.value) {
      await createNewConversation();
      return;
    }

    try {
      await fetch(`http://127.0.0.1:5000/api/conversations/${conversationId.value}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          nodes: nodes.value,
          updatedAt: new Date().toISOString(),
          title: nodes.value[0]?.title || 'Untitled Conversation'
        })
      });
    } catch (error) {
      console.error('Error saving conversation:', error);
    }
  };

  const createNewConversation = async () => {
    try {
      const conversation = {
        id: crypto.randomUUID(),
        nodes: nodes.value,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        title: nodes.value[0]?.title || 'New Conversation'
      };

      await fetch('http://127.0.0.1:5000/api/conversations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(conversation)
      });

      conversationId.value = conversation.id;
    } catch (error) {
      console.error('Error creating conversation:', error);
    }
  };

  const parseModelInfo = (selectedModel: string): ModelInfo => {
    if (selectedModel.includes('/')) {
      const [provider, name] = selectedModel.split('/');
      return {
        id: selectedModel,
        name,
        source: 'openrouter',
        provider
      };
    } else if (customApiUrl.value) {
      return {
        id: selectedModel,
        name: selectedModel,
        source: 'custom'
      };
    } else {
      return {
        id: selectedModel,
        name: selectedModel,
        source: 'ollama'
      };
    }
  };

  const sendMessage = async (
    nodeId: string,
    message: string,
    selectedModel: string,
    openRouterApiKey: string,
    addUserMessage = true
  ) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (!node) return;

    const systemPrompt = `
      You are a helpful AI assistant who can engage in natural conversation while also helping with code. 
      When sharing code examples, always format them in markdown using fenced blocks with the appropriate language.
    `;

    try {
      const modelInfo = parseModelInfo(selectedModel);

      if (addUserMessage) {
        const userMessage: Message = {
          role: 'user',
          content: message,
          timestamp: new Date().toISOString(),
          isStreaming: false
        };
        addMessage(nodeId, userMessage);
      }

      const messageContext = node.messages.map(msg => ({
        role: msg.role,
        content: msg.content
      }));

      const { endpoint, headers, requestBody } = prepareRequest(
        modelInfo,
        messageContext,
        systemPrompt,
        openRouterApiKey
      );

      const response = await fetch(endpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await getErrorText(response);
        throw new Error(errorText);
      }

      const reader = response.body?.getReader();
      if (!reader) throw new Error('Response body is null');

      const accumulatedContent = await handleStreamingResponse(reader, nodeId, modelInfo.source);

      // Store final message
      const assistantMessage: Message = {
        role: 'assistant',
        content: accumulatedContent,
        timestamp: new Date().toISOString(),
        modelId: modelInfo.id,
        isStreaming: false
      };
      addMessage(nodeId, assistantMessage);
      setStreamingContent(nodeId, null);

      return true;
    } catch (error) {
      console.error('Error sending message:', error);
      setStreamingContent(nodeId, null);
      return false;
    }
  };

  const prepareRequest = (
    modelInfo: ModelInfo,
    messageContext: Array<{ role: string; content: string }>,
    systemPrompt: string,
    openRouterApiKey: string
  ) => {
    let endpoint = 'http://localhost:11434/api/chat';
    let headers: HeadersInit = {
      'Content-Type': 'application/json'
    };

    if (modelInfo.source === 'openrouter') {
      endpoint = 'https://openrouter.ai/api/v1/chat/completions';
      headers = {
        ...headers,
        'Authorization': `Bearer ${openRouterApiKey}`,
        'HTTP-Referer': window.location.origin,
        'X-Title': 'Tangent Chat'
      };
    } else if (modelInfo.source === 'custom' && customApiUrl.value) {
      endpoint = customApiUrl.value;
    }

    const requestBody = modelInfo.source === 'custom' && customApiUrl.value
      ? {
        prompt: `${messageContext.map(m => `${m.role}: ${m.content}`).join('\n')}`,
        stream: true,
        model: modelInfo.id
      }
      : {
        model: modelInfo.id,
        messages: [
          { role: 'system', content: systemPrompt },
          ...messageContext
        ],
        stream: true
      };

    return { endpoint, headers, requestBody };
  };

  const getErrorText = async (response: Response) => {
    let errorText = `API error: ${response.status}`;
    try {
      const errorData = await response.json();
      errorText += ` - ${JSON.stringify(errorData)}`;
    } catch (e) {
      console.error('Could not parse error body', e);
    }
    return errorText;
  };

  // Node management functions
  const addNode = async (parentId: string, branchMessageIndex: number, position: { x: number, y: number }, initialData = {}) => {
    const newNode = {
      id: (Math.max(...nodes.value.map(n => parseInt(n.id))) + 1).toString(),
      x: position.x,
      y: position.y,
      parentId,
      messages: [],
      type: 'branch',
      branchMessageIndex,
      streamingContent: null,
      ...initialData
    };

    nodes.value.push(newNode);
    await saveCurrentConversation();
    return newNode;
  };

  const updateNodePosition = async (id: string, position: { x: number, y: number }) => {
    const node = nodes.value.find(n => n.id === id);
    if (node) {
      node.x = position.x;
      node.y = position.y;
      await saveCurrentConversation();
    }
  };

  const removeNode = async (id: string) => {
    nodes.value = nodes.value.filter(n => n.id !== id && n.parentId !== id);
    await saveCurrentConversation();
  };

  const addMessage = (nodeId: string, message: string | Message) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node) {
      const newMessage: Message = typeof message === 'string'
        ? {
          role: 'assistant',
          content: message,
          timestamp: new Date().toISOString(),
          isStreaming: false
        }
        : {
          ...message,
          role: message.role as 'user' | 'assistant',
          isStreaming: message.isStreaming ?? false
        };

      node.messages = [...(node.messages || []), newMessage];
    }
  };

  const removeMessage = (nodeId: string, messageIndex: number) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node && node.messages) {
      node.messages = [
        ...node.messages.slice(0, messageIndex),
        ...node.messages.slice(messageIndex + 1)
      ];

      const childNodes = nodes.value.filter(n => n.parentId === nodeId);
      childNodes.forEach(childNode => {
        if (childNode.branchMessageIndex && childNode.branchMessageIndex >= messageIndex) {
          childNode.branchMessageIndex--;
        }
      });
    }
  };



  const updateNodeTitle = (id: string, title: string) => {
    const node = nodes.value.find(n => n.id === id);
    if (node) {
      node.title = title;
    }
  };

  const setStreamingContent = (nodeId: string, content: string | null) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node) {
      node.streamingContent = content;
    }
  };

  const setCustomApiUrl = (url: string | null) => {
    customApiUrl.value = url;
    if (url) {
      localStorage.setItem('customApiUrl', url);
    } else {
      localStorage.removeItem('customApiUrl');
    }
  };

  return {
    // State
    nodes,
    activeNode,
    isDragging,
    dragOffset,
    viewMode,
    isTransitioning,
    topicClusters,
    nodeTopics,
    customApiUrl,
    conversationId,
    isLoading,

    // Computed
    connections,
    graphData,

    // Constants
    CARD_WIDTH,
    CARD_HEIGHT,
    HORIZONTAL_SPACING,

    // Methods
    addNode,
    updateNodePosition,
    removeNode,
    updateNodeTitle,
    addMessage,
    setStreamingContent,
    removeMessage,
    sendMessage,
    setCustomApiUrl,
    loadConversation,
    createNewConversation,
    saveCurrentConversation,
  };
});
=== END FILE: ./src/stores/canvasStore.ts ===


=== START FILE: ./src/stores/graphControlStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import { useCanvasStore } from '@/stores/canvasStore';
import { useTopicClusterStore } from '@/stores/topicClusterStore'

export const useGraphControlsStore = defineStore('graphControls', () => {
    const canvasStore = useCanvasStore();
    const clusterStore = useTopicClusterStore();

    const isLoading = ref(false);
    const currentConvId = ref<string | null>(null);

    const createNewConversation = async () => {
        isLoading.value = true;
        try {
            const id = await canvasStore.createNewConversation();
            if (id) {
                currentConvId.value = id;
                await clusterStore.clusterConversations(canvasStore.nodes);
            }
            return id;
        } finally {
            isLoading.value = false;
        }
    };

    const saveCurrentConversation = async () => {
        if (!currentConvId.value) {
            const id = await createNewConversation();
            return id;
        }
        await canvasStore.saveCurrentConversation();

        // Add this call
        await fetch('http://127.0.0.1:5000/api/clusters/update', {
            method: 'POST',
            body: JSON.stringify({ nodes: canvasStore.nodes })
        });

        await clusterStore.clusterConversations(canvasStore.nodes);
    };

    const loadConversation = async (id: string) => {
        isLoading.value = true;
        try {
            await canvasStore.loadConversation(id);
            currentConvId.value = id;
            await clusterStore.clusterConversations(canvasStore.nodes);
        } finally {
            isLoading.value = false;
        }
    };

    watch(() => canvasStore.nodes.length, async () => {
        if (currentConvId.value) {
            await saveCurrentConversation();
        }
    });

    return {
        isLoading,
        currentConvId,
        createNewConversation,
        loadConversation,
        saveCurrentConversation
    };
});
=== END FILE: ./src/stores/graphControlStore.ts ===


=== START FILE: ./src/stores/topicClusterStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Node } from '../types/message';

interface TopicCluster {
    id: string;
    topic: string;
    nodes: Node[];
    embedding: number[];
    coherence: number;
}

export const useTopicClusterStore = defineStore('topicClusters', () => {
    const clusters = ref<TopicCluster[]>([]);
    const isProcessing = ref(false);

    // Generate embeddings for a list of texts
    const generateEmbeddings = async (texts: string[]) => {
        const response = await fetch('http://localhost:11434/api/embed', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: 'all-minilm',
                input: texts
            })
        });

        const data = await response.json();
        return data.embeddings;
    };

    // Calculate cosine similarity between two embeddings
    const cosineSimilarity = (a: number[], b: number[]) => {
        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
        return dotProduct / (magnitudeA * magnitudeB);
    };

    // Cluster conversations based on embeddings
    const clusterConversations = async (nodes: Node[]) => {
        isProcessing.value = true;
        try {
            // Get titles or first messages
            const texts = nodes.map(node => {
                const text = node.title || node.messages[0]?.content || '';
                return text.slice(0, 2000); // Limit to first 2000 chars
            });
            const embeddings = await generateEmbeddings(texts);
            
            // Clustering using similarity threshold
            const SIMILARITY_THRESHOLD = 0.8;
            const newClusters: TopicCluster[] = [];

            for (let i = 0; i < nodes.length; i++) {
                const nodeEmbedding = embeddings[i];
                let assignedToCluster = false;

                // Try to assign to existing cluster
                for (const cluster of newClusters) {
                    const similarity = cosineSimilarity(nodeEmbedding, cluster.embedding);
                    if (similarity > SIMILARITY_THRESHOLD) {
                        cluster.nodes.push(nodes[i]);
                        assignedToCluster = true;
                        break;
                    }
                }

                // Create new cluster if needed
                if (!assignedToCluster) {
                    newClusters.push({
                        id: crypto.randomUUID(),
                        topic: '',  // Will be generated
                        nodes: [nodes[i]],
                        embedding: nodeEmbedding,
                        coherence: 1
                    });
                }
            }

            // Generate topic names
            await Promise.all(newClusters.map(async cluster => {
                const titles = cluster.nodes.map(n => n.title || '').join('\n');
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'mistral',
                        prompt: `These are related conversation titles:\n${titles}\n\nProvide a short (2-3 words) topic name that describes their common theme. Respond with just the topic name.`,
                        stream: false
                    })
                });

                const data = await response.json();
                cluster.topic = data.response.trim();
            }));

            clusters.value = newClusters;
        } finally {
            isProcessing.value = false;
        }
    };

    return {
        clusters,
        isProcessing,
        clusterConversations
    };
});
=== END FILE: ./src/stores/topicClusterStore.ts ===


=== START FILE: ./src/utils/api.ts ===
=== TYPE: ts ===


=== END FILE: ./src/utils/api.ts ===


=== START FILE: ./src/components/ui/Card.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Card.vue -->
<template>
    <div 
      class="rounded-lg border bg-card text-card-foreground shadow"
      :class="className"
    >
      <slot />
    </div>
  </template>
  
  <script setup>
  defineProps({
    className: {
      type: String,
      default: ''
    }
  });
  </script>
=== END FILE: ./src/components/ui/Card.vue ===


=== START FILE: ./src/components/ui/alert/Alert.vue ===
=== TYPE: vue ===

<template>
  <div :class="[
    'relative w-full rounded-lg border p-4',
    variantStyles[variant || 'default'],
    className
  ]" role="alert">
    <slot />
  </div>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'default' | 'destructive',
  className?: string
}

withDefaults(defineProps<Props>(), {
  variant: 'default',
  className: ''
})

const variantStyles = {
  default: 'bg-background text-foreground',
  destructive: 'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive'
}
</script>
=== END FILE: ./src/components/ui/alert/Alert.vue ===


=== START FILE: ./src/components/ui/alert/AlertDescription.vue ===
=== TYPE: vue ===

<!-- src/components/ui/AlertDescription.vue -->
<template>
    <div
      class="text-sm [&_p]:leading-relaxed"
      :class="className"
    >
      <slot />
    </div>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    className?: string
  }>()
  </script>
=== END FILE: ./src/components/ui/alert/AlertDescription.vue ===


=== START FILE: ./src/components/ui/alert/AlertTitle.vue ===
=== TYPE: vue ===

<!-- src/components/ui/AlertTitle.vue -->
<template>
    <h5
      class="mb-1 font-medium leading-none tracking-tight"
      :class="className"
    >
      <slot />
    </h5>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    className?: string
  }>()
  </script>
=== END FILE: ./src/components/ui/alert/AlertTitle.vue ===


=== START FILE: ./src/components/ui/Badge.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Badge.vue -->
<template>
  <div 
    class="inline-flex items-center rounded-md px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
    :class="{
      'bg-primary text-primary-foreground hover:bg-primary/80': variant === 'default',
      'bg-secondary text-secondary-foreground hover:bg-secondary/80': variant === 'secondary',
      'bg-destructive text-destructive-foreground hover:bg-destructive/80': variant === 'destructive',
      'border border-primary/20 bg-primary/10 text-primary hover:bg-primary/20': variant === 'outline'
    }"
  >
    <slot />
  </div>
</template>

<script setup>
defineProps({
  variant: {
    type: String,
    default: 'default',
    validator: (value) => ['default', 'secondary', 'destructive', 'outline'].includes(value)
  }
});
</script>
=== END FILE: ./src/components/ui/Badge.vue ===


=== START FILE: ./src/components/ui/Button.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Button.vue -->
<template>
    <button
      class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
      :class="[
        variantStyles[variant],
        sizeStyles[size],
        className
      ]"
      :disabled="disabled"
      :type="type"
      @click="$emit('click', $event)"
    >
      <slot />
    </button>
  </template>
  
  <script setup lang="ts">
  interface Props {
    variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link'
    size?: 'default' | 'sm' | 'lg' | 'icon'
    className?: string
    disabled?: boolean
    type?: 'button' | 'submit' | 'reset'
  }
  
  withDefaults(defineProps<Props>(), {
    variant: 'default',
    size: 'default',
    className: '',
    disabled: false,
    type: 'button'
  })
  
  defineEmits<{
    (e: 'click', event: MouseEvent): void
  }>()
  
  const variantStyles = {
    default: 'bg-primary text-primary-foreground shadow hover:bg-primary/90',
    destructive: 'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',
    outline: 'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',
    secondary: 'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',
    ghost: 'hover:bg-accent hover:text-accent-foreground',
    link: 'text-primary underline-offset-4 hover:underline'
  }
  
  const sizeStyles = {
    default: 'h-9 px-4 py-2',
    sm: 'h-8 rounded-md px-3 text-xs',
    lg: 'h-10 rounded-md px-8',
    icon: 'h-9 w-9'
  }
  </script>
=== END FILE: ./src/components/ui/Button.vue ===


=== START FILE: ./src/components/messages/MessageInput.vue ===
=== TYPE: vue ===

<!-- src/components/MessageInput.vue -->
<template>
  <div class="message-input-container border-t border-gray-200 dark:border-gray-700 mt-4 pt-4">
    <div class="relative">
      <textarea
        ref="textareaRef"
        v-model="messageInput"
        rows="1"
        class="w-full px-4 py-2.5 resize-none bg-white dark:bg-gray-800 
               border border-gray-200 dark:border-gray-700 rounded-lg pr-24
               text-gray-800 dark:text-gray-200 placeholder-gray-500
               focus:ring-2 focus:ring-primary focus:ring-opacity-50 focus:border-transparent"
        :class="{ 'opacity-50': isLoading }"
        placeholder="Type your message..."
        @keydown.enter.prevent="handleSubmit"
        @input="autoResize"
      ></textarea>
      
      <div class="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-2">
        <!-- The button toggles between "Send" and "Stop" based on isLoading -->
        <button
          class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 
                 transition-colors disabled:opacity-50"
          :disabled="!isLoading && !messageInput.trim()"
          @click="handleToggleButton"
        >
          <!-- If isLoading, show Stop icon; otherwise show Send icon -->
          <template v-if="isLoading">
            <!-- Stop Icon (any you prefer, e.g. XCircle, or lucide StopCircle, etc.) -->
            <StopCircle class="w-5 h-5 text-red-600" />
          </template>
          <template v-else>
            <Send class="w-5 h-5 text-primary" />
          </template>
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue';
import { Send, StopCircle } from 'lucide-vue-next';

const props = defineProps({
  isLoading: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['send', 'stop']);

const messageInput = ref('');
const textareaRef = ref(null);

/**
 * Dynamically resize the text area.
 */
const autoResize = () => {
  const textarea = textareaRef.value;
  if (!textarea) return;
  
  textarea.style.height = 'auto';
  textarea.style.height = `${textarea.scrollHeight}px`;
};

/**
 * Called on Enter or Send button click.
 */
const handleSubmit = async () => {
  const message = messageInput.value.trim();
  if (!message || props.isLoading) return;

  emit('send', message);
  messageInput.value = '';
  
  await nextTick();
  autoResize();
};

/**
 * Called if isLoading is true (currently streaming).
 * Emitted up so parent can stop the generation and update store.
 */
const handleStop = () => {
  emit('stop');
};

/**
 * Toggle function for the button click:
 * - If we are loading/streaming => "Stop"
 * - Otherwise => "Send"
 */
const handleToggleButton = () => {
  if (props.isLoading) {
    handleStop();
  } else {
    handleSubmit();
  }
};
</script>

=== END FILE: ./src/components/messages/MessageInput.vue ===


=== START FILE: ./src/components/messages/CodePreview.vue ===
=== TYPE: vue ===

<template>
  <div class="relative mt-3 mb-3">
    <div class="absolute right-2 top-2 flex gap-2">
      <button 
        class="p-1.5 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors shadow-sm"
        @click="copyToClipboard"
      >
        <Clipboard class="w-4 h-4 text-gray-600 dark:text-gray-300" />
      </button>
    </div>
    <pre 
      ref="previewRef"
      :class="[
        'p-4 rounded-lg overflow-x-auto border',
        'bg-gray-100 dark:bg-gray-800',
        'border-gray-200 dark:border-gray-700',
        isDark ? 'hljs-dark' : 'hljs-light'
      ]"
    >
      <code 
        ref="codeRef"
        :class="`language-${props.language} hljs text-sm`"
        v-html="highlightedCode"
      />
    </pre>
    <div v-if="props.isStreaming" class="mt-2 flex gap-1">
      <span class="animate-bounce w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-75 w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-150 w-1.5 h-1.5 bg-primary rounded-full"></span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';
import hljs from 'highlight.js';
import DOMPurify from 'dompurify';
import { Clipboard } from 'lucide-vue-next';

interface Props {
  content: string;
  isStreaming: boolean;
  language?: string;
}

const props = withDefaults(defineProps<Props>(), {
  language: 'javascript'
});

const previewRef = ref<HTMLElement | null>(null);
const codeRef = ref<HTMLElement | null>(null);
const isDark = ref(false);

// Watch for theme changes
const updateTheme = () => {
  isDark.value = document.documentElement.classList.contains('dark');
};

onMounted(() => {
  // Initialize hljs
  hljs.configure({ 
    ignoreUnescapedHTML: true,
    languages: ['javascript', 'python', 'bash', 'typescript', 'json']
  });

  // Set initial theme
  updateTheme();

  // Watch for theme changes using MutationObserver
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        updateTheme();
      }
    });
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class']
  });

  // Cleanup
  onUnmounted(() => {
    observer.disconnect();
  });
});

const highlightedCode = computed(() => {
  try {
    // First ensure language is registered
    if (!hljs.getLanguage(props.language)) {
      console.warn(`Language ${props.language} not found, falling back to plaintext`);
      return DOMPurify.sanitize(props.content);
    }

     const result = hljs.highlight(props.content, {
        language: props.language,
      });


    return DOMPurify.sanitize(result.value);
  } catch (err) {
    console.error('Highlighting error:', err);
    return DOMPurify.sanitize(props.content);
  }
});

const copyToClipboard = () => {
  navigator.clipboard.writeText(props.content);
};
</script>

<style>
/* Light theme styles */
:root:not(.dark) .hljs-light {
  --hljs-background: transparent;
  --hljs-comment: #54575a;
  --hljs-keyword: #d73a49;
  --hljs-string: #032f62;
  --hljs-number: #005cc5;
  --hljs-function: #2c0f60;
  --hljs-title: #240b53;
  --hljs-params: #24292e;
  --hljs-built_in: #005cc5;
  --hljs-literal: #005cc5;
  --hljs-variable: #24292e;
  --hljs-type: #d73a49;
  --hljs-attr: #005cc5;
  --hljs-selector: #125f24;
}

/* Dark theme styles */
.dark .hljs-dark {
  --hljs-background: transparent;
  --hljs-comment: #8b949e;
  --hljs-keyword: #ff7b72;
  --hljs-string: #a5d6ff;
  --hljs-number: #79c0ff;
  --hljs-function: #d2a8ff;
  --hljs-title: #d2a8ff;
  --hljs-params: #c9d1d9;
  --hljs-built_in: #79c0ff;
  --hljs-literal: #79c0ff;
  --hljs-variable: #c9d1d9;
  --hljs-type: #ff7b72;
  --hljs-attr: #79c0ff;
  --hljs-selector: #7ee787;
}

/* Common styles */
.hljs {
  background: var(--hljs-background) !important;
  color: var(--hljs-params);
}

.hljs-comment { color: var(--hljs-comment); }
.hljs-keyword { color: var(--hljs-keyword); }
.hljs-string { color: var(--hljs-string); }
.hljs-number { color: var(--hljs-number); }
.hljs-function { color: var(--hljs-function); }
.hljs-title { color: var(--hljs-title); }
.hljs-params { color: var(--hljs-params); }
.hljs-built_in { color: var(--hljs-built_in); }
.hljs-literal { color: var(--hljs-literal); }
.hljs-variable { color: var(--hljs-variable); }
.hljs-type { color: var(--hljs-type); }
.hljs-attr { color: var(--hljs-attr); }
.hljs-selector { color: var(--hljs-selector); }

pre {
  margin: 0;
  white-space: pre-wrap;
  word-break: break-word;
  tab-size: 2;
}

code {
  font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, 'Courier New', monospace;
}
</style>
=== END FILE: ./src/components/messages/CodePreview.vue ===


=== START FILE: ./src/components/messages/MessageContent.vue ===
=== TYPE: vue ===

<template>
  <div class="message-content">
    <!-- If streaming, show chunked output as it arrives -->
    <template v-if="isStreaming">
      <div v-for="(part, index) in streamingParts" :key="index" class="first:mt-0 mt-4">
        <CodePreview v-if="part.type === 'code'" :content="part.content" :is-streaming="!part.complete"
          :language="part.language || 'plaintext'" />
        <div v-else v-html="part.content" class="text-base-content whitespace-pre-wrap" />
      </div>
    </template>

    <!-- Otherwise, render the fully parsed content (once complete) -->
    <template v-else>
      <div v-for="(part, index) in parsedContent" :key="index" class="first:mt-0 mt-4">
        <CodePreview v-if="part.type === 'code'" :content="part.content" :is-streaming="false"
          :language="part.language" />
        <div v-else v-html="part.content" class="text-base-content whitespace-pre-wrap" />
      </div>
    </template>

    <!-- Optional "AI typing" indicator -->
    <div v-if="isStreaming" class="mt-2 flex gap-1">
      <span class="animate-bounce w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-75 w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-150 w-1.5 h-1.5 bg-primary rounded-full"></span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import CodePreview from './CodePreview.vue'
import { marked } from 'marked'
import DOMPurify from 'dompurify'

interface Props {
  content: string
  isStreaming?: boolean
}

interface ContentPart {
  type: 'text' | 'code'
  content: string
  language?: string
  complete?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  isStreaming: false
})

// Store the last complete content
const lastCompleteContent = ref('')

// Keep track of streaming parts
const streamingParts = ref<ContentPart[]>([])

// Watch for content changes during streaming
watch(
  () => props.content,
  async (newContent) => {
    if (!props.isStreaming) {
      // Store the complete content when streaming ends
      lastCompleteContent.value = newContent
      return
    }

    const parts: ContentPart[] = []
    let inCodeBlock = false
    let codeLanguage = ''
    let currentBuffer = ''
    let i = 0

    while (i < newContent.length) {
      if (newContent.slice(i, i + 3) === '```') {
        if (!inCodeBlock) {
          if (currentBuffer) {
            const html = await marked(currentBuffer)
            const safeHTML = DOMPurify.sanitize(html as string)
            parts.push({
              type: 'text',
              content: safeHTML,
              complete: true
            })
            currentBuffer = ''
          }
          let endOfLine = newContent.indexOf('\n', i + 3)
          if (endOfLine === -1) endOfLine = newContent.length
          codeLanguage = newContent.slice(i + 3, endOfLine).trim()

          inCodeBlock = true
          i = endOfLine + 1
        } else {
          parts.push({
            type: 'code',
            content: currentBuffer.trim(),
            language: codeLanguage || 'plaintext',
            complete: true
          })

          inCodeBlock = false
          codeLanguage = ''
          currentBuffer = ''
          i += 3
        }
      } else {
        currentBuffer += newContent[i]
        i++
      }
    }

    if (currentBuffer) {
      if (inCodeBlock) {
        parts.push({
          type: 'code',
          content: currentBuffer,
          language: codeLanguage || 'plaintext',
          complete: false
        })
      } else {
        const html = await marked(currentBuffer)
        const safeHTML = DOMPurify.sanitize(html)
        parts.push({
          type: 'text',
          content: safeHTML,
          complete: false
        })
      }
    }

    streamingParts.value = parts
  }
)

// Parse content for non-streaming mode
const parsedContent = computed<ContentPart[]>(() => {
  // Use the last complete content instead of props.content
  const contentToProcess = lastCompleteContent.value || props.content
  const parts: ContentPart[] = []
  let inCodeBlock = false
  let codeLanguage = ''
  let currentBuffer = ''

  const processMarkdown = (text: string) => {
    if (!text) return
    const html = marked(text)
    const safeHTML = DOMPurify.sanitize(html as string)
    parts.push({
      type: 'text',
      content: safeHTML,
      complete: true
    })
  }

  const lines = contentToProcess.split('\n')

  for (const line of lines) {
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        parts.push({
          type: 'code',
          content: currentBuffer,
          language: codeLanguage || 'plaintext',
          complete: true
        })
        currentBuffer = ''
        codeLanguage = ''
        inCodeBlock = false
      } else {
        if (currentBuffer) processMarkdown(currentBuffer)
        currentBuffer = ''
        codeLanguage = line.slice(3).trim()
        inCodeBlock = true
      }
    } else {
      currentBuffer += currentBuffer ? '\n' + line : line
    }
  }

  if (inCodeBlock) {
    parts.push({
      type: 'code',
      content: currentBuffer,
      language: codeLanguage || 'plaintext',
      complete: true
    })
  } else if (currentBuffer) {
    processMarkdown(currentBuffer)
  }

  return parts
})
</script>
=== END FILE: ./src/components/messages/MessageContent.vue ===


=== START FILE: ./src/components/messages/MessageTimestamp.vue ===
=== TYPE: vue ===


<!-- MessageTimestamp.vue -->
<template>
    <div
      class="absolute flex items-center px-3 py-1.5 gap-1.5 text-xs font-mono rounded-full 
             bg-white dark:bg-gray-800 shadow-sm border border-gray-200 dark:border-gray-700
             text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-700 
             transition-all duration-200"
      :class="side === 'right' ? 'left-[calc(100%+8px)] top-4' : 'right-[calc(100%+8px)] top-4'"
    >
      <Timer class="w-3 h-3" />
      <span>{{ formattedTime }}</span>
    </div>
  </template>
  
  <script setup lang="ts">
  // MessageTimestamp.vue
import { computed } from 'vue';
import { Timer } from 'lucide-vue-next';

const props = defineProps({
  timestamp: {
    type: String,
    required: true
  },
  side: {
    type: String,
    default: 'right',
    validator: (value: string) => ['left', 'right'].includes(value)
  }
});

const formattedTime = computed(() => {
  const date = new Date(props.timestamp);
  return `${
    date.getHours().toString().padStart(2, '0')
  }:${
    date.getMinutes().toString().padStart(2, '0')
  }:${
    date.getSeconds().toString().padStart(2, '0')
  }`;
});
  </script>
  
  <!-- Updated styles for BranchNode.vue -->
  <style>
  .message-bubble {
    @apply relative transition-all duration-200 rounded-lg p-4;
  }
  
  .message-bubble.user {
    @apply bg-blue-900/20 border-l-4 border-blue-500;
  }
  
  .message-bubble.assistant {
    @apply bg-purple-900/20 border-l-4 border-purple-500;
  }
  
  .message-bubble.inherited {
    @apply opacity-75 border-dashed;
  }
  
  .node-card {
    @apply backdrop-blur bg-gray-900/30 transition-all duration-300 border border-gray-700/50 rounded-lg;
  }
  
  .node-card:hover {
    @apply shadow-lg shadow-black/20 border-gray-600/50;
  }
  
  .selected .node-card {
    @apply ring-2 ring-blue-500/50;
  }
  
  .streaming .node-card {
    @apply relative;
  }
  
  .streaming .node-card::before {
    content: '';
    @apply absolute inset-0 rounded-lg;
    background: linear-gradient(90deg, 
      theme('colors.blue.500') 0%,
      theme('colors.purple.500') 50%,
      theme('colors.blue.500') 100%
    );
    background-size: 200% 100%;
    animation: flowBorder 4s linear infinite;
    z-index: 0;
    opacity: 0.2;
  }
  
  @keyframes flowBorder {
    0% { background-position: 100% 0; }
    100% { background-position: -100% 0; }
  }
  </style>
=== END FILE: ./src/components/messages/MessageTimestamp.vue ===


=== START FILE: ./src/components/tokenizer/DirectoryTokenizer.vue ===
=== TYPE: vue ===

<template>
    <div class="min-h-screen bg-background/40 backdrop-blur-md p-6 border border-border/40">
      <div class="max-w-6xl mx-auto">
        <div class="flex justify-between items-center mb-8">
          <div class="flex items-center space-x-4">
            <h1 class="text-3xl font-bold text-foreground">Tokenic</h1>
            <div class="relative flex space-x-2">
              <select v-model="optimizationLevel"
                      class="w-44 px-3 py-2 bg-background border rounded-lg shadow-sm">
                <option value="low">Conservative</option>
                <option value="medium">Standard</option>
                <option value="aggressive">Aggressive</option>
              </select>
              <select v-model="selectedModel"
                      class="w-full px-4 py-2 bg-background/80 backdrop-blur-sm border rounded-lg appearance-none cursor-pointer">
                <optgroup v-for="(models, category) in groupedModels" :key="category" :label="category">
                  <option v-for="model in models" :key="model" :value="model">
                    {{ model }}
                  </option>
                </optgroup>
              </select>
              <div class="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none">
                <span class="i-lucide-chevron-down h-4 w-4 text-muted-foreground" />
              </div>
            </div>
          </div>
        </div>
  
        <!-- Tab Selection -->
        <div class="flex gap-4 border-b mb-6">
          <button
            v-for="tab in tabs"
            :key="tab.id"
            @click="activeTab = tab.id"
            class="px-4 py-2 -mb-px transition-colors relative"
            :class="[
              activeTab === tab.id
                ? 'border-b-2 border-primary text-primary font-medium'
                : 'text-muted-foreground hover:text-foreground'
            ]"
          >
            {{ tab.name }}
          </button>
        </div>
  
        <!-- File Processing -->
        <div v-if="activeTab === 'file'" class="space-y-6">
          <div class="flex items-center gap-4">
            <div class="flex-1 relative">
              <input
                v-model="filePath"
                type="text"
                placeholder="Enter file path..."
                class="w-full px-4 py-3 bg-background border rounded-lg pr-10"
                @keyup.enter="optimizeFile"
              />
              <button
                v-if="filePath"
                @click="filePath = ''"
                class="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <span class="i-lucide-x h-4 w-4" />
              </button>
            </div>
            <button
              @click="optimizeFile"
              class="px-6 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              :disabled="isProcessing || !filePath"
            >
              {{ isProcessing ? 'Processing...' : 'Optimize' }}
            </button>
          </div>
        </div>
  
        <!-- Directory Processing -->
        <div v-if="activeTab === 'directory'" class="space-y-6">
          <div class="flex items-center gap-4">
            <div class="flex-1 relative">
              <input
                v-model="directory"
                type="text"
                placeholder="Enter directory path..."
                class="w-full px-4 py-3 bg-background border rounded-lg pr-10"
                @keyup.enter="processDirectory"
              />
              <button
                v-if="directory"
                @click="directory = ''"
                class="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <span class="i-lucide-x h-4 w-4" />
              </button>
            </div>
            <button
              @click="processDirectory"
              class="px-6 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              :disabled="isProcessing || !directory"
            >
              {{ isProcessing ? 'Processing...' : 'Process Directory' }}
            </button>
          </div>
        </div>
  
        <!-- Raw Text Input -->
        <div v-if="activeTab === 'raw'" class="space-y-6">
          <div class="flex items-center gap-4 mb-4">
            <select v-model="rawInputType" class="px-4 py-3 bg-background border rounded-lg">
              <option value="system">System</option>
              <option value="user">User</option>
              <option value="assistant">Assistant</option>
            </select>
            <button
              @click="optimizeRawText"
              class="px-6 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              :disabled="isProcessing || !rawText"
            >
              {{ isProcessing ? 'Processing...' : 'Optimize' }}
            </button>
          </div>
          <div class="relative">
            <textarea
              v-model="rawText"
              placeholder="Enter your text here..."
              class="w-full h-48 p-4 bg-background border rounded-lg font-mono text-sm resize-none"
              @keyup.ctrl.enter="optimizeRawText"
            />
            <div v-if="rawText" class="absolute top-2 right-2">
              <button @click="rawText = ''" class="p-1 hover:bg-muted rounded">
                <span class="i-lucide-x h-4 w-4 text-muted-foreground" />
              </button>
            </div>
          </div>
        </div>
  
        <!-- Results Display -->
        <div v-if="currentResult" class="mt-8 bg-card border rounded-lg shadow-sm">
          <!-- Header Stats -->
          <div class="p-4 border-b">
            <div v-if="currentResult.filepath" class="mb-2 text-sm text-muted-foreground">
              {{ currentResult.filepath }}
            </div>
            <div class="flex items-center justify-between">
              <div class="flex gap-6 text-sm">
                <div>
                  <span class="text-muted-foreground">Original Tokens:</span>
                  <span class="ml-2 font-medium">{{ currentResult.token_map.original.token_count }}</span>
                </div>
                <div>
                  <span class="text-muted-foreground">Optimized Tokens:</span>
                  <span class="ml-2 font-medium">{{ currentResult.token_map.optimized.token_count }}</span>
                </div>
                <div>
                  <span class="text-muted-foreground">Reduction:</span>
                  <span class="ml-2 font-medium">
                    {{
                      (
                        (currentResult.token_map.original.token_count -
                          currentResult.token_map.optimized.token_count) /
                        currentResult.token_map.original.token_count
                      * 100).toFixed(1)
                    }}%
                  </span>
                </div>
              </div>
              <div class="text-sm text-muted-foreground">
                Model: {{ currentResult.model }}
              </div>
            </div>
          </div>
  
          <!-- Token Visualization -->
          <div class="grid grid-cols-2 gap-6 p-6">
            <!-- Original Panel -->
            <div>
              <h4 class="font-medium mb-2">Original</h4>
              <div class="max-h-[400px] overflow-auto">
                <pre
                  class="p-4 bg-muted rounded-lg font-mono text-sm whitespace-normal leading-tight"
                  style="margin: 0;"
                >
  <template v-for="(token, idx) in currentResult.token_map.original.tokens" :key="idx">
    <span
      class="token"
      :class="{
        'bg-destructive/20 text-destructive': isRemovedToken(token),
        'bg-success/20 text-success': isNewToken(token),
        'opacity-50': isRemovedToken(token)
      }"
    >
      {{ token.trim() }}
    </span><span v-if="idx < currentResult.token_map.original.tokens.length - 1"> </span>
  </template>
                </pre>
              </div>
            </div>
  
            <!-- Removed Tokens Panel -->
            <div>
              <h4 class="font-medium mb-2">Removed Tokens</h4>
              <div class="max-h-[400px] overflow-auto">
                <pre
                  class="p-4 bg-muted rounded-lg font-mono text-sm whitespace-normal leading-tight"
                  style="margin: 0;"
                >
  <template v-for="(token, idx) in removedTokens" :key="idx">
    <span class="token bg-destructive/20 text-destructive">
      {{ token.trim() }}
    </span><span v-if="idx < removedTokens.length - 1"> </span>
  </template>
                </pre>
              </div>
            </div>
          </div>
  
          <!-- Token Analysis -->
          <div class="p-4 border-t bg-muted">
            <div class="grid grid-cols-3 gap-8">
              <div>
                <p class="text-sm text-muted-foreground mb-1">Removed Tokens</p>
                <p class="text-2xl font-bold">{{ getRemovedTokenCount() }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground mb-1">New Tokens</p>
                <p class="text-2xl font-bold">{{ getNewTokenCount() }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground mb-1">Token Savings</p>
                <p class="text-2xl font-bold">{{ getTokenSavings() }}</p>
              </div>
            </div>
          </div>
        </div>
  
        <!-- Bundle Results -->
        <div v-if="activeTab === 'directory' && processedFiles.length" class="mt-8 space-y-4">
          <div class="bg-card border rounded-lg p-4">
            <h3 class="text-lg font-medium mb-4">Bundle Summary</h3>
            <div class="grid grid-cols-4 gap-6">
              <div>
                <p class="text-sm text-muted-foreground">Total Files</p>
                <p class="text-2xl font-bold">{{ processedFiles.length }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground">Total Original Tokens</p>
                <p class="text-2xl font-bold">{{ totalOriginalTokens }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground">Total Optimized Tokens</p>
                <p class="text-2xl font-bold">{{ totalOptimizedTokens }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground">Average Reduction</p>
                <p class="text-2xl font-bold">
                  {{
                    (
                      (totalOriginalTokens - totalOptimizedTokens) /
                        totalOriginalTokens
                    * 100).toFixed(1)
                  }}%
                </p>
              </div>
            </div>
          </div>
        </div>
  
      </div>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed, onMounted } from 'vue'
  
  interface TokenMap {
    text: string
    token_count: number
    tokens: string[]
  }
  
  interface ProcessedResult {
    filepath?: string
    token_map: {
      original: TokenMap
      optimized: TokenMap
    }
    optimization_level: string
    model: string
  }
  
  interface Tab {
    id: 'file' | 'directory' | 'raw'
    name: string
  }
  
  const tabs: Tab[] = [
    { id: 'file', name: 'Single File' },
    { id: 'directory', name: 'Directory' },
    { id: 'raw', name: 'Raw Text' }
  ]
  
  const activeTab = ref<Tab['id']>('file')
  const directory = ref('')
  const filePath = ref('')
  const rawText = ref('')
  const rawInputType = ref<'system' | 'user' | 'assistant'>('user')
  const optimizationLevel = ref('medium')
  const isProcessing = ref(false)
  const currentResult = ref<ProcessedResult | null>(null)
  const processedFiles = ref<ProcessedResult[]>([])
  const selectedModel = ref('gpt-4')
  const availableModels = ref<string[]>([])
  
  const groupedModels = computed(() => {
    return {
      Popular: availableModels.value.filter(m =>
        ['gpt-4', 'gpt-3.5-turbo', 'gpt-4-1106-preview'].includes(m)
      ),
      'Open-Source Models': availableModels.value.filter(m =>
        m.includes('llama') || m.includes('meta')
      ),
      'OpenAI Models': availableModels.value.filter(m =>
        m.includes('gpt') && !['gpt-4','gpt-3.5-turbo','gpt-4-1106-preview'].includes(m)
      ),
      Legacy: availableModels.value.filter(m =>
        ['davinci','curie','babbage','ada'].includes(m)
      )
    }
  })
  
  const totalOriginalTokens = computed(() => {
    return processedFiles.value.reduce((sum, file) =>
      sum + file.token_map.original.token_count, 0
    )
  })
  
  const totalOptimizedTokens = computed(() => {
    return processedFiles.value.reduce((sum, file) =>
      sum + file.token_map.optimized.token_count, 0
    )
  })
  
  onMounted(async () => {
    try {
      const response = await fetch('http://127.0.0.1:5000/models')
      const data = await response.json()
      availableModels.value = data.models
    } catch (error) {
      console.error('Error fetching models:', error)
    }
  })
  
  const removedTokens = computed(() => {
    if (!currentResult.value) return []
    const original = currentResult.value.token_map.original.tokens
    const optimized = currentResult.value.token_map.optimized.tokens
    return original.filter(token => !optimized.includes(token))
  })
  
  const isRemovedToken = (token: string) => {
    if (!currentResult.value) return false
    return !currentResult.value.token_map.optimized.tokens.includes(token)
  }
  
  const isNewToken = (token: string) => {
    if (!currentResult.value) return false
    return (
      currentResult.value.token_map.optimized.tokens.includes(token) &&
      !currentResult.value.token_map.original.tokens.includes(token)
    )
  }
  
  const getRemovedTokenCount = () => {
    if (!currentResult.value) return 0
    return currentResult.value.token_map.original.tokens.filter(token =>
      isRemovedToken(token)
    ).length
  }
  
  const getNewTokenCount = () => {
    if (!currentResult.value) return 0
    return currentResult.value.token_map.optimized.tokens.filter(token =>
      isNewToken(token)
    ).length
  }
  
  const getTokenSavings = () => {
    if (!currentResult.value) return 0
    return (
      currentResult.value.token_map.original.token_count -
      currentResult.value.token_map.optimized.token_count
    )
  }
  
  const optimizeFile = async () => {
    if (!filePath.value) return
    isProcessing.value = true
    try {
      const response = await fetch('http://127.0.0.1:5000/optimize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filepath: filePath.value,
          level: optimizationLevel.value,
          model: selectedModel.value
        }),
      })
  
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to optimize file')
      }
  
      const data = await response.json()
      currentResult.value = data
    } catch (error) {
      console.error('Error optimizing file:', error)
    } finally {
      isProcessing.value = false
    }
  }
  
  const processDirectory = async () => {
    if (!directory.value) return
    isProcessing.value = true
    try {
      const response = await fetch('http://127.0.0.1:5000/bundle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          directory: directory.value,
          level: optimizationLevel.value,
          model: selectedModel.value
        }),
      })
  
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to process directory')
      }
  
      const data = await response.json()
      processedFiles.value = data.files
      if (data.files.length > 0) {
        currentResult.value = data.files[0]
      }
    } catch (error) {
      console.error('Error processing directory:', error)
    } finally {
      isProcessing.value = false
    }
  }
  
  const optimizeRawText = async () => {
    if (!rawText.value) return
    isProcessing.value = true
    try {
      const response = await fetch('http://127.0.0.1:5000/optimize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: rawText.value,
          type: rawInputType.value,
          level: optimizationLevel.value,
          model: selectedModel.value
        }),
      })
  
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to optimize text')
      }
  
      const data = await response.json()
      currentResult.value = data
    } catch (error) {
      console.error('Error optimizing text:', error)
    } finally {
      isProcessing.value = false
    }
  }
  </script>
  
  <style>
  .token {
    display: inline-block;
    border-radius: 2px;
    padding: 0 2px;
    margin: 0 1px;
  }
  </style>
  
=== END FILE: ./src/components/tokenizer/DirectoryTokenizer.vue ===


=== START FILE: ./src/components/models/ModelSelector.vue ===
=== TYPE: vue ===

<template>
  <div class="relative inline-block">
    <!-- Model Selection Button -->
    <button @click="toggleDropdown" @keydown.space.prevent="toggleDropdown" @keydown.enter.prevent="toggleDropdown"
      @keydown.m.prevent="focusModelSelector"
      class="w-64 bg-background border rounded-md px-3 py-2 text-sm flex items-center justify-between hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-950"
      ref="modelButton">
      <div class="flex items-center gap-2 overflow-hidden">
        <span v-if="selectedModel" class="flex items-center gap-2">
          <Badge
            :variant="selectedModel.source === 'ollama' ? 'default' : selectedModel.source === 'openrouter' ? 'secondary' : 'outline'"
            class="text-xs">
            {{ selectedModel.source === 'ollama' ? 'Local' : selectedModel.source === 'openrouter' ? 'Cloud' : 'Custom'
            }}
          </Badge>
          <span class="font-medium truncate">{{ selectedModel.name }}</span>
        </span>
        <span v-else>Select Model (M)</span>
      </div>
      <ChevronDown class="w-4 h-4 transition-transform" :class="{ 'rotate-180': isOpen }" />
    </button>

    <!-- Dropdown Menu -->
    <div v-show="isOpen" class="absolute right-0 mt-2 w-96 bg-white dark:bg-gray-950 border rounded-md shadow-lg z-30"
      role="dialog" aria-label="Model Selection">
      <!-- Search and Filter Bar -->
      <div class="p-3 border-b">
        <div class="relative mb-2">
          <Search class="absolute left-3 top-2.5 w-4 h-4 text-gray-400" />
          <input v-model="searchQuery" type="text" ref="searchInput"
            class="w-full pl-9 pr-3 py-2 border rounded-md bg-white dark:bg-gray-950 text-sm placeholder:text-gray-400"
            placeholder="Search models... (/)" @keydown.up.prevent="navigateList('up')"
            @keydown.down.prevent="navigateList('down')" @keydown.enter.prevent="selectHighlighted"
            @keydown.esc.prevent="closeDropdown" />
        </div>
        <!-- Price Filter -->
        <div class="flex gap-2 mt-2">
          <button v-for="filter in ['all', 'free', 'paid']" :key="filter" @click="priceFilter = filter"
            @keydown.enter="priceFilter = filter" class="px-3 py-1 text-xs rounded-md"
            :class="priceFilter === filter ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300' : 'bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400'"
            tabindex="0">
            {{ filter.charAt(0).toUpperCase() + filter.slice(1) }}
          </button>
        </div>
      </div>

      <!-- Models List -->
      <div class="max-h-[60vh] overflow-y-auto bg-white dark:bg-gray-950" role="listbox" ref="modelsList">
        <!-- Custom Model Option -->
        <div class="border-b last:border-0 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800"
          :class="{ 'bg-blue-50 dark:bg-blue-900': highlightedIndex === filteredModels.length }"
          @click="selectCustomModel()" @keydown.enter="selectCustomModel()"
          @mouseover="highlightedIndex = filteredModels.length" role="option"
          :aria-selected="highlightedIndex === filteredModels.length" tabindex="0" ref="modelItems">
          <div class="p-3">
            <div class="flex items-center gap-2">
              <Badge variant="outline" class="text-xs">
                Custom
              </Badge>
              <span class="font-medium">Custom Model</span>
            </div>
          </div>
        </div>

        <!-- Combined Models List -->
        <div v-for="(model, index) in filteredModels" :key="model.id"
          class="border-b last:border-0 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800"
          :class="{ 'bg-blue-50 dark:bg-blue-900': highlightedIndex === index }" @click="selectModel(model)"
          @keydown.enter="selectModel(model)" @mouseover="highlightedIndex = index" role="option"
          :aria-selected="highlightedIndex === index" tabindex="0" ref="modelItems">
          <div class="p-3">
            <div class="flex items-center justify-between">
              <div class="flex items-center gap-2">
                <Badge :variant="model.source === 'ollama' ? 'default' : 'secondary'" class="text-xs">
                  {{ model.source === 'ollama' ? 'Local' : model.provider }}
                </Badge>
                <span class="font-medium">{{ model.name }}</span>
              </div>
              <div v-if="isOpenRouterModel(model)" class="text-xs text-gray-500">
                ${{ model.pricing?.prompt }}/1K
              </div>
            </div>
            <p v-if="isOpenRouterModel(model) && model.description" class="mt-1 text-xs text-gray-500 line-clamp-2">
              {{ model.description }}
            </p>
            <div v-if="isOpenRouterModel(model) && model.tags?.length" class="flex gap-2 mt-2">
              <span v-for="tag in model.tags" :key="tag"
                class="px-1.5 py-0.5 text-[10px] rounded-full bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400">
                {{ tag }}
              </span>
            </div>
          </div>
        </div>

        <!-- Empty State -->
        <div v-if="filteredModels.length === 0 && searchQuery" class="p-8 text-center text-gray-500">
          <p class="text-sm">No models found matching "{{ searchQuery }}"</p>
        </div>
        <div v-else-if="filteredModels.length === 0" class="p-8 text-center text-gray-500">
          <p class="text-sm">No models available</p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, nextTick, computed, onMounted, onBeforeUnmount, watch } from 'vue';
import { ChevronDown, Search } from 'lucide-vue-next';
import Badge from '../ui/Badge.vue';
import type { Model, OllamaModel, OpenRouterModel } from '../../types';

const props = defineProps<{
  apiKey?: string;
  selectedModel: Model | null;
}>();

const emit = defineEmits<{
  (e: 'select', model: Model): void;
}>();

// Refs
const isOpen = ref(false);
const searchQuery = ref('');
const priceFilter = ref<'all' | 'free' | 'paid'>('all');
const ollamaModels = ref<OllamaModel[]>([]);
const openRouterModels = ref<OpenRouterModel[]>([]);
const highlightedIndex = ref(0);
const modelButton = ref<HTMLButtonElement | null>(null);
const searchInput = ref<HTMLInputElement | null>(null);
const modelsList = ref<HTMLDivElement | null>(null);
const modelItems = ref<HTMLDivElement[]>([]);
const isChatInputFocused = ref(false);

// Navigation
const navigateList = (direction: 'up' | 'down') => {
  const maxIndex = filteredModels.value.length;
  if (direction === 'up') {
    highlightedIndex.value = highlightedIndex.value <= 0 ? maxIndex : highlightedIndex.value - 1;
  } else {
    highlightedIndex.value = highlightedIndex.value >= maxIndex ? 0 : highlightedIndex.value + 1;
  }

  // Scroll highlighted item into view
  const highlightedElement = modelItems.value[highlightedIndex.value];
  if (highlightedElement && modelsList.value) {
    highlightedElement.scrollIntoView({ block: 'nearest' });
  }
};

const selectHighlighted = () => {
  if (highlightedIndex.value === filteredModels.value.length) {
    selectCustomModel()
  } else {
    const model = filteredModels.value[highlightedIndex.value];
    if (model) {
      selectModel(model);
    }
  }
};

// Toggle and focus management
const focusModelSelector = () => {
  toggleDropdown();
  nextTick(() => {
    if (isOpen.value) {
      searchInput.value?.focus();
    }
  });
};

const toggleDropdown = () => {
  isOpen.value = !isOpen.value;
  if (isOpen.value) {
    highlightedIndex.value = 0;
    nextTick(() => {
      searchInput.value?.focus();
    });
  }
};

const closeDropdown = () => {
  isOpen.value = false;
  searchQuery.value = '';
  modelButton.value?.focus();
};

// Model selection
const selectModel = (model: Model) => {
  emit('select', model);
  closeDropdown();
};


const selectCustomModel = () => {
  emit('select', {
    id: 'custom_model', // A generic ID for custom models
    name: 'Custom Model',
    source: 'custom'
  });
  closeDropdown();
};

// Computed and utilities
const filteredModels = computed(() => {
  const query = searchQuery.value.toLowerCase();
  const allModels = [...ollamaModels.value, ...openRouterModels.value];

  return allModels
    .filter(model => {
      const matchesSearch = model.name.toLowerCase().includes(query) ||
        (model.source === 'openrouter' &&
          ((model as OpenRouterModel).description?.toLowerCase().includes(query) ||
            (model as OpenRouterModel).provider.toLowerCase().includes(query)));

      if (priceFilter.value === 'all') return matchesSearch;

      if (model.source === 'ollama') {
        return priceFilter.value === 'free' && matchesSearch;
      } else {
        const openRouterModel = model as OpenRouterModel;
        const isFree = openRouterModel.pricing.prompt === "0";
        return (
          (priceFilter.value === 'free' && isFree && matchesSearch) ||
          (priceFilter.value === 'paid' && !isFree && matchesSearch)
        );
      }
    })
    .sort((a, b) => {
      if (a.source !== b.source) {
        return a.source === 'ollama' ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });
});

const isOpenRouterModel = (model: Model): model is OpenRouterModel => {
  return model.source === 'openrouter';
};

const handleGlobalKeydown = (e: KeyboardEvent) => {
  // Check if any input or textarea is focused
  const activeElement = document.activeElement;
  const isInputFocused = activeElement instanceof HTMLInputElement ||
    activeElement instanceof HTMLTextAreaElement;

  // Immediately prevent model selector if we're typing in an input
  if (isInputFocused) {
    // Still allow Escape to close the dropdown if it's open
    if (e.key === 'Escape' && isOpen.value) {
      closeDropdown();
    }
    return;
  }

  // Handle model selector shortcuts only if no input is focused
  if (e.key === 'm' && !isOpen.value) {
    e.preventDefault();
    focusModelSelector();
  }

  // Focus search with '/' key
  if (e.key === '/' && isOpen.value) {
    e.preventDefault();
    searchInput.value?.focus();
  }

  // Close with Escape
  if (e.key === 'Escape' && isOpen.value) {
    closeDropdown();
  }
};

// Remove the chat input focus tracking since we're now checking actively
onMounted(() => {
  document.addEventListener('keydown', handleGlobalKeydown);
  fetchOllamaModels();
  if (props.apiKey) {
    fetchOpenRouterModels();
  }
});

onBeforeUnmount(() => {
  document.removeEventListener('keydown', handleGlobalKeydown);
});
// Reset highlighted index when filtered models change
watch(filteredModels, () => {
  highlightedIndex.value = 0;
});

// API calls
const fetchOllamaModels = async () => {
  try {
    const response = await fetch('http://localhost:11434/api/tags');
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const data = await response.json();
    if (Array.isArray(data.models)) {
      ollamaModels.value = data.models.map((model: any) => ({
        id: model.name,
        name: model.name,
        source: 'ollama' as const
      }));
    }
  } catch (error) {
    console.error('Error fetching Ollama models:', error);
    ollamaModels.value = [];
  }
};

const fetchOpenRouterModels = async () => {
  if (!props.apiKey) return;

  try {
    const response = await fetch('https://openrouter.ai/api/v1/models', {
      headers: {
        'Authorization': `Bearer ${props.apiKey}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

    const data = await response.json();
    openRouterModels.value = data.data.map((model: any) => ({
      id: model.id,
      name: model.name.split(':')[1]?.trim() || model.name,
      source: 'openrouter' as const,
      provider: model.name.split(':')[0],
      description: model.description,
      pricing: {
        prompt: model.pricing.prompt,
        completion: model.pricing.completion
      },
      tags: [
        `${model.context_length}k context`,
        model.pricing.prompt === "0" ? "Free" : "Paid",
      ],
      context_length: model.context_length
    }));
  } catch (error) {
    console.error('Error fetching OpenRouter models:', error);
    openRouterModels.value = [];
  }
};
</script>
=== END FILE: ./src/components/models/ModelSelector.vue ===


=== START FILE: ./src/components/canvas/clustermap/BottomSheetCluster.vue ===
=== TYPE: vue ===

<template>
  <div>
    <!-- Bottom Sheet Pull Tab -->
    <div 
      class="fixed bottom-0 left-1/2 -translate-x-1/2 w-24 h-1.5 rounded-full bg-base-300/50 cursor-pointer hover:bg-base-300 transition-colors mb-2"
      @mouseenter="handleShowSheet"
      @mouseleave="startHideTimer"
    />

    <!-- Bottom Sheet -->
    <div 
      class="fixed mx-4 left-0 right-0 bg-base-200/95 backdrop-blur border-t border-base-300 shadow-lg transition-all duration-300 ease-in-out rounded-t-lg"
      :class="[
        isOpen ? 'bottom-0' : '-bottom-[500px]',
        'transform'
      ]"
      :style="{ height: '500px' }"
      @mouseenter="handleShowSheet"
      @mouseleave="handleHideSheet"
    >
      <!-- Header -->
      <div class="flex items-center justify-between px-6 py-2 border-b border-base-300">
        <h3 class="text-lg font-medium">Topic Clusters</h3>
        <button 
          class="p-1.5 hover:bg-base-300 rounded-lg transition-colors"
          @click="handleHideSheet"
        >
          <span class="sr-only">Close</span>
          <XIcon class="w-5 h-5" />
        </button>
      </div>

      <!-- Content -->
      <div class="p-6 h-full">
        <TopicClusterViz 
          :width="vizWidth" 
          :height="400"
          :selected-topic="selectedTopic"
          @select-node="handleTopicSelect"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount } from 'vue';
import { XIcon } from 'lucide-vue-next';
import TopicClusterViz from './TopicClusterViz.vue';

const props = defineProps<{
  selectedTopic?: string;
}>();

const emit = defineEmits<{
  (e: 'select-topic', topicId: string): void;
}>();

const isOpen = ref(false);
const hideTimer = ref<number | null>(null);
const windowWidth = ref(window.innerWidth);

const vizWidth = computed(() => windowWidth.value - 80);

const handleShowSheet = () => {
  if (hideTimer.value) {
    clearTimeout(hideTimer.value);
    hideTimer.value = null;
  }
  isOpen.value = true;
};

const handleHideSheet = () => {
  isOpen.value = false;
};

const startHideTimer = () => {
  hideTimer.value = window.setTimeout(() => {
    if (!isOpen.value) return;
    handleHideSheet();
  }, 300);
};

const handleTopicSelect = (node: any) => {
  emit('select-topic', node.id);
};

onMounted(() => {
  const handleResize = () => {
    windowWidth.value = window.innerWidth;
  };
  
  window.addEventListener('resize', handleResize);
  
  onBeforeUnmount(() => {
    window.removeEventListener('resize', handleResize);
    if (hideTimer.value) {
      clearTimeout(hideTimer.value);
    }
  });
});
</script>

<style scoped>
.bottom-sheet-enter-active,
.bottom-sheet-leave-active {
  transition: transform 0.3s ease-in-out;
}

.bottom-sheet-enter-from,
.bottom-sheet-leave-to {
  transform: translateY(100%);
}
</style>
=== END FILE: ./src/components/canvas/clustermap/BottomSheetCluster.vue ===


=== START FILE: ./src/components/canvas/clustermap/TopicClusterViz.vue ===
=== TYPE: vue ===

<template>
    <div>
      <!-- Graph Controls -->
      <div class="absolute top-4 right-4 flex gap-2">
        <button class="px-4 py-2 bg-primary text-white rounded hover:bg-primary/90" :disabled="graphControls.isLoading"
          @click="graphControls.createNewConversation">
          {{ graphControls.isLoading ? 'Creating...' : 'New Chat' }}
        </button>
  
        <span v-if="graphControls.currentConvId" class="px-4 py-2 bg-secondary text-white rounded">
          {{ canvasStore.nodes[0]?.title || 'Untitled Chat' }}
        </span>
      </div>
  
      <!-- Visualization Container -->
      <div ref="containerRef" class="topic-cluster-viz" :style="{ width: `${width || 800}px`, height: `${height || 600}px` }"
        @click="handleNodeClick" />
  
      <!-- Loading Overlay -->
      <div v-if="clusterStore.isProcessing"
        class="absolute inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center">
        <div class="text-white text-lg">Processing clusters...</div>
      </div>
  
      <!-- Selected Cluster Info -->
      <div v-if="selectedCluster" class="absolute bottom-4 left-4 p-4 bg-card rounded-lg border shadow-lg">
        <h3 class="text-lg font-semibold mb-2">{{ selectedCluster.topic }}</h3>
        <div class="text-sm text-muted-foreground">
          {{ selectedCluster.nodes.length }} conversations
        </div>
        <div class="mt-2 flex gap-2 flex-wrap">
          <span v-for="node in selectedCluster.nodes" :key="node.id"
            class="px-2 py-1 bg-muted rounded-full text-xs">
            {{ node.title || 'Untitled' }}
          </span>
        </div>
      </div>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed, onMounted, shallowRef, onBeforeUnmount, watch } from 'vue';
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
  import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';
  import { useGraphControlsStore } from '@/stores/graphControlStore';
  import { useTopicClusterStore } from '@/stores/topicClusterStore';
  import { useCanvasStore } from '@/stores/canvasStore';
  
  const props = defineProps<{
    width?: number;
    height?: number;
    selectedTopic?: string;
  }>();
  
  const emit = defineEmits<{
    (e: 'select-node', node: ClusterNode): void;
  }>();
  
  // Store references
  const graphControls = useGraphControlsStore();
  const clusterStore = useTopicClusterStore();
  const canvasStore = useCanvasStore();
  
  // Refs
  const containerRef = ref<HTMLDivElement | null>(null);
  const selectedCluster = ref<TopicCluster | null>(null);
  
  // Scene state using shallowRef for performance
  const sceneObjects = shallowRef({
    scene: null as THREE.Scene | null,
    camera: null as THREE.PerspectiveCamera | null,
    renderer: null as THREE.WebGLRenderer | null,
    labelRenderer: null as CSS2DRenderer | null,
    controls: null as OrbitControls | null,
    nodeObjects: new Map<string, {
      mesh: THREE.Mesh;
      label: CSS2DObject;
      position: THREE.Vector3;
    }>()
  });
  
  // Node types
  interface ClusterNode {
    id: string;
    name: string;
    type: 'topic' | 'conversation';
    size: number;
    cluster?: string;
  }
  
  interface TopicCluster {
    id: string;
    topic: string;
    nodes: any[];
    coherence: number;
  }
  
  // Computed nodes
  const nodes = computed<ClusterNode[]>(() => {
    const topicNodes = clusterStore.clusters.map(cluster => ({
      id: cluster.id,
      name: cluster.topic,
      type: 'topic' as const,
      size: 30 + (cluster.nodes.length * 2)
    }));
  
    const conversationNodes = clusterStore.clusters.flatMap(cluster =>
      cluster.nodes.map(node => ({
        id: node.id,
        name: node.title || 'Untitled',
        type: 'conversation' as const,
        size: 15,
        cluster: cluster.id
      }))
    );
  
    return [...topicNodes, ...conversationNodes];
  });
  
  // Scene setup functions
  const createScene = () => {
    if (!containerRef.value) return;
  
    const width = props.width || 800;
    const height = props.height || 600;
  
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
  
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 500;
  
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    containerRef.value.appendChild(renderer.domElement);
  
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(width, height);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    containerRef.value.appendChild(labelRenderer.domElement);
  
    const controls = new OrbitControls(camera, labelRenderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
  
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
  
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);
  
    sceneObjects.value = {
      scene,
      camera,
      renderer,
      labelRenderer,
      controls,
      nodeObjects: new Map()
    };
  };
  
  // Node creation and management
  const createNodes = () => {
    const { scene, nodeObjects } = sceneObjects.value;
    if (!scene) return;
  
    nodeObjects.clear();
    scene.clear();
  
    nodes.value.forEach((node, index) => {
      const geometry = new THREE.SphereGeometry(node.size * 0.5, 32, 32);
      const material = new THREE.MeshPhongMaterial({
        color: node.type === 'topic' ? 0x60A5FA : 0xF87171,
        transparent: true,
        opacity: node.type === 'topic' ? 0.9 : 0.7,
      });
  
      const mesh = new THREE.Mesh(geometry, material);
  
      const phi = Math.acos(-1 + (2 * index) / nodes.value.length);
      const theta = Math.sqrt(nodes.value.length * Math.PI) * phi;
      const radius = 200;
  
      const position = new THREE.Vector3(
        radius * Math.cos(theta) * Math.sin(phi),
        radius * Math.sin(theta) * Math.sin(phi),
        radius * Math.cos(phi)
      );
  
      mesh.position.copy(position);
  
      const labelDiv = document.createElement('div');
      labelDiv.className = `node-label ${node.type}`;
      labelDiv.textContent = node.name;
  
      const label = new CSS2DObject(labelDiv);
      label.position.copy(position);
  
      scene.add(mesh);
      scene.add(label);
  
      nodeObjects.set(node.id, { mesh, label, position });
    });
  
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
  
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);
  };
  
  // Connection creation
  const createConnections = () => {
    const { scene, nodeObjects } = sceneObjects.value;
    if (!scene) return;
  
    clusterStore.clusters.forEach(cluster => {
      const topicNodeObj = nodeObjects.get(cluster.id);
      
      cluster.nodes.forEach(node => {
        const convNodeObj = nodeObjects.get(node.id);
  
        if (topicNodeObj && convNodeObj) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            topicNodeObj.position,
            convNodeObj.position
          ]);
  
          const material = new THREE.LineBasicMaterial({
            color: 0x4B5563,
            transparent: true,
            opacity: 0.4
          });
  
          const line = new THREE.Line(geometry, material);
          scene.add(line);
        }
      });
    });
  };
  
  // Animation loop
  const animate = () => {
    const { renderer, scene, camera, labelRenderer, controls } = sceneObjects.value;
    if (!renderer || !scene || !camera || !labelRenderer || !controls) return;
  
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  };
  
  // Event handlers
  const handleNodeClick = (event: MouseEvent) => {
    const { camera, scene, nodeObjects } = sceneObjects.value;
    if (!camera || !scene) return;
  
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    const rect = (event.target as HTMLElement).getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / (props.width || 800)) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / (props.height || 600)) * 2 + 1;
  
    raycaster.setFromCamera(mouse, camera);
  
    const intersects = raycaster.intersectObjects(scene.children);
    
    if (intersects.length > 0) {
      const clickedMesh = intersects[0].object as THREE.Mesh;
      for (const [nodeId, nodeObj] of nodeObjects.entries()) {
        if (nodeObj.mesh === clickedMesh) {
          const clickedNode = nodes.value.find(node => node.id === nodeId);
          if (clickedNode) {
            emit('select-node', clickedNode);
            if (clickedNode.type === 'topic') {
              selectedCluster.value = clusterStore.clusters.find(c => c.id === clickedNode.id) || null;
            } else if (clickedNode.cluster) {
              selectedCluster.value = clusterStore.clusters.find(c => c.id === clickedNode.cluster) || null;
            }
          }
          break;
        }
      }
    }
  };
  
  // Watchers
  watch(() => clusterStore.clusters, () => {
    if (sceneObjects.value.scene) {
      createNodes();
      createConnections();
    }
  }, { deep: true });
  
  watch(() => [props.width, props.height], () => {
    const { camera, renderer, labelRenderer } = sceneObjects.value;
    if (!camera || !renderer || !labelRenderer) return;
  
    camera.aspect = (props.width || 800) / (props.height || 600);
    camera.updateProjectionMatrix();
    renderer.setSize(props.width || 800, props.height || 600);
    labelRenderer.setSize(props.width || 800, props.height || 600);
  });
  
  watch(() => props.selectedTopic, (newTopic) => {
    const { camera, controls, nodeObjects } = sceneObjects.value;
    if (!camera || !controls || !newTopic) return;
  
    const selectedNodeObj = nodeObjects.get(newTopic);
    if (selectedNodeObj) {
      const position = selectedNodeObj.position.clone();
      position.z += 100;
  
      const duration = 1000;
      const startPosition = camera.position.clone();
      const startTime = Date.now();
  
      const animateCamera = () => {
        const currentTime = Date.now();
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
  
        camera.position.lerpVectors(startPosition, position, progress);
        controls.target.copy(selectedNodeObj.position);
  
        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        }
      };
  
      animateCamera();
    }
  });
  
  // Lifecycle
  onMounted(() => {
    createScene();
    createNodes();
    createConnections();
    animate();
  });
  
  onBeforeUnmount(() => {
    const { scene, renderer, labelRenderer } = sceneObjects.value;
    scene?.clear();
    renderer?.dispose();
    labelRenderer?.dispose();
  });
  </script>
  
  <style scoped>
  .topic-cluster-viz {
    position: relative;
    overflow: hidden;
  }
  
  :deep(.node-label) {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    cursor: pointer;
    padding: 2px 4px;
    pointer-events: none;
    white-space: nowrap;
    backdrop-filter: blur(8px);
    color: white;
    font-weight: 500;
  }
  
  :deep(.node-label.topic) {
    font-size: 14px;
    background: rgba(96, 165, 250, 0.2);
  }
  
  :deep(.node-label.conversation) {
    font-size: 12px;
    background: rgba(248, 113, 113, 0.2);
  }
  </style>
=== END FILE: ./src/components/canvas/clustermap/TopicClusterViz.vue ===


=== START FILE: ./src/components/canvas/InfiniteCanvas.vue ===
=== TYPE: vue ===

<template>
  <div class="fixed overflow-hidden bg-background transition-all duration-300" :style="{
    left: sidePanelOpen ? '40vw' : '0',
    right: '0',
    top: '0',
    bottom: '0'
  }">
    <!-- Main Canvas -->
    <div ref="canvasRef" class="absolute inset-0 transition-transform duration-500 ease-in-out"
      :class="{ '-translate-x-1/2': store.viewMode === '3d' }" @mousemove="handleMouseMove" @mouseup="handleMouseUp"
      @mouseleave="handleMouseUp" @mousedown="handleCanvasMouseDown" tabindex="0" @keydown="handleKeyDown">

      <!-- Canvas Transform Container -->
      <div class="absolute transform-gpu" :style="transformStyle">
        <!-- SVG Layer for Connections -->
        <svg class="absolute pointer-events-none overflow-visible" style="z-index: 1" :style="svgStyle"
          viewBox="0 0 100000 100000" preserveAspectRatio="none">
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" class="fill-primary" />
            </marker>
          </defs>

          <template v-for="connection in store.connections" :key="`${connection.parent.id}-${connection.child.id}`">
            <SplineConnector :start-node="connection.parent" :end-node="connection.child" :card-width="store.CARD_WIDTH"
              :card-height="store.CARD_HEIGHT" :is-active="isConnectionActive(connection)" :zoom-level="zoom" />
          </template>
        </svg>

        <!-- Nodes Layer -->
        <div class="absolute" :style="nodesLayerStyle" style="z-index: 2">
          <BranchNode v-for="node in store.nodes" :key="node.id" :open-router-api-key="openRouterApiKey" :node="node"
            :is-selected="isNodeFocused(node.id)" :selected-model="selectedModel" :zoom="zoom"
            :model-registry="modelRegistry" @select="handleNodeSelect(node.id)" @drag-start="handleDragStart"
            @create-branch="handleCreateBranch" @update-title="store.updateNodeTitle"
            @resend="(userMessageIndex) => handleResend(node.id, userMessageIndex)"
            @delete="() => store.removeNode(node.id)" :style="{
              transform: `translate(${node.x}px, ${node.y}px)`,
              transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
            }" />
        </div>
      </div>
    </div>

    <!-- Bottom Sheet Cluster Visualization -->
    <BottomSheetCluster :selected-topic="focusedTopicId" @select-topic="handleTopicSelect" />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount, watch } from 'vue';
import { useCanvasStore } from '../../stores/canvasStore';
import BranchNode from './node/BranchNode.vue';
import SplineConnector from './spline/SplineConnector.vue';
import BottomSheetCluster from './clustermap/BottomSheetCluster.vue';
// Add near the top with other refs
const modelRegistry = ref(new Map<string, ModelInfo>());

// Add the ModelInfo interface
interface ModelInfo {
  id: string;
  name: string;
  source: 'ollama' | 'openrouter' | 'custom';
  provider?: string;
}

const store = useCanvasStore();
const canvasRef = ref(null);

// State
const props = defineProps({
  selectedModel: {
    type: String,
    required: true,
    default: ''
  },
  openRouterApiKey: {
    type: String,
    required: true
  },
  modelType: {
    type: String,
    required: true,
    default: ''
  },
  sidePanelOpen: {
    type: Boolean,
    required: true
  },
  autoZoomEnabled: {
    type: Boolean,
    required: true
  },
  zoom: {  // Add this prop definition
    type: Number,
    required: true,
    default: 1
  }
});


const emit = defineEmits(['update:zoom', 'update:autoZoomEnabled']);

// Modify zoom ref to be computed
const zoom = computed({
  get: () => props.zoom,
  set: (value) => emit('update:zoom', value)
});

// Modify autoZoomEnabled to use prop
watch(() => props.autoZoomEnabled, (newValue) => {
  if (newValue) {
    autoFitNodes();
  }
});

const panX = ref(0);
const panY = ref(0);
const isPanning = ref(false);
const lastPanPosition = ref({ x: 0, y: 0 });
const focusedNodeId = ref(null);
const focusedTopicId = ref<string | null>(null);


const lastActivityTimestamp = ref(Date.now());
const autoZoomEnabled = ref(true);
const isAutoZooming = ref(false);
const AUTO_CENTER_DELAY = 30000; // 30 seconds
const inactivityTimer = ref(null);

const isClusterVizFocused = ref(false);
const windowSize = ref({
  width: typeof window !== 'undefined' ? window.innerWidth : 1920,
  height: typeof window !== 'undefined' ? window.innerHeight : 1080
});

const isBrowser = typeof window !== 'undefined';

// Helper Functions
const getNodeCenter = (node) => ({
  x: node.x + store.CARD_WIDTH / 2,
  y: node.y + store.CARD_HEIGHT / 2
});


const transformStyle = computed(() => ({
  transform: `scale(${zoom.value}) translate(${panX.value / zoom.value}px, ${panY.value / zoom.value}px)`,
  transformOrigin: '0 0',
  width: '100000px',
  height: '100000px',
  background: 'transparent',
  transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
}));

const svgStyle = computed(() => ({
  width: '100000px',
  height: '100000px'
}));

const nodesLayerStyle = computed(() => ({
  width: '100000px',
  height: '100000px',
  left: 0,
  top: 0
}));


const handleNodeSelect = (nodeId: string) => {
  centerOnNode(nodeId);
  focusedNodeId.value = nodeId;
};

const handleWheel = (e) => {
  resetInactivityTimer();
  // If it's a zoom event (Ctrl/Cmd + wheel)
  if (e.metaKey || e.ctrlKey) {
    e.preventDefault();

    const ZOOM_SENSITIVITY = 0.001;
    const ZOOM_MIN = 0.1;
    const ZOOM_MAX = 5;

    const rect = canvasRef.value.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const mouseContentX = (mouseX - panX.value) / zoom.value;
    const mouseContentY = (mouseY - panY.value) / zoom.value;

    const delta = -e.deltaY;
    const newZoom = Math.min(
      Math.max(zoom.value * (1 + delta * ZOOM_SENSITIVITY), ZOOM_MIN),
      ZOOM_MAX
    );

    zoom.value = newZoom;
    panX.value = mouseX - mouseContentX * newZoom;
    panY.value = mouseY - mouseContentY * newZoom;
  } else {
    panX.value -= e.deltaX;
    panY.value -= e.deltaY;
  }
};

const handleTopicSelect = (node: any) => {
  focusedTopicId.value = node.id;
};

onMounted(() => {
  if (isBrowser) {
    window.addEventListener('keydown', handleKeyDown);
    if (canvasRef.value) {
      canvasRef.value.addEventListener('wheel', handleWheel, { passive: false });
    }

    if (store.nodes.length) {
      autoFitNodes();
    }

    resetInactivityTimer();
  }
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyDown);
  if (canvasRef.value) {
    canvasRef.value.removeEventListener('wheel', handleWheel);
  }
  if (inactivityTimer.value) {
    clearTimeout(inactivityTimer.value);
  }
});

watch(() => store.nodes.length, () => {
  resetInactivityTimer();
});


const centerOnNode = (nodeId) => {
  const node = store.nodes.find(n => n.id === nodeId);
  if (!node) return;

  store.isTransitioning = true;
  const center = getNodeCenter(node);

  const rect = canvasRef.value.getBoundingClientRect();
  // Center the node in the viewport
  panX.value = (rect.width / 2) - (center.x * zoom.value);
  panY.value = (rect.height / 2) - (center.y * zoom.value);

  focusedNodeId.value = nodeId;

  setTimeout(() => {
    store.isTransitioning = false;
  }, 300);
};

const handleCreateBranch = (parentId: string, messageIndex: number, position: { x: number, y: number }, initialData: any) => {
  const parentNode = store.nodes.find(n => n.id === parentId);
  if (!parentNode) return;

  // Find existing branches from this parent
  const existingBranches = store.nodes.filter(n => n.parentId === parentId);

  // Determine initial vertical offset based on number of existing branches
  const verticalOffset = existingBranches.length * (store.CARD_HEIGHT + 20);

  // Update position
  const adjustedPosition = {
    x: position.x,
    y: parentNode.y + verticalOffset
  };

  // Create the new node
  const newNode = store.addNode(parentId, messageIndex, adjustedPosition, {
    ...initialData,
    // Ensure vertical offset is preserved in node data
    y: adjustedPosition.y
  });

  // First center on the new node
  centerOnNode(newNode.id);

  // Then after centering transition, auto fit to show all nodes
  setTimeout(() => {
    autoFitNodes();
  }, 400); // Slightly longer than centerOnNode transition
};

const handleResend = async (nodeId: string, userMessageIndex: number) => {
  const node = store.nodes.find(n => n.id === nodeId);
  if (!node || !node.messages) return;

  const userMsg = node.messages[userMessageIndex];
  if (!userMsg || userMsg.role !== 'user') return;

  // Remove the AI response that follows this user message
  store.removeMessage(nodeId, userMessageIndex + 1);

  // Set up model info in registry before sending
  let modelInfo: ModelInfo;
  if (props.selectedModel === 'custom_model') {
    modelInfo = {
      id: 'custom_model',
      name: 'Custom Model',
      source: 'custom'
    };
  } else {
    modelInfo = {
      id: props.selectedModel,
      name: props.selectedModel.includes('/') ? props.selectedModel.split('/')[1] : props.selectedModel,
      source: props.modelType === 'ollama' ? 'ollama' : 'openrouter',
      provider: props.modelType === 'openrouter' ? props.selectedModel.split('/')[0] : undefined
    };
  }

  modelRegistry.value.set(props.selectedModel, modelInfo);

  // Pass false for addUserMessage since we're reusing the existing message
  await store.sendMessage(nodeId, userMsg.content, props.selectedModel, props.openRouterApiKey, false);
};

const findNodeInDirection = (currentNode, connections, direction) => {
  const connectedNodes = connections
    .filter(conn =>
      conn.parent.id === currentNode.id ||
      conn.child.id === currentNode.id
    )
    .map(conn =>
      conn.parent.id === currentNode.id ? conn.child : conn.parent
    );

  const currentCenter = getNodeCenter(currentNode);

  return connectedNodes
    .filter(node => {
      const nodeCenter = getNodeCenter(node);
      return direction === 'up'
        ? nodeCenter.y < currentCenter.y
        : nodeCenter.y > currentCenter.y;
    })
    .sort((a, b) => {
      const aCenter = getNodeCenter(a);
      const bCenter = getNodeCenter(b);
      const aDist = Math.abs(aCenter.y - currentCenter.y);
      const bDist = Math.abs(bCenter.y - currentCenter.y);
      return aDist - bDist;
    })[0]?.id;
};


const handleMouseUp = () => {
  store.isDragging = false;
  store.activeNode = null;
  isPanning.value = false;
};

const handleCanvasMouseDown = (e) => {
  if (e.button === 0 && !store.isDragging) {
    isPanning.value = true;
    lastPanPosition.value = { x: e.clientX - panX.value, y: e.clientY - panY.value };
  }
};

const handleKeyDown = (e) => {
  if (store.isTransitioning) return;

  if (e.key === 'Escape' && isClusterVizFocused.value) {
    unfocusClusterViz();
    return;
  }

  const currentNode = store.nodes.find(n => n.id === focusedNodeId.value);
  if (!currentNode) return;

  const connections = store.connections;
  let targetNodeId = null;

  switch (e.key) {
    case 'ArrowUp':
      targetNodeId = findNodeInDirection(currentNode, connections, 'up');
      break;
    case 'ArrowDown':
      targetNodeId = findNodeInDirection(currentNode, connections, 'down');
      break;
    case 'ArrowRight':
      targetNodeId = currentNode.parentId;
      break;
    case 'ArrowLeft':
      targetNodeId = connections
        .find(conn => conn.parent.id === currentNode.id)?.child.id;
      break;
  }

  if (targetNodeId) {
    centerOnNode(targetNodeId);
  }
};

const handleClusterVizClick = (e: MouseEvent) => {
  if (!isClusterVizFocused.value) {
    e.stopPropagation();

    store.isTransitioning = true;
    isClusterVizFocused.value = true;
    isPanning.value = false;
    store.isDragging = false;
  }
};


const unfocusClusterViz = () => {
  // First step: Start unfocus transition
  store.isTransitioning = true;

  // Second step: Unfocus
  isClusterVizFocused.value = false;
  focusedTopicId.value = null;

  // Third step: After transition, re-enable canvas and reset
  setTimeout(() => {
    store.isTransitioning = false;
    autoFitNodes();
  }, 700); // Match the transition duration
};

// Event Handlers
const calculateNodesBounds = () => {
  if (!store.nodes.length) return null;

  const bounds = store.nodes.reduce((acc, node) => {
    const nodeWidth = store.CARD_WIDTH;
    const nodeHeight = store.CARD_HEIGHT;

    return {
      minX: Math.min(acc.minX, node.x),
      maxX: Math.max(acc.maxX, node.x + nodeWidth),
      minY: Math.min(acc.minY, node.y),
      maxY: Math.max(acc.maxY, node.y + nodeHeight)
    };
  }, {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  });

  return bounds;
};

// Function to auto-center and zoom to fit all nodes
const autoFitNodes = () => {
  if (!canvasRef.value || !autoZoomEnabled.value || store.isDragging || isPanning.value) return;

  const bounds = calculateNodesBounds();
  if (!bounds) return;

  const rect = canvasRef.value.getBoundingClientRect();
  const padding = 100; // Padding around the nodes

  // Calculate required zoom to fit all nodes
  const contentWidth = bounds.maxX - bounds.minX + (padding * 2);
  const contentHeight = bounds.maxY - bounds.minY + (padding * 2);
  const scaleX = rect.width / contentWidth;
  const scaleY = rect.height / contentHeight;
  const newZoom = Math.min(scaleX, scaleY, 1); // Cap zoom at 1 to prevent too much zoom

  // Calculate center point of all nodes
  const centerX = (bounds.minX + bounds.maxX) / 2;
  const centerY = (bounds.minY + bounds.maxY) / 2;

  isAutoZooming.value = true;
  store.isTransitioning = true;

  // Animate to new position and zoom
  zoom.value = newZoom;
  panX.value = (rect.width / 2) - (centerX * newZoom);
  panY.value = (rect.height / 2) - (centerY * newZoom);

  setTimeout(() => {
    isAutoZooming.value = false;
    store.isTransitioning = false;
  }, 300);
};


defineExpose({
  autoFitNodes
});

// Function to reset inactivity timer
const resetInactivityTimer = () => {
  if (inactivityTimer.value) {
    clearTimeout(inactivityTimer.value);
  }

  lastActivityTimestamp.value = Date.now();

  inactivityTimer.value = setTimeout(() => {
    if (Date.now() - lastActivityTimestamp.value >= AUTO_CENTER_DELAY) {
      autoFitNodes();
    }
  }, AUTO_CENTER_DELAY);
};


const handleMouseMove = (e) => {
  if (isClusterVizFocused.value) return;
  resetInactivityTimer();

  if (store.isDragging && store.activeNode) {
    // Handle node dragging
    const canvasRect = canvasRef.value.getBoundingClientRect();

    // Calculate the new position in canvas space
    const canvasX = (e.clientX - canvasRect.left - panX.value) / zoom.value;
    const canvasY = (e.clientY - canvasRect.top - panY.value) / zoom.value;

    // Update node position accounting for the initial click offset
    store.updateNodePosition(store.activeNode, {
      x: canvasX - store.dragOffset.x,
      y: canvasY - store.dragOffset.y
    });
  } else if (isPanning.value) {
    // Handle canvas panning
    const dx = e.clientX - lastPanPosition.value.x;
    const dy = e.clientY - lastPanPosition.value.y;
    panX.value = dx;
    panY.value = dy;
  }
};

const handleDragStart = (e, node) => {
  store.isDragging = true;
  store.activeNode = node.id;

  const canvasRect = canvasRef.value.getBoundingClientRect();

  // Calculate the initial click position in canvas space
  const canvasX = (e.clientX - canvasRect.left - panX.value) / zoom.value;
  const canvasY = (e.clientY - canvasRect.top - panY.value) / zoom.value;

  // Calculate offset from the node's position
  store.dragOffset = {
    x: canvasX - node.x,
    y: canvasY - node.y
  };
};

// Active State Checks
const isNodeFocused = (nodeId) => focusedNodeId.value === nodeId;

const isConnectionActive = (connection) => {
  if (!focusedNodeId.value) return false;
  return connection.parent.id === focusedNodeId.value ||
    connection.child.id === focusedNodeId.value;
};

// Lifecycle
onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
  canvasRef.value?.focus();

  if (store.nodes.length) {
    centerOnNode(store.nodes[0].id);
  }
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyDown);
});
</script>

<style scoped>
/* GPU Acceleration */
.transform-gpu {
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
  perspective: 1000px;
  overflow: hidden;
}

/* Layout & Positioning */
.fixed {
  overflow: hidden;
  z-index: 40;
}

.absolute {
  overflow: visible;
}

/* Basic Transitions */
.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 500ms;
}

.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 300ms;
}

/* Focus States */
div:focus {
  outline: none;
}

div:focus-visible {
  outline: none;
  box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.1);
}

/* Canvas Controls */
.canvas-control {
  position: fixed;
  padding: 0.375rem 0.75rem;
  background-color: rgb(var(--color-base-200) / 0.9);
  backdrop-filter: blur(4px);
  border-radius: 9999px;
  border: 1px solid rgb(var(--color-base-300));
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
}

.canvas-control:hover {
  background-color: rgb(var(--color-base-300) / 0.9);
}

/* Transform Utilities */
.will-change-transform {
  will-change: transform;
}

.transform-smooth {
  transition: transform 0.3s ease-out;
}

/* Container Styles */
.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  touch-action: none;
  user-select: none;
}

/* SVG Layer */
.svg-layer {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 1;
}

/* Node Layer */
.node-layer {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2;
}

/* Animation States */
.enter-active,
.leave-active {
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.enter-from,
.leave-to {
  opacity: 0;
  transform: scale(0.95);
}

/* Performance Optimizations */
.hardware-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
}
</style>
=== END FILE: ./src/components/canvas/InfiniteCanvas.vue ===


=== START FILE: ./src/components/canvas/spline/SplineConnector.vue ===
=== TYPE: vue ===

<template>
  <g>
    <!-- Main dashed path -->
    <path :d="pathData" :stroke="isActive ? '#2563eb' : '#94a3b8'" :stroke-width="strokeWidth" fill="none"
      :stroke-dasharray="dashPattern" class="transition-all duration-200" opacity="0.4" />

    <!-- Particles with scaled radius -->
    <g v-for="particle in particles" :key="particle.id">
      <circle :cx="particle.x" :cy="particle.y" :r="particleRadius" :fill="isActive ? '#2563eb' : '#94a3b8'">
        <animate attributeName="opacity" values="1;0.3;1" :dur="particle.duration" repeatCount="indefinite" />
      </circle>
    </g>


    <!-- Hidden path for text alignment -->
    <path :id="`connection-path-${startNode.id}-${endNode.id}`" :d="isLeftBranch ? reversedPathData : pathData"
      fill="none" stroke="none" />

    <!-- Label Container -->
    <g class="label-container">
      <text class="text-container">
        <textPath :href="`#connection-path-${startNode.id}-${endNode.id}`" startOffset="50%" text-anchor="middle"
          :side="isLeftBranch ? 'right' : 'left'" :class="{ 'reversed': isLeftBranch }">
          <tspan :dy="-12" class="label-text" :style="labelStyle">
            <tspan @dblclick.stop.prevent="handleLabelDoubleClick" class="label-background" v-if="!isEditing">
              {{ getLabelText() }}
            </tspan>
          </tspan>
        </textPath>
      </text>

      <!-- Edit Input -->
      <foreignObject v-if="isEditing" :x="calculateLabelPosition().x" :y="calculateLabelPosition().y"
        :width="300 / Math.min(1, zoomLevel)" :height="50 / Math.min(1, zoomLevel)" @dblclick.stop.prevent>
        <div xmlns="http://www.w3.org/2000/svg" class="flex items-center justify-center w-full h-full">
          <input ref="inputRef" v-model="labelInput" @blur="handleLabelBlur" @keydown="handleKeyDown"
            class="bg-base-100 border border-base-300 rounded px-3 py-2 text-center w-full" :style="inputStyle" />
        </div>
      </foreignObject>
    </g>
  </g>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue';

const props = defineProps({
  startNode: {
    type: Object,
    required: true
  },
  endNode: {
    type: Object,
    required: true
  },
  cardWidth: {
    type: Number,
    required: true
  },
  cardHeight: {
    type: Number,
    required: true
  },
  isActive: {
    type: Boolean,
    default: false
  },
  zoomLevel: {
    type: Number,
    default: 1
  }
});

// State
const isEditing = ref(false);
const labelInput = ref('');
const customLabel = ref('');
const inputRef = ref(null);
const particles = ref([]);
let animationFrame = null;

// Constants

const baseStroke = 1.5;
const baseFontSize = 14;
const baseParticleRadius = 3;
const baseParticleSpeed = 0.002;
const numParticles = 4;

const strokeWidth = computed(() => {
  const scale = 1 / Math.pow(props.zoomLevel, 1.2); // More aggressive scaling
  return baseStroke * Math.min(scale, 4); // Increased max scale
});

// Enhanced scaling for dash pattern
const dashPattern = computed(() => {
  const scale = 1 / Math.pow(props.zoomLevel, 1.2);
  const dash = 4 * Math.min(scale, 4);
  const gap = 6 * Math.min(scale, 4);
  return `${dash} ${gap}`;
});

// Enhanced scaling for particles
const particleRadius = computed(() => {
  const scale = 1 / Math.pow(props.zoomLevel, 1.2);
  return baseParticleRadius * Math.min(scale, 4);
});

// Adjust particle speed based on zoom
const getParticleSpeed = () => {
  const scale = 1 / Math.max(0.3, props.zoomLevel);
  return baseParticleSpeed * Math.min(scale, 2);
};

const fontSize = computed(() => {
  const scaleFactor = 1 / Math.min(1, props.zoomLevel);
  return Math.max(baseFontSize * scaleFactor, baseFontSize);
});

const isLeftBranch = computed(() => {
  return props.endNode.type === 'left-branch';
});

const labelStyle = computed(() => ({
  fontSize: `${fontSize.value}px`,
  fontWeight: 500
}));

const inputStyle = computed(() => ({
  fontSize: `${fontSize.value}px`,
  fontWeight: 500,
  transform: `scale(${1 / props.zoomLevel})`,
  transformOrigin: 'center'
}));

// Path calculations
const calculateConnectionPoints = () => {
  const messageIndex = props.endNode.branchMessageIndex || 0;
  const messageYOffset = messageIndex * 120 + 40;
  const startOffset = 1;

  const startPoint = {
    x: isLeftBranch.value
      ? props.startNode.x - startOffset
      : props.startNode.x + props.cardWidth + startOffset,
    y: props.startNode.y + messageYOffset
  };

  const endPoint = {
    x: props.endNode.x + (isLeftBranch.value ? props.cardWidth : 0),
    y: props.endNode.y + props.cardHeight / 2
  };

  return { startPoint, endPoint };
};

const pathData = computed(() => {
  const { startPoint, endPoint } = calculateConnectionPoints();

  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const controlPointDistance = Math.min(60, distance * 0.3);

  const controlPoint1 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y
  };

  const controlPoint2 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y
  };

  return `M ${startPoint.x} ${startPoint.y} 
          C ${controlPoint1.x} ${controlPoint1.y},
            ${controlPoint2.x} ${controlPoint2.y},
            ${endPoint.x} ${endPoint.y}`;
});

const reversedPathData = computed(() => {
  const { startPoint, endPoint } = calculateConnectionPoints();

  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const controlPointDistance = Math.min(60, distance * 0.3);

  const controlPoint1 = {
    x: endPoint.x + controlPointDistance,
    y: endPoint.y
  };

  const controlPoint2 = {
    x: startPoint.x - controlPointDistance,
    y: startPoint.y
  };

  return `M ${endPoint.x} ${endPoint.y} 
          C ${controlPoint1.x} ${controlPoint1.y},
            ${controlPoint2.x} ${controlPoint2.y},
            ${startPoint.x} ${startPoint.y}`;
});

// Particle animation
const getPointOnCurve = (t, startPoint, controlPoint1, controlPoint2, endPoint) => {
  const t1 = 1 - t;
  return {
    x: Math.pow(t1, 3) * startPoint.x +
      3 * Math.pow(t1, 2) * t * controlPoint1.x +
      3 * t1 * Math.pow(t, 2) * controlPoint2.x +
      Math.pow(t, 3) * endPoint.x,
    y: Math.pow(t1, 3) * startPoint.y +
      3 * Math.pow(t1, 2) * t * controlPoint1.y +
      3 * t1 * Math.pow(t, 2) * controlPoint2.y +
      Math.pow(t, 3) * endPoint.y
  };
};

const initializeParticles = () => {
  const newParticles = [];
  const baseSpeed = getParticleSpeed();

  for (let i = 0; i < numParticles; i++) {
    newParticles.push({
      id: i,
      progress: i / numParticles,
      speed: baseSpeed + (Math.random() * baseSpeed * 0.5), // Add some randomness
      duration: `${0.8 + Math.random() * 0.4}s`
    });
  }
  particles.value = newParticles;
};


const animateParticles = () => {
  const { startPoint, endPoint } = calculateConnectionPoints();
  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const controlPointDistance = Math.min(60, distance * 0.3);

  const controlPoint1 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y
  };

  const controlPoint2 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y
  };

  // Get current base speed based on zoom level
  const baseSpeed = getParticleSpeed();

  particles.value = particles.value.map(particle => {
    // Update particle speed based on current zoom level while maintaining relative randomness
    const relativeSpeedFactor = particle.speed / (particle.speed - (Math.random() * particle.speed * 0.5));
    const newSpeed = baseSpeed + (Math.random() * baseSpeed * 0.5);
    particle.speed = newSpeed * relativeSpeedFactor;

    // Update progress with new speed
    particle.progress += particle.speed;
    if (particle.progress > 1) {
      particle.progress = 0;
    }

    const point = getPointOnCurve(
      particle.progress,
      startPoint,
      controlPoint1,
      controlPoint2,
      endPoint
    );

    return {
      ...particle,
      x: point.x,
      y: point.y
    };
  });

  animationFrame = requestAnimationFrame(animateParticles);
};

onMounted(() => {
  initializeParticles();
  animateParticles();
});

onUnmounted(() => {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
  }
});

// Label position calculation
const calculateLabelPosition = () => {
  const { startPoint, endPoint } = calculateConnectionPoints();
  const midX = startPoint.x + (endPoint.x - startPoint.x) / 2;
  const midY = startPoint.y + (endPoint.y - startPoint.y) / 2;

  return {
    x: midX - (150 / Math.min(1, props.zoomLevel)),
    y: midY - (25 / Math.min(1, props.zoomLevel))
  };
};

// Label text handling
const getLabelText = () => {
  if (customLabel.value) {
    return customLabel.value;
  }

  const messageIndex = props.endNode.branchMessageIndex;
  const message = props.startNode.messages?.[messageIndex];

  if (message?.content) {
    const words = message.content.split(' ').slice(0, 3).join(' ');
    return words.length > 20 ? words.substring(0, 20) + '...' : words;
  }

  return `Branch ${messageIndex + 1}`;
};

const handleLabelDoubleClick = (event) => {
  event.stopPropagation();
  event.preventDefault();

  if (!isEditing.value) {
    isEditing.value = true;
    labelInput.value = customLabel.value || getLabelText();
    nextTick(() => {
      inputRef.value?.focus();
    });
  }
};

const handleLabelBlur = () => {
  if (labelInput.value.trim()) {
    customLabel.value = labelInput.value.trim();
  }
  isEditing.value = false;
};

const handleKeyDown = (event) => {
  if (event.key === 'Enter') {
    handleLabelBlur();
  } else if (event.key === 'Escape') {
    isEditing.value = false;
  }
};
</script>

<style scoped>
.text-container {
  pointer-events: none;
}

.label-text {
  pointer-events: none;
  fill: var(--color-base-content);
  opacity: 0.8;
}

.label-background {
  pointer-events: all;
  cursor: pointer;
  fill: currentColor;
  background: var(--color-base-100);
  padding: 4px 12px;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.label-background:hover {
  background: var(--color-base-200);
}

input {
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 2px var(--color-primary/0.2);
}

textPath.reversed {
  transform: scale(1, -1);
}
</style>
=== END FILE: ./src/components/canvas/spline/SplineConnector.vue ===


=== START FILE: ./src/components/canvas/node/BranchNode.vue ===
=== TYPE: vue ===

<template>
  <div class="branch-node" :data-node-id="node.id" :class="{
    'selected': isSelected,
    'streaming': node.streamingContent,
    'active': isStreaming,
    'fading-out': !node.streamingContent && isStreaming,
    'draggable': isDraggable
  }" @click="$emit('select')" @mousedown="handleMouseDown" @mousemove="handleMouseMove" @mouseup="handleMouseUp">
    <Card :class="[
      'node-card max-w-2xl w-[42rem]',
      'backdrop-blur transition-all duration-300'
    ]" :style="{
      ...nodeStyles,
      backgroundColor: `${threadColor}05`,
      '--tw-backdrop-blur': '8px',
      borderColor: `${threadColor}20`
    }">
      <!-- Model Avatars -->
      <div class="absolute -top-4 left-1/2 transform -translate-x-1/2 flex -space-x-2 px-2">
        <div v-for="model in uniqueModels" :key="model.id" class="relative group w-9 h-9">
          <img :src="getAvatarUrl(model)" alt="Provider Avatar"
            class="w-9 h-9 rounded-full border-2 border-base-100 shadow-md object-cover" />
          <div
            class="avatar-overlay transition-opacity duration-200 opacity-0 absolute inset-0 rounded-full bg-black/30 group-hover:opacity-100">
          </div>
          <div class="absolute bottom-full mb-2 hidden group-hover:block z-50"
            style="left: 50%; transform: translateX(-50%);">
            <div class="bg-base-100 border rounded-md shadow-lg px-2 py-1 text-xs whitespace-nowrap text-base-content">
              {{ model.name }}
            </div>
          </div>
        </div>
      </div>

      <div class="p-4">
        <div class="flex items-center justify-between mb-4">
          <!-- Header Content -->
          <div class="flex items-center gap-3">
            <button @click.stop="isExpanded = !isExpanded" class="p-2 rounded-full hover:bg-white/10 transition-colors"
              :style="{ color: threadColor }">
              <ChevronDown class="w-5 h-5 transition-transform duration-200" :class="{ '-rotate-90': !isExpanded }" />
            </button>

            <div class="flex flex-col">
              <!-- Title Section -->
              <div class="flex items-center gap-2">
                <template v-if="isEditing">
                  <input ref="titleInputRef" v-model="titleInput" @blur="handleTitleUpdate"
                    @keyup.enter="handleTitleUpdate" class="bg-base-100 px-2 py-1 rounded border text-base-content"
                    placeholder="Enter title..." />
                </template>
                <template v-else>
                  <span class="text-lg font-semibold truncate max-w-lg text-base-content">
                    {{ node.title || "Untitled Thread" }}
                  </span>
                  <button @click.stop="startEditing" class="p-1 rounded-full hover:bg-white/10 flex-shrink-0">
                    <Edit2 class="w-4 h-4 text-base-content/60" />
                  </button>
                </template>
              </div>

              <!-- Message Count -->
              <div class="flex items-center gap-2 mt-1">
                <MessageCircle class="w-4 h-4 text-base-content/60" />
                <span class="text-sm text-base-content/60">
                  {{ node.messages?.length || 0 }} messages
                </span>
              </div>
            </div>
          </div>

          <!-- Delete Button -->
          <button v-if="node.type !== 'main'"
            class="p-2 rounded-full hover:bg-destructive/10 text-base-content/60 hover:text-destructive flex-shrink-0"
            @click.stop="$emit('delete')">
            <X class="w-5 h-5" />
          </button>
        </div>

        <!-- Messages -->
        <div v-if="isExpanded && node.messages" class="space-y-4">
          <div v-for="(msg, i) in displayMessages" :key="i" class="relative group message-container"
            :style="getMessageStyles(i)">
            <MessageTimestamp :timestamp="msg.timestamp" :side="node.type === 'branch' ? 'left' : 'right'" />

            <!-- Branch Buttons -->
            <div
              class="absolute inset-y-0 -left-12 flex items-center opacity-0 group-hover:opacity-100 transition-all duration-200 ease-in-out z-20">
              <button @click.stop="createBranch(i, 'left')"
                class="p-2 rounded-full hover:bg-white/10 transition-colors group/btn" :style="{ color: threadColor }"
                title="Branch left">
                <div class="relative">
                  <GitBranch class="w-5 h-5 transform -scale-x-100" />
                  <div
                    class="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap opacity-0 group-hover/btn:opacity-100 transition-opacity duration-200 text-xs bg-base-300/90 backdrop-blur px-2 py-1 rounded">
                    Branch left
                  </div>
                </div>
              </button>
            </div>

            <div
              class="absolute inset-y-0 -right-12 flex items-center opacity-0 group-hover:opacity-100 transition-all duration-200 ease-in-out z-20">
              <button @click.stop="createBranch(i, 'right')"
                class="p-2 rounded-full hover:bg-white/10 transition-colors group/btn" :style="{ color: threadColor }"
                title="Branch right">
                <div class="relative">
                  <GitBranch class="w-5 h-5" />
                  <div
                    class="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap opacity-0 group-hover/btn:opacity-100 transition-opacity duration-200 text-xs bg-base-300/90 backdrop-blur px-2 py-1 rounded">
                    Branch right
                  </div>
                </div>
              </button>
            </div>

            <div class="p-4 relative z-10">
              <!-- Message Header -->
              <div class="flex items-center justify-between mb-2">
                <Badge :variant="msg.role === 'user' ? 'default' : msg.isStreaming ? 'outline' : 'secondary'"
                  class="text-xs">
                  {{ msg.role === 'user' ? 'You' : msg.isStreaming ? 'AI Typing...' : 'AI' }}
                </Badge>

                <div class="flex items-center gap-2" v-if="!msg.isStreaming">
                  <button @click.stop="expandMessage(i)" class="p-1.5 rounded-full hover:bg-white/10">
                    <component :is="expandedMessages.has(i) ? Maximize2 : Minimize2"
                      class="w-4 h-4 text-base-content/60" />
                  </button>
                </div>
              </div>

              <!-- Message Content -->
              <div class="text-sm break-words overflow-hidden" :class="{
                'line-clamp-2': expandedMessages.has(i),
                'whitespace-pre-wrap': !msg.isStreaming,
                'whitespace-normal': msg.isStreaming
              }">
                <MessageContent :content="msg.content" :is-streaming="msg.isStreaming" />
              </div>

              <!-- Message Actions -->
              <div class="mt-3 flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <button v-if="msg.isStreaming"
                    class="flex items-center gap-2 text-sm text-red-500 hover:underline opacity-0 group-hover:opacity-100 transition-opacity"
                    @click.stop="stopStreaming">
                    <XCircle class="w-4 h-4" />
                    Stop
                  </button>

                  <button v-else-if="msg.role === 'assistant'"
                    class="flex items-center gap-2 text-sm hover:underline opacity-0 group-hover:opacity-100 transition-opacity"
                    :style="{ color: threadColor }" @click.stop="$emit('resend', i - 1)">
                    <RotateCw class="w-4 h-4" />
                    Resend
                  </button>
                </div>

                <!-- Model Badge -->
                <div v-if="msg.role === 'assistant'"
                  class="model-badge opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-2 px-3 py-1 rounded-full text-xs bg-base-100/90 border border-base-200">
                  <img :src="getAvatarUrl(getModelInfo(msg.modelId))" alt="Model Avatar"
                    class="w-4 h-4 rounded-full object-cover" />
                  <span class="text-base-content">
                    {{ getModelInfo(msg.modelId)?.name || 'Unknown Model' }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Collapsed View -->
        <div v-else-if="node.messages?.length" class="mt-2 text-sm text-base-content/60">
          <div class="line-clamp-2 break-words overflow-hidden">
            Last message:
            {{ node.streamingContent || node.messages[node.messages.length - 1]?.content }}
          </div>
        </div>
      </div>

      <MessageInput :is-loading="isLoading" @send="handleMessageSend" @stop="stopStreaming" />
    </Card>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, nextTick, onBeforeUnmount, watch } from 'vue';
import type { PropType } from 'vue';
import {
  ChevronDown, MessageCircle, Edit2, X,
  Maximize2, Minimize2, XCircle, RotateCw
} from 'lucide-vue-next';

import MessageInput from '../../messages/MessageInput.vue';
import { useCanvasStore } from '../../../stores/canvasStore';
import Card from '../../ui/Card.vue';
import Badge from '../../ui/Badge.vue';
import MessageContent from '../../messages/MessageContent.vue';
import MessageTimestamp from '../../messages/MessageTimestamp.vue';
import type { Message, Node } from '../../../types/message';
import anthropic from '@/assets/anthropic.jpeg'
import openai from '@/assets/openai.jpeg'
import google from '@/assets/google.jpeg'
import meta from '@/assets/meta.jpeg'
import mistral from '@/assets/mistral.jpeg'
import unknownAvatar from '@/assets/unknown.jpeg'
import ollama from '@/assets/ollama.jpeg'
import { GitBranch } from 'lucide-vue-next';

interface ModelInfo {
  id: string;
  name: string;
  source: 'ollama' | 'openrouter';
  provider?: string;
}

interface ExtendedMessage extends Message {
  modelId?: string;
}

interface ExtendedNode extends Node {
  messages: ExtendedMessage[];
  streamingContent: string | null
}

const props = defineProps({
  node: {
    type: Object as PropType<ExtendedNode>,
    required: true
  },
  isSelected: Boolean,
  selectedModel: {
    type: String,
    required: true
  },
  openRouterApiKey: {
    type: String,
    required: true
  },
  zoom: {
    type: Number,
    required: true
  },
  modelRegistry: {
    type: Object as PropType<Map<string, ModelInfo>>,
    required: true
  }
});


const emit = defineEmits(['select', 'drag-start', 'create-branch', 'update-title', 'delete', 'resend']);

// UI states
const isExpanded = ref(true);
const isEditing = ref(false);
const titleInput = ref('');
const expandedMessages = ref(new Set<number>());
const titleInputRef = ref<HTMLElement | null>(null);
const isDraggable = ref(false);
const dragStartPosition = ref({ x: 0, y: 0 });
const DRAG_THRESHOLD = 5; // Pixels to move before initiating drag
const isStreaming = ref(false);
const fadeTimeout = ref<number | null>(null);

// Store
const store = useCanvasStore();

// Loading / streaming states
const isLoading = ref(false);
// We'll store a single AbortController for the current request
let abortController: AbortController | null = null;

// Watch for title changes
watch(
  () => props.node.title,
  (newTitle) => {
    titleInput.value = newTitle || '';
  },
  { immediate: true }
);

watch(() => props.node.streamingContent, (newVal) => {
  if (newVal) {
    // Clear any existing timeout
    if (fadeTimeout.value) {
      clearTimeout(fadeTimeout.value);
    }
    isStreaming.value = true;
  } else if (isStreaming.value) {
    // Only start fade out if we were streaming
    fadeTimeout.value = setTimeout(() => {
      isStreaming.value = false;
    }, 1000); // Match this to your transition duration
  }
});

const threadColor = computed(() => {
  const hues = [210, 330, 160, 280, 40, 190];
  // Simple pseudo-random approach based on the node ID
  const index = Math.abs(Math.floor(Number(props.node.id) * Math.sin(Number(props.node.id))) % hues.length);
  return `hsl(${hues[index]}, 85%, 45%)`;
});

const displayMessages = computed((): Message[] => {
  if (!props.node.messages) return [];
  return props.node.streamingContent
    ? [
      ...props.node.messages,
      {
        role: 'assistant',
        content: props.node.streamingContent,
        isStreaming: true,
        timestamp: new Date().toISOString()
      }
    ]
    : props.node.messages;
});

const providerAvatars: Record<string, string> = {
  Anthropic: anthropic,
  OpenAI: openai,
  Google: google,
  Meta: meta,
  Mistral: mistral,
  Unknown: unknownAvatar,
  ollama: ollama
};

function getAvatarUrl(model?: ModelInfo): string {
  if (!model) return providerAvatars['Unknown'];

  if (model.source === 'ollama') {
    return providerAvatars['ollama'];
  }

  // For openrouter models
  const avatar = model.provider ? providerAvatars[model.provider] : providerAvatars['Unknown'];
  return avatar || providerAvatars['Unknown'];
}

const uniqueModels = computed(() => {
  const models = new Set<ModelInfo>();
  if (!props.node.messages) return [];

  props.node.messages.forEach((msg) => {
    if (msg.modelId) {
      const model = getModelInfo(msg.modelId);
      if (model) models.add(model);
    }
  });
  return Array.from(models);
});


function getModelInfo(modelId?: string): ModelInfo | undefined {
  if (!modelId) return undefined;

  // First try to get from registry
  const registryModel = props.modelRegistry.get(modelId);
  if (registryModel) return registryModel;

  // Fallback: Parse from model ID if not in registry
  if (modelId.includes('/')) {
    const [provider, name] = modelId.split('/');
    return {
      id: modelId,
      name,
      source: 'openrouter',
      provider
    };
  }

  return {
    id: modelId,
    name: modelId,
    source: 'ollama'
  };
}

const nodeStyles = computed(() => ({
  '--border-color': threadColor.value,
  '--border-color-light': `${threadColor.value}50`
}));

/* ------------------
   Drag event handlers
------------------ */
const handleMouseDown = (e: MouseEvent) => {
  
  if (props.node.type !== 'main') {
    dragStartPosition.value = { x: e.clientX, y: e.clientY };
    isDraggable.value = true;
  }
};

const handleMouseMove = (e: MouseEvent) => {
  if (!isDraggable.value) return;
  const dx = Math.abs(e.clientX - dragStartPosition.value.x);
  const dy = Math.abs(e.clientY - dragStartPosition.value.y);

  if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
    e.stopPropagation();
    isDraggable.value = false;
    emit('drag-start', e, props.node);
  }
};

const handleMouseUp = () => {
  isDraggable.value = false;
};

/* ------------------
   Title editing
------------------ */
const startEditing = () => {
  isEditing.value = true;
  titleInput.value = props.node.title || '';
  nextTick(() => {
    if (titleInputRef.value) {
      (titleInputRef.value as HTMLInputElement).focus();
      (titleInputRef.value as HTMLInputElement).select();
    }
  });
};

const handleTitleUpdate = () => {
  if (titleInput.value.trim()) {
    emit('update-title', props.node.id, titleInput.value.trim());
  }
  isEditing.value = false;
};

/* ------------------
   Branch creation
------------------ */
const createBranch = (messageIndex: number, direction: 'left' | 'right') => {
  const horizontalOffset = direction === 'left'
    ? -store.CARD_WIDTH - 100
    : store.CARD_WIDTH + 100;

  // Calculate new branch position
  const position = {
    x: props.node.x + horizontalOffset,
    y: props.node.y  // Let handleCreateBranch handle vertical positioning
  };

  // Create initial data for the new branch
  const initialData = {
    title: `Branch from "${props.node.title || 'Untitled Thread'}"`,
    messages: props.node.messages.slice(0, messageIndex + 1),
    branchMessageIndex: messageIndex,
    // This is crucial for connector positioning
    type: direction === 'left' ? 'left-branch' : 'right-branch'
  };

  emit('create-branch', props.node.id, messageIndex, position, initialData);
};

/* ------------------
   Message sending
------------------ */

async function handleMessageSend(message: string) {
  isLoading.value = true;
  try {
    await store.sendMessage(props.node.id, message, props.selectedModel, props.openRouterApiKey);
    // Auto-generate title for new conversations
    if (props.node.messages.length === 2 && !props.node.title) {
      generateTitle();
    }
  } catch (error) {
    console.error('Error sending message:', error);
  } finally {
    isLoading.value = false;
  }
}

/* ------------------
   Title generator
------------------ */
async function generateTitle() {
  try {
    const messages = props.node.messages.slice(0, 3);
    const prompt = `Based on this conversation, suggest a concise and descriptive title (max 5 words):\n\n${messages
      .map((m) => `${m.role}: ${m.content}`)
      .join('\n')}`;

    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: props.selectedModel,
        prompt,
        system:
          'You are a helpful assistant. Respond only with the title - no explanations or additional text.',
        stream: false
      })
    });

    const data = await response.json();
    const generatedTitle = data.response.trim();
    emit('update-title', props.node.id, generatedTitle);
  } catch (error) {
    console.error('Error generating title:', error);
  }
}

/* ------------------
   Stop streaming
------------------ */
function stopStreaming() {
  if (abortController) {
    abortController.abort();
    store.setStreamingContent(props.node.id, null);
  }
}

/* ------------------
   Expand/collapse
------------------ */
const expandMessage = (index: number) => {
  const newSet = new Set(expandedMessages.value);
  if (newSet.has(index)) {
    newSet.delete(index);
  } else {
    newSet.add(index);
  }
  expandedMessages.value = newSet;
};

function getMessageStyles(index: number) {
  const isInherited =
    props.node.type === 'branch' &&
    props.node.branchMessageIndex !== null &&
    index <= props.node.branchMessageIndex;

  const baseColor = threadColor.value;
  const messageBackground = isInherited
    ? `linear-gradient(to right, ${baseColor}03, ${baseColor}08)`
    : `linear-gradient(to right, ${baseColor}08, ${baseColor}15)`;

  return {
    background: messageBackground,
    borderLeft: `4px ${isInherited ? 'dashed' : 'solid'} ${baseColor}`,
    borderRadius: '0.5rem',
    position: 'relative' as const,
    transition: 'box-shadow 0.3s ease',
    ...(isInherited && {
      boxShadow: `inset 0 0 0 1px ${baseColor}10`
    })
  };
}

onMounted(() => {
  if (!props.node.title) {
    isEditing.value = true;
  }
});

onBeforeUnmount(() => {
  isDraggable.value = false;
  if (fadeTimeout.value) {
    clearTimeout(fadeTimeout.value);
  }
});
</script>

<style scoped>
.branch-node {
  position: absolute;
  transition: transform 0.2s ease;
  user-select: none;
}

.draggable:active {
  cursor: grabbing;
}

.node-card {
  backdrop-filter: blur(8px);
  margin: 4px;
  transition: all 0.3s ease;
  position: relative;
}

.node-card:hover {
  box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1);
}

.selected .node-card {
  ring: 2px;
  ring-color: rgb(59 130 246);
}

/* Base streaming states */
.streaming .node-card::before,
.streaming .node-card::after {
  content: '';
  position: absolute;
  border-radius: inherit;
  background: linear-gradient(90deg,
      #ff1493 0%,
      #ff6347 15%,
      #ffd700 30%,
      #32cd32 45%,
      #4169e1 60%,
      #9400d3 75%,
      #ff1493 90%,
      #ff6347 100%);
  background-size: 200% 100%;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  animation: flowBorder 3s linear infinite;
  opacity: 0;
  transition: opacity 1s ease-in-out;
  z-index: 0;
}

.streaming .node-card::before {
  inset: -2px;
  /* Reduced from -4px */
  padding: 2px;
  /* Reduced from 4px */
  filter: blur(3px);
  /* Slightly reduced blur */
}

.streaming .node-card::after {
  inset: -1px;
  /* Reduced from -2px */
  padding: 1px;
  /* Reduced from 2px */
  filter: blur(1px);
  /* Reduced blur for sharper inner border */
}

/* Animation states */
.branch-node.active .node-card::before,
.branch-node.active .node-card::after {
  opacity: 1;
}

.branch-node.fading-out .node-card::before,
.branch-node.fading-out .node-card::after {
  opacity: 0;
}

@keyframes flowBorder {
  0% {
    background-position: 100% 0;
  }

  100% {
    background-position: -100% 0;
  }
}

/* Fix for child content rotation in streaming */
.streaming .node-card>* {
  position: relative;
  z-index: 1;
}

.model-badge {
  animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-container {
  position: relative;
  transition: all 0.2s ease-in-out;
}

.message-container:hover {
  transform: translateX(0);
}

.branch-button {
  transform: translateX(20px);
  opacity: 0;
  transition: all 0.2s ease-in-out;
}

.message-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: -12px;
  right: -12px;
  bottom: 0;
  z-index: -1;
}

/* Ensure branch buttons have enough hover area */
.message-container .absolute {
  padding: 0.5rem;
  margin: -0.5rem;
}

.message-container:hover .branch-button {
  transform: translateX(0);
  opacity: 1;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

.avatar-overlay {
  border-radius: 9999px;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}


.cluster-viz-container {
  transform-origin: bottom left;
}

.cluster-viz-minimized {
  cursor: pointer;
}

.cluster-viz-focused {
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.5);
}
</style>
=== END FILE: ./src/components/canvas/node/BranchNode.vue ===


=== START FILE: ./src/components/manager/TaskManager.vue ===
=== TYPE: vue ===

<script setup lang="ts">
import { ref, onMounted, computed, watch } from 'vue';
import { Plus, X, ChevronDown, ChevronUp, Trash2 } from 'lucide-vue-next';

interface Task {
  id: string;
  title: string;
  description: string;
  status: 'todo' | 'in-progress' | 'done';
  type: 'feature' | 'bug';
  dateCreated: string;
  dateUpdated: string;
}

const tasks = ref<Task[]>([]);
const showNewTaskForm = ref(false);
const newTask = ref({
  title: '',
  description: '',
  type: 'feature' as const
});
const expandedTaskId = ref<string | null>(null);
const filterStatus = ref<Task['status'] | 'all'>('all');
const filterType = ref<Task['type'] | 'all'>('all');

const addTask = () => {
  if (!newTask.value.title.trim()) return;
  
  const now = new Date().toISOString();
  tasks.value.unshift({
    id: crypto.randomUUID(),
    title: newTask.value.title,
    description: newTask.value.description,
    status: 'todo',
    type: newTask.value.type,
    dateCreated: now,
    dateUpdated: now
  });
  
  newTask.value = {
    title: '',
    description: '',
    type: 'feature'
  };
  showNewTaskForm.value = false;
};

const cancelNewTask = () => {
  newTask.value = {
    title: '',
    description: '',
    type: 'feature'
  };
  showNewTaskForm.value = false;
};

const deleteTask = (taskId: string) => {
  tasks.value = tasks.value.filter(task => task.id !== taskId);
  if (expandedTaskId.value === taskId) {
    expandedTaskId.value = null;
  }
};

const updateTaskStatus = (task: Task, status: Task['status']) => {
  task.status = status;
  task.dateUpdated = new Date().toISOString();
};

const toggleExpand = (taskId: string) => {
  expandedTaskId.value = expandedTaskId.value === taskId ? null : taskId;
};

const filteredTasks = computed(() => {
  return tasks.value.filter(task => {
    const statusMatch = filterStatus.value === 'all' || task.status === filterStatus.value;
    const typeMatch = filterType.value === 'all' || task.type === filterType.value;
    return statusMatch && typeMatch;
  });
});

const getStatusColor = (status: Task['status']) => {
  switch (status) {
    case 'todo': return 'bg-blue-500/10 text-blue-500';
    case 'in-progress': return 'bg-yellow-500/10 text-yellow-500';
    case 'done': return 'bg-green-500/10 text-green-500';
  }
};

onMounted(() => {
  const savedTasks = localStorage.getItem('projectTasks');
  if (savedTasks) tasks.value = JSON.parse(savedTasks);
});

watch(tasks, (newTasks) => {
  localStorage.setItem('projectTasks', JSON.stringify(newTasks));
}, { deep: true });
</script>

<template>
  <div class="space-y-6">
    <!-- Header with New Task Button -->
    <div class="flex justify-between items-center">
      <div class="flex gap-2 text-sm">
        <select v-model="filterStatus" class="select select-sm select-bordered">
          <option value="all">All Status</option>
          <option value="todo">Todo</option>
          <option value="in-progress">In Progress</option>
          <option value="done">Done</option>
        </select>
        <select v-model="filterType" class="select select-sm select-bordered">
          <option value="all">All Types</option>
          <option value="feature">Features</option>
          <option value="bug">Bugs</option>
        </select>
      </div>
      
      <button 
        v-if="!showNewTaskForm"
        class="btn btn-sm btn-primary"
        @click="showNewTaskForm = true"
      >
        <Plus class="w-4 h-4" />
        New Task
      </button>
    </div>

    <!-- New Task Form (Collapsible) -->
    <div 
      v-if="showNewTaskForm"
      class="border border-base-300 rounded-lg p-4 space-y-3 bg-base-200/50"
    >
      <div class="flex justify-between items-center">
        <h3 class="font-medium">Create New Task</h3>
        <button 
          class="btn btn-ghost btn-sm btn-square"
          @click="cancelNewTask"
        >
          <X class="w-4 h-4" />
        </button>
      </div>
      
      <input
        v-model="newTask.title"
        type="text"
        placeholder="Task title..."
        class="input input-sm input-bordered w-full"
        @keyup.enter="addTask"
      />
      
      <textarea
        v-model="newTask.description"
        placeholder="Description (optional)"
        class="textarea textarea-bordered textarea-sm w-full h-20 resize-none"
      />
      
      <div class="flex gap-2">
        <select v-model="newTask.type" class="select select-sm select-bordered flex-1">
          <option value="feature">Feature</option>
          <option value="bug">Bug</option>
        </select>
        <button 
          class="btn btn-sm btn-primary"
          @click="addTask"
        >
          Create Task
        </button>
      </div>
    </div>

    <!-- Tasks List -->
    <div class="space-y-2">
      <div 
        v-for="task in filteredTasks" 
        :key="task.id" 
        class="border border-base-300 rounded-lg overflow-hidden hover:border-base-content/20 transition-colors"
      >
        <!-- Task Header -->
        <div 
          class="flex items-center justify-between p-3 cursor-pointer"
          @click="toggleExpand(task.id)"
        >
          <div class="flex items-center gap-3 min-w-0">
            <span 
              class="px-2 py-0.5 rounded-full text-xs capitalize"
              :class="getStatusColor(task.status)"
            >
              {{ task.status }}
            </span>
            <span 
              class="px-2 py-0.5 rounded-full text-xs capitalize"
              :class="task.type === 'bug' ? 'bg-red-500/10 text-red-500' : 'bg-purple-500/10 text-purple-500'"
            >
              {{ task.type }}
            </span>
            <span class="truncate">{{ task.title }}</span>
          </div>
          <component 
            :is="expandedTaskId === task.id ? ChevronUp : ChevronDown" 
            class="w-4 h-4 opacity-50"
          />
        </div>
        
        <!-- Task Details -->
        <div 
          v-if="expandedTaskId === task.id"
          class="p-3 pt-0 space-y-3 text-sm"
        >
          <p class="text-base-content/70 whitespace-pre-wrap">
            {{ task.description || 'No description provided.' }}
          </p>
          
          <div class="flex items-center gap-2">
            <select 
              v-model="task.status" 
              class="select select-sm select-bordered"
              @change="updateTaskStatus(task, $event.target.value)"
            >
              <option value="todo">Todo</option>
              <option value="in-progress">In Progress</option>
              <option value="done">Done</option>
            </select>
            
            <button 
              class="btn btn-ghost btn-sm text-error"
              @click="deleteTask(task.id)"
              title="Delete task"
            >
              <Trash2 class="w-4 h-4" />
            </button>
            
            <div class="flex-1" />
            
            <div class="text-xs text-base-content/50">
              Updated {{ new Date(task.dateUpdated).toLocaleString() }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
=== END FILE: ./src/components/manager/TaskManager.vue ===


=== START FILE: ./src/components/logo/TangentLogo.vue ===
=== TYPE: vue ===

// TangentLogo.vue
<template>
  <div
    class="w-[180px] h-[36px] relative perspective-[1000px] rounded-lg overflow-hidden"
  >
    <div
      ref="gridRef"
      class="w-full h-full grid relative gap-0"
      :style="{
        gridTemplateColumns: `repeat(${COLS}, 1fr)`,
        gridTemplateRows: `repeat(${ROWS}, 1fr)`
      }"
    >
      <div
        v-for="(_, i) in cells"
        :key="i"
        class="relative transition-transform duration-1000 ease-in-out cell"
        :style="{
          transformStyle: 'preserve-3d',
          border: 'none',
          backgroundColor: 'transparent'
        }"
      >
        <div
          class="absolute w-full h-full overflow-hidden front"
          :style="{
            backfaceVisibility: 'hidden',
            backgroundColor: 'transparent'
          }"
        >
          <div
            class="w-[180px] h-[36px] relative"
            :style="{
              transform: `translate(${-(i % COLS) * (180 / COLS)}px, ${-Math.floor(i / COLS) * (36 / ROWS)}px)`
            }"
          >
            <LogoSVG />
          </div>
        </div>
        <div
          class="absolute w-full h-full overflow-hidden back"
          :style="{
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)',
            backgroundColor: 'transparent'
          }"
        >
          <div
            class="absolute w-[180px] h-[36px]"
            :style="{
              transform: `translate(${-(i % COLS) * (180 / COLS)}px, ${-Math.floor(i / COLS) * (36 / ROWS)}px)`
            }"
          >
            <div class="font-sans text-[24px] font-bold w-full h-full ps-4 flex items-center justify-center text-foreground">
              TANGENT
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import LogoSVG from './LogoSVG.vue';

const COLS = 15;
const ROWS = 5;
const cells = Array.from({ length: ROWS * COLS });

const isShowingFront = ref(true);
const gridRef = ref<HTMLDivElement | null>(null);

const flipCell = (cell: HTMLElement, delay: number) => {
  setTimeout(() => {
    if (cell) {
      cell.style.transform = isShowingFront.value ? 'rotateY(180deg)' : 'rotateY(0deg)';
    }
  }, delay);
};

const animateFlip = () => {
  if (!gridRef.value) return;
  const cells = Array.from(gridRef.value.querySelectorAll('.cell'));

  // Organize cells into columns
  const columns: HTMLElement[][] = Array.from({ length: COLS }, () => []);
  cells.forEach((cell, index) => {
    const col = index % COLS;
    columns[col].push(cell as HTMLElement);
  });

  const delayBetweenColumns = 50;
  const middle = Math.floor(COLS / 2);
  let columnOrder = [middle];
  
  for (let offset = 1; offset <= middle; offset++) {
    if (middle - offset >= 0) columnOrder.push(middle - offset);
    if (middle + offset < COLS) columnOrder.push(middle + offset);
  }

  if (!isShowingFront.value) {
    columnOrder = columnOrder.reverse();
  }

  columnOrder.forEach((colIndex, index) => {
    setTimeout(() => {
      columns[colIndex].forEach((cell) => {
        flipCell(cell, 0);
      });
    }, index * delayBetweenColumns);
  });

  setTimeout(() => {
    isShowingFront.value = !isShowingFront.value;
  }, columnOrder.length * delayBetweenColumns + 500);
};

let intervalId: number;

onMounted(() => {
  intervalId = window.setInterval(animateFlip, 5000);
});

onBeforeUnmount(() => {
  clearInterval(intervalId);
});
</script>
=== END FILE: ./src/components/logo/TangentLogo.vue ===


=== START FILE: ./src/components/logo/LogoSVG.vue ===
=== TYPE: vue ===

// LogoSVG.vue
<template>
  <svg viewBox="0 0 200 45" class="absolute inset-0">
    <!-- Dynamic wave patterns -->
    <path
      d="M 20 22.5 C 40 22.5, 45 12, 65 12 S 90 33, 110 33 S 135 12, 155 12 S 180 22.5, 200 22.5"
      fill="none"
      class="stroke-foreground dark:stroke-foreground"
      stroke-width="1"
    />

    <!-- Fractal-like pattern -->
    <path
      d="M 100 22.5 C 105 22.5, 110 18, 120 18 S 135 27, 145 27 S 155 18, 165 18"
      fill="none"
      class="stroke-cyan-500 dark:stroke-cyan-400"
      stroke-width="1"
    />
    <path
      d="M 100 22.5 C 95 22.5, 90 27, 80 27 S 65 18, 55 18 S 45 27, 35 27"
      fill="none"
      class="stroke-rose-500 dark:stroke-rose-400"
      stroke-width="1"
    />

    <!-- Geometric accents -->
    <path
      v-for="i in 8"
      :key="`right-${i}`"
      :d="`M ${100 + i * 10} 22.5 L ${105 + i * 10} 15 L ${110 + i * 10} 22.5`"
      fill="none"
      class="stroke-emerald-500/30 dark:stroke-emerald-400/30"
      stroke-width="0.5"
    />
    <path
      v-for="i in 8"
      :key="`left-${i}`"
      :d="`M ${100 - i * 10} 22.5 L ${95 - i * 10} 30 L ${90 - i * 10} 22.5`"
      fill="none"
      class="stroke-purple-500/30 dark:stroke-purple-400/30"
      stroke-width="0.5"
    />

    <!-- Dynamic circles -->
    <circle
      v-for="i in 5"
      :key="`right-circle-${i}`"
      :cx="100 + i * 20"
      :cy="22.5 + Math.sin(i * 1.5) * 5"
      :r="1.2 - i * 0.15"
      class="fill-cyan-500 dark:fill-cyan-400"
    />
    <circle
      v-for="i in 5"
      :key="`left-circle-${i}`"
      :cx="100 - i * 20"
      :cy="22.5 + Math.cos(i * 1.5) * 5"
      :r="1.2 - i * 0.15"
      class="fill-rose-500 dark:fill-rose-400"
    />

    <!-- Central focal point -->
    <path
      d="M 95 22.5 L 105 22.5 M 100 17.5 L 100 27.5"
      class="stroke-foreground dark:stroke-foreground"
      stroke-width="1.5"
    />
    <circle
      cx="100"
      cy="22.5"
      r="2.5"
      class="fill-foreground dark:fill-foreground"
    />

    <!-- Abstract mathematical symbols -->
    <path
      d="M 160 15 A 5 5 0 0 1 170 15 A 5 5 0 0 1 160 15"
      fill="none"
      class="stroke-emerald-500/50 dark:stroke-emerald-400/50"
      stroke-width="0.75"
    />
    <path
      d="M 30 30 A 5 5 0 0 0 40 30 A 5 5 0 0 0 30 30"
      fill="none"
      class="stroke-purple-500/50 dark:stroke-purple-400/50"
      stroke-width="0.75"
    />
  </svg>
</template>
=== END FILE: ./src/components/logo/LogoSVG.vue ===


=== START FILE: ./src/components/theme/ThemeToggle.vue ===
=== TYPE: vue ===

<template>
  <div class="relative inline-block">
    <!-- Theme Dropdown -->
    <div class="relative">
      <button @click="isOpen = !isOpen"
        class="flex items-center gap-2 px-3 py-2 rounded-lg bg-background/80 backdrop-blur border shadow-sm hover:bg-muted/80 transition-all duration-200">
        <div class="flex items-center gap-2">
          <div class="flex -space-x-1">
            <div class="w-4 h-4 rounded-full border-2 border-background shadow-sm"
              :style="{ backgroundColor: getThemeColors(currentTheme).primary }" />
            <div class="w-4 h-4 rounded-full border-2 border-background shadow-sm"
              :style="{ backgroundColor: getThemeColors(currentTheme).secondary }" />
          </div>
          <span class="text-sm font-medium">{{ currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1) }}</span>
        </div>
        <ChevronDown class="w-4 h-4 transition-transform duration-200" :class="{ 'rotate-180': isOpen }" />
      </button>

      <!-- Dropdown Menu -->
      <div v-if="isOpen"
        class="absolute left-0 mt-2 w-64 max-h-[60vh] overflow-y-auto rounded-lg border bg-background/95 backdrop-blur shadow-lg z-[100]">
        <div class="p-2" @click.stop>
          <input v-model="search" type="text" placeholder="Search themes..."
            class="w-full px-3 py-2 text-sm rounded-md bg-muted/50 border-0 focus:ring-1 focus:ring-primary" />
        </div>

        <div class="py-1">
          <button v-for="theme in filteredThemes" :key="theme" @click="selectTheme(theme)"
            class="w-full px-3 py-2 flex items-center gap-3 hover:bg-muted/50 transition-colors group"
            :class="{ 'bg-primary/5': theme === currentTheme }">
            <!-- Theme Preview -->
            <div class="flex items-center gap-1.5">
              <div class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200"
                :style="{ backgroundColor: getThemeColors(theme).primary }" />
              <div class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200"
                :style="{ backgroundColor: getThemeColors(theme).secondary }" />
              <div class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200"
                :style="{ backgroundColor: getThemeColors(theme).accent }" />
            </div>

            <span class="text-sm">{{ theme.charAt(0).toUpperCase() + theme.slice(1) }}</span>

            <Check v-if="theme === currentTheme" class="w-4 h-4 ml-auto text-primary" />
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { ChevronDown, Check } from 'lucide-vue-next';

type ThemeColors = {
  primary: string;
  secondary: string;
  accent: string;
};

type ThemeName =
  | "light" | "dark" | "cupcake" | "bumblebee" | "emerald" | "corporate"
  | "synthwave" | "retro" | "cyberpunk" | "valentine" | "halloween" | "garden"
  | "forest" | "aqua" | "lofi" | "pastel" | "fantasy" | "wireframe" | "black"
  | "luxury" | "dracula" | "cmyk" | "autumn" | "business" | "acid" | "lemonade"
  | "night" | "coffee" | "winter";

type ThemeColorMap = {
  [K in ThemeName]: ThemeColors;
};

const themes: ThemeName[] = [
  "light", "dark", "cupcake", "bumblebee", "emerald", "corporate",
  "synthwave", "retro", "cyberpunk", "valentine", "halloween",
  "garden", "forest", "aqua", "lofi", "pastel", "fantasy",
  "wireframe", "black", "luxury", "dracula", "cmyk", "autumn",
  "business", "acid", "lemonade", "night", "coffee", "winter"
];

const themeColors: ThemeColorMap = {
  // Light themes
  light: { primary: '#570DF8', secondary: '#F000B8', accent: '#37CDBE' },
  cupcake: { primary: '#65C3C8', secondary: '#EF9FBC', accent: '#EEAF3A' },
  bumblebee: { primary: '#F9D72F', secondary: '#E0A82E', accent: '#181830' },
  emerald: { primary: '#66CC8A', secondary: '#377CFB', accent: '#EA5234' },
  corporate: { primary: '#4B6BFB', secondary: '#7B92B2', accent: '#EA5234' },
  garden: { primary: '#5c7f67', secondary: '#be123c', accent: '#9CA384' },
  lofi: { primary: '#0D0D0D', secondary: '#1A1919', accent: '#4A4A4A' },
  pastel: { primary: '#d1c1d7', secondary: '#f6cbd1', accent: '#b4e9d6' },
  fantasy: { primary: '#6D0A0A', secondary: '#A65D03', accent: '#2D5A27' },
  wireframe: { primary: '#B8B8B8', secondary: '#CDCDCD', accent: '#DEDEDE' },
  lemonade: { primary: '#519903', secondary: '#E9E92E', accent: '#94CE58' },

  // Dark themes
  dark: { primary: '#793EF9', secondary: '#F471B5', accent: '#1FB2A5' },
  synthwave: { primary: '#E779C1', secondary: '#58C7F3', accent: '#F3CC30' },
  retro: { primary: '#EF9995', secondary: '#2CB67D', accent: '#7D5BA6' },
  cyberpunk: { primary: '#FF7598', secondary: '#75D1F0', accent: '#F7D51D' },
  valentine: { primary: '#E96D7B', secondary: '#A12E45', accent: '#F0AFC0' },
  halloween: { primary: '#F28C18', secondary: '#6B21A8', accent: '#37CDBE' },
  forest: { primary: '#1EB854', secondary: '#1DB88E', accent: '#1EA885' },
  aqua: { primary: '#09ECF3', secondary: '#0771DE', accent: '#07ABE3' },
  black: { primary: '#333333', secondary: '#666666', accent: '#999999' },
  luxury: { primary: '#DAA520', secondary: '#B8860B', accent: '#FFD700' },
  dracula: { primary: '#FF79C6', secondary: '#BD93F9', accent: '#50FA7B' },
  cmyk: { primary: '#00BCD4', secondary: '#FF4081', accent: '#FFEB3B' },
  autumn: { primary: '#8B4513', secondary: '#A0522D', accent: '#CD853F' },
  business: { primary: '#1C4E80', secondary: '#7C909A', accent: '#A6B0B5' },
  acid: { primary: '#FF00FF', secondary: '#00FF00', accent: '#FFFF00' },
  night: { primary: '#38BDF8', secondary: '#818CF8', accent: '#C084FC' },
  coffee: { primary: '#6F4E37', secondary: '#C6A880', accent: '#DAC3B3' },
  winter: { primary: '#0EA5E9', secondary: '#84CC16', accent: '#10B981' }
};

const isOpen = ref(false);
const search = ref('');
const currentTheme = ref<ThemeName>(
  (localStorage.getItem('theme') as ThemeName) || 'light'
);

const getThemeColors = (theme: ThemeName): ThemeColors => {
  return themeColors[theme];
};

const filteredThemes = computed(() => {
  const searchTerm = search.value.toLowerCase();
  return themes.filter(theme =>
    theme.toLowerCase().includes(searchTerm)
  );
});

const selectTheme = (theme: ThemeName) => {
  currentTheme.value = theme;
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('theme', theme);
  isOpen.value = false;
};

onMounted(() => {
  const savedTheme = localStorage.getItem('theme') as ThemeName || 'light';
  currentTheme.value = savedTheme;
  document.documentElement.setAttribute('data-theme', savedTheme);
});
</script>

<style scoped>
div::-webkit-scrollbar {
  width: 6px;
}

div::-webkit-scrollbar-track {
  background: transparent;
}

div::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.dark div::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.2);
}
</style>
=== END FILE: ./src/components/theme/ThemeToggle.vue ===


=== START FILE: ./src/vite-env.d.ts ===
=== TYPE: ts ===

/// <reference types="vite/client" />

=== END FILE: ./src/vite-env.d.ts ===


=== START FILE: ./src/router/index.ts ===
=== TYPE: ts ===

import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'
import InfiniteCanvas from '../components/canvas/InfiniteCanvas.vue'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: InfiniteCanvas
  },
  {
    path: '/canvas/:id',
    name: 'SpecificCanvas',
    component: InfiniteCanvas,
    props: true
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router
=== END FILE: ./src/router/index.ts ===


