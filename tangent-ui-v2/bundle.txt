=== START FILE: ./vite.config.ts ===
=== TYPE: ts ===

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
  optimizeDeps: {
    esbuildOptions: {
      target: 'esnext'
    }
  },
  build: {
    target: 'esnext',
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          'ui-vendor': ['@headlessui/vue', '@heroicons/vue', 'lucide-vue-next'],
          'highlight': ['highlight.js'],
          'prism': ['prismjs'],
          'marked': ['marked'],
          'dompurify': ['dompurify'],
          'monaco': ['@monaco-editor/loader']
        }
      }
    }
  }
})
=== END FILE: ./vite.config.ts ===


=== START FILE: ./src/App.vue ===
=== TYPE: vue ===

<template>
  <div class="min-h-screen bg-background">
    <!-- Logo Container -->
    <div
      class="fixed top-4 z-50 transition-all duration-300 w-[180px]"
      :style="{
        left: isSidePanelOpen ? 'calc(40vw + (60vw - 180px) / 2)' : 'calc(50vw - 90px)'
      }"
    >
      <TangentLogo />
    </div>

    <!-- Side Panel -->
    <div
      class="fixed left-0 top-0 h-full w-[40vw] bg-background shadow-lg transform transition-transform duration-300 z-40 border-r border-base-300"
      :class="isSidePanelOpen ? 'translate-x-0' : '-translate-x-full'"
    >
      <div class="h-full pt-2 px-4 pb-4 bg-background">
        <TopicClusterViz />
      </div>
    </div>

    <!-- Toggle Button -->
    <button
      @click="toggleSidePanel"
      class="fixed left-0 top-1/2 -translate-y-1/2 z-50 p-2 bg-background border border-l-0 border-base-300 rounded-r-md hover:bg-base-200 transition-all duration-300 shadow-md"
      :class="{ 'translate-x-[40vw]': isSidePanelOpen }"
    >
      <ChevronRight class="w-5 h-5 transition-transform" :class="{ 'rotate-180': isSidePanelOpen }" />
    </button>

    <!-- Top Controls Container -->
    <div
      class="fixed z-50 transition-all duration-300 flex justify-between"
      :style="{
        left: isSidePanelOpen ? '40vw' : '0',
        right: '0'
      }"
    >
      <!-- Left Controls Group -->
      <div class="flex items-center px-4">
        <div class="flex items-center gap-4">
          <WorkspaceMenu />

          <!-- Canvas Controls -->
          <div class="flex items-center">
            <ThemeToggle />
            <div class="px-3 bg-base-200/90 backdrop-blur text-sm rounded-full border border-base-300">
              {{ Math.round(canvasZoom * 100) }}%
            </div>
            <button
              class="px-3 bg-base-200/90 backdrop-blur rounded-full border border-base-300 hover:bg-base-300/90"
              @click="toggleAutoZoom"
            >
              <span class="text-sm">{{ canvasAutoZoom ? 'Auto-fit On' : 'Auto-fit Off' }}</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Right Controls Group -->
      <div class="flex items-center gap-2 p-4 mr-4">
        <button @click="openSettings" class="btn btn-sm btn-ghost">
          <Settings class="w-4 h-4" />
        </button>
        <ModelSelector :api-key="openRouterApiKey" :selected-model="selectedModel" @select="handleModelSelect" />
      </div>
    </div>

    <!-- Canvas Container -->
    <InfiniteCanvas
      ref="canvasRef"
      :selected-model="selectedModel?.id || ''"
      :open-router-api-key="openRouterApiKey"
      :model-type="modelType"
      :side-panel-open="isSidePanelOpen"
      :zoom="canvasZoom"
      v-model:zoom="canvasZoom"
      v-model:auto-zoom-enabled="canvasAutoZoom"
    />

    <!-- "Back to Workspaces" Button -->
    <button
      v-if="showBackButton"
      class="fixed bottom-4 left-4 z-50 btn btn-sm btn-ghost gap-2"
      @click="handleReturnToOverview"
    >
      <ArrowLeft class="w-4 h-4" />
      Back to Workspaces
    </button>

    <!-- Workspace Overview Title -->
    <!-- We use showOverviewTitle to avoid reading .value on null -->
    <div
      class="fixed bottom-4 z-50 w-full text-center transition-all duration-300"
      :style="{ left: isSidePanelOpen ? '40vw' : '0', right: '0' }"
    >
      <div
        v-if="showOverviewTitle"
        class="inline-block px-4 py-2 bg-base-200/90 backdrop-blur rounded-full border border-base-300 text-lg font-semibold"
      >
        Your Workspaces
      </div>
    </div>

    <!-- Settings Modal -->
    <dialog ref="settingsDialog" class="modal">
      <div class="modal-box max-w-lg">
        <div class="flex items-center space-x-2 mb-4">
          <button class="btn btn-sm" :class="{ 'btn-active': activeTab === 'api' }" @click="activeTab = 'api'">
            API Settings
          </button>
          <button class="btn btn-sm" :class="{ 'btn-active': activeTab === 'tasks' }" @click="activeTab = 'tasks'">
            Tasks
          </button>
        </div>

        <div v-if="activeTab === 'api'" class="space-y-4">
          <div class="form-control">
            <label class="label">
              <span class="label-text">OpenRouter API Key</span>
            </label>
            <input
              v-model="openRouterApiKey"
              type="password"
              placeholder="sk-or-..."
              class="input input-bordered w-full"
            />

            <label class="label mt-2">
              <span class="label-text">Gemini API Key</span>
            </label>
            <input
              v-model="geminiApiKey"
              type="password"
              placeholder="AIza..."
              class="input input-bordered w-full"
            />

            <label class="label mt-2">
              <span class="label-text">Custom API URL</span>
            </label>
            <input
              v-model="customApiUrl"
              type="url"
              placeholder="http://localhost:8080/v1/chat/completions"
              class="input input-bordered w-full"
            />
          </div>
        </div>

        <div v-else-if="activeTab === 'tasks'">
          <TaskManager />
        </div>

        <div class="modal-action">
          <button class="btn" @click="closeSettings">Close</button>
        </div>
      </div>
    </dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue';
import { ArrowLeft, Settings, ChevronRight } from 'lucide-vue-next';

import InfiniteCanvas from './components/canvas/InfiniteCanvas.vue';
import ThemeToggle from './components/theme/ThemeToggle.vue';
import TangentLogo from './components/logo/TangentLogo.vue';
import ModelSelector from './components/models/ModelSelector.vue';
import TaskManager from './components/manager/TaskManager.vue';
import WorkspaceMenu from './components/workspace/WorkspaceMenu.vue';
import TopicClusterViz from './components/canvas/clustermap/TopicClusterViz.vue';
import type { Model } from './stores/modelStore';

import { useCanvasStore } from './stores/canvasStore';
import { useModelStore } from './stores/modelStore';
import { useChatStore } from './stores/chatStore';


// Refs and reactive state
const canvasRef = ref<InstanceType<typeof InfiniteCanvas> | null>(null);
const canvasZoom = ref(1);
const canvasAutoZoom = ref(true);

const canvasStore = useCanvasStore();
const modelStore = useModelStore();
const chatStore = useChatStore();

// Called once the component is mounted
onMounted(() => {
  canvasStore.initFromLocalStorage();
  chatStore.loadChats();
});

// Model selection
const selectedModel = ref<Model | null>(
  localStorage.getItem('selectedModel')
    ? JSON.parse(localStorage.getItem('selectedModel')!)
    : null
);
const modelType = ref<string>(localStorage.getItem('modelType') || '');
const openRouterApiKey = ref(localStorage.getItem('openRouterApiKey') || '');
const geminiApiKey = ref(localStorage.getItem('geminiApiKey') || '');
const customApiUrl = ref<string | null>(localStorage.getItem('customApiUrl') || null);
const activeTab = ref<'api' | 'tasks'>('api');
const isSidePanelOpen = ref(false);

// --- Computed to show/hide "Back to Workspaces" button safely ---
const showBackButton = computed(() => {
  return canvasRef.value && !canvasRef.value.isWorkspaceOverview;
});

// --- Computed to show/hide "Your Workspaces" title safely ---
const showOverviewTitle = computed(() => {
  return canvasRef.value && canvasRef.value.isWorkspaceOverview;
});

// Methods
const toggleSidePanel = () => {
  isSidePanelOpen.value = !isSidePanelOpen.value;
  setTimeout(() => {
    canvasRef.value?.autoFitNodes();
  }, 300);
};

function handleReturnToOverview() {
  // Safely call the child's method
  canvasRef.value?.returnToOverview();
}

const toggleAutoZoom = () => {
  canvasAutoZoom.value = !canvasAutoZoom.value;
  if (canvasAutoZoom.value) {
    canvasRef.value?.autoFitNodes();
  }
};

const handleModelSelect = (model: Model) => {
  selectedModel.value = model;
  modelType.value = model.source;
  localStorage.setItem('selectedModel', JSON.stringify(model));
  localStorage.setItem('modelType', model.source);
};

const openSettings = () => {
  settingsDialog.value?.showModal();
};

const closeSettings = () => {
  settingsDialog.value?.close();
  if (openRouterApiKey.value) {
    localStorage.setItem('openRouterApiKey', openRouterApiKey.value);
  }
  if (geminiApiKey.value) {
    localStorage.setItem('geminiApiKey', geminiApiKey.value);
    modelStore.initialize();
  }
};

const settingsDialog = ref<HTMLDialogElement | null>(null);
</script>

<style scoped>
.modal {
  background: rgba(0, 0, 0, 0.5);
  z-index: 100;
}

.side-panel {
  isolation: isolate;
}

/* Smooth transitions */
.btn {
  transition: all 0.2s ease;
}

.btn-ghost {
  @apply hover:bg-base-200/90;
}
</style>

=== END FILE: ./src/App.vue ===


=== START FILE: ./src/types/chat.ts ===
=== TYPE: ts ===

// src/types/chat.ts
export interface ChatSummary {
    id: string;
    title: string;
    createdAt: string;
    updatedAt: string;
    nodeCount: number;
  }
  
  export interface ChatData {
    id: string;
    title: string;
    createdAt: string;
    updatedAt: string;
    nodes: Node;
  }
=== END FILE: ./src/types/chat.ts ===


=== START FILE: ./src/types/message.ts ===
=== TYPE: ts ===

// types/message.ts
export interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  isStreaming?: boolean;
  modelId?: string;
}

export interface ContentPart {
  type: 'text' | 'code';
  content: string;
  language?: string;
  complete?: boolean;
}

export interface Node {
  id: string;
  x: number;
  y: number;
  title?: string;
  parentId: string | null;
  messages: Message[];
  type: 'main' | 'branch';
  branchMessageIndex: number | null;
  streamingContent?: string | null;
}
=== END FILE: ./src/types/message.ts ===


=== START FILE: ./src/types/vue-shims.d.ts ===
=== TYPE: ts ===

// src/types/vue-shims.d.ts
declare module '*.vue' {
    import type { DefineComponent } from 'vue';
    const component: DefineComponent<{}, {}, any>;
    export default component;
}
=== END FILE: ./src/types/vue-shims.d.ts ===


=== START FILE: ./src/main.ts ===
=== TYPE: ts ===

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import 'highlight.js/styles/github-dark.css';
import router from './router'
import App from './App.vue'
import './assets/main.css'

const app = createApp(App)
app.use(createPinia())
app.use(router)
app.mount('#app')

=== END FILE: ./src/main.ts ===


=== START FILE: ./src/stores/canvasStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { useChatStore } from './chatStore';
import { ref, watch, computed } from 'vue';
import type { Message, Node } from '../types/message';

// Helper types for model info
type ModelSource = 'ollama' | 'openrouter' | 'custom';
interface ModelInfo {
  id: string;
  name: string;
  source: ModelSource;
  provider?: string;
}

interface LocalStorageState {
  nodes: Node[];
  lastSavedWorkspaceId: string | null;
}


export const useCanvasStore = defineStore('canvas', () => {
  const chatStore = useChatStore();
  const lastSavedWorkspaceId = ref<string | null>(null);


  const initFromLocalStorage = () => {
    const savedState = localStorage.getItem('canvasState');
    if (savedState) {
      const state = JSON.parse(savedState) as LocalStorageState;
      nodes.value = state.nodes;
      lastSavedWorkspaceId.value = state.lastSavedWorkspaceId;
    }
  };


  // Main state
  const nodes = ref<Node[]>([{
    id: '1',
    x: 100,
    y: 100,
    title: 'Root Thread',
    parentId: null,
    messages: [],
    type: 'main',
    branchMessageIndex: null,
    streamingContent: null
  }]);

  // UI state
  const activeNode = ref<string | null>(null);
  const isDragging = ref(false);
  const dragOffset = ref({ x: 0, y: 0 });
  const viewMode = ref<'2d' | '3d'>('2d');
  const isTransitioning = ref(false);
  const customApiUrl = ref<string | null>(localStorage.getItem('customApiUrl') || null);

  // Constants
  const CARD_WIDTH = 672;
  const CARD_HEIGHT = 80;
  const HORIZONTAL_SPACING = 100;

  // Topic clustering state
  const topicClusters = ref(new Map());
  const nodeTopics = ref(new Map());

  // Helper function to process SSE lines
  const processSSELine = (line: string, source: ModelSource) => {
    // Skip empty lines and known control messages
    if (!line || line === 'data: [DONE]' || line === '[DONE]' ||
      (source === 'openrouter' && line.startsWith(': OPENROUTER PROCESSING'))) {
      return null;
    }

    // Remove 'data: ' prefix and handle different formats
    const jsonData = line.startsWith('data: ') ? line.slice(5) : line;

    try {
      const data = JSON.parse(jsonData);

      // Handle different provider response structures
      switch (source) {
        case 'openrouter':
          return data.choices?.[0]?.delta?.content || '';
        case 'ollama':
          // Ollama's response structure uses 'message' field
          return data.message?.content || data.content || '';
        case 'custom':
          // Handle custom API formats
          return data.content || data.response || data.output || '';
        default:
          return data.content || '';
      }
    } catch (e) {
      // Only log actual parsing errors for non-control messages
      if (!line.includes('[DONE]') && !line.includes('OPENROUTER PROCESSING')) {
        console.error(`Error parsing ${source} response:`, e, line);
      }
      return null;
    }
  };

  // Helper function to handle streaming responses
  const handleStreamingResponse = async (
    reader: ReadableStreamDefaultReader<Uint8Array>,
    nodeId: string,
    modelSource: ModelSource
  ) => {
    let buffer = '';
    let accumulatedContent = '';
    const decoder = new TextDecoder();

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          const content = processSSELine(line, modelSource);
          if (content !== null) { // Explicit null check
            accumulatedContent += content;
            setStreamingContent(nodeId, accumulatedContent);
          }
        }
      }

      // Process any remaining buffer content
      if (buffer) {
        const content = processSSELine(buffer, modelSource);
        if (content !== null) {
          accumulatedContent += content;
          setStreamingContent(nodeId, accumulatedContent);
        }
      }

      return accumulatedContent;
    } catch (error) {
      console.error('Error in streaming response:', error);
      throw error;
    }
  };


  // Computed properties for 3D view
  const graphData = computed(() => {
    const clusters = Array.from(topicClusters.value.entries()).map(([topicId, nodeSet]) => ({
      id: `cluster-${topicId}`,
      type: 'cluster',
      nodes: Array.from(nodeSet),
      size: nodeSet.size
    }));

    const graphNodes = nodes.value.map(node => ({
      id: node.id,
      title: node.title || 'Untitled Thread',
      clusterId: nodeTopics.value.get(node.id),
      messageCount: node.messages?.length || 0,
      lastActive: node.messages?.[node.messages.length - 1]?.timestamp || '',
      branchPoint: node.branchMessageIndex
    }));

    const links = connections.value.map(conn => ({
      source: conn.parent?.id || '',
      target: conn.child.id,
      branchPoint: nodes.value.find(n => n.id === conn.child.id)?.branchMessageIndex
    }));

    return {
      nodes: [...graphNodes, ...clusters],
      links
    };
  });

  // Connections computed property
  const connections = computed(() => {
    return nodes.value
      .filter(node => node.parentId)
      .map(node => {
        const parent = nodes.value.find(n => n.id === node.parentId);
        return { parent, child: node };
      });
  });

  const parseModelInfo = (selectedModel: string): ModelInfo => {
    if (selectedModel.includes('/')) {
      const [provider, name] = selectedModel.split('/');
      return {
        id: selectedModel,
        name,
        source: 'openrouter',
        provider
      };
    } else if (customApiUrl.value) {
      return {
        id: selectedModel,
        name: selectedModel,
        source: 'custom'
      };
    } else {
      return {
        id: selectedModel,
        name: selectedModel,
        source: 'ollama'
      };
    }
  };

  const sendMessage = async (
    nodeId: string,
    message: string,
    selectedModel: string,
    openRouterApiKey: string,
    addUserMessage = true
  ) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (!node) return;

    const systemPrompt = `
      You are a helpful AI assistant who can engage in natural conversation while also helping with code. 
      When sharing code examples, always format them in markdown using fenced blocks with the appropriate language.
    `;

    try {
      const modelInfo = parseModelInfo(selectedModel);

      if (addUserMessage) {
        const userMessage: Message = {
          role: 'user',
          content: message,
          timestamp: new Date().toISOString(),
          isStreaming: false
        };
        addMessage(nodeId, userMessage);
      }

      const messageContext = node.messages.map(msg => ({
        role: msg.role,
        content: msg.content
      }));

      const { endpoint, headers, requestBody } = prepareRequest(
        modelInfo,
        messageContext,
        systemPrompt,
        openRouterApiKey
      );

      const response = await fetch(endpoint, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await getErrorText(response);
        throw new Error(errorText);
      }

      const reader = response.body?.getReader();
      if (!reader) throw new Error('Response body is null');

      const accumulatedContent = await handleStreamingResponse(reader, nodeId, modelInfo.source);

      // Store final message
      const assistantMessage: Message = {
        role: 'assistant',
        content: accumulatedContent,
        timestamp: new Date().toISOString(),
        modelId: modelInfo.id,
        isStreaming: false
      };
      addMessage(nodeId, assistantMessage);
      setStreamingContent(nodeId, null);

      return true;
    } catch (error) {
      console.error('Error sending message:', error);
      setStreamingContent(nodeId, null);
      return false;
    }
  };

  const prepareRequest = (
    modelInfo: ModelInfo,
    messageContext: Array<{ role: string; content: string }>,
    systemPrompt: string,
    openRouterApiKey: string
  ) => {
    let endpoint = 'http://localhost:11434/api/chat';
    let headers: HeadersInit = {
      'Content-Type': 'application/json'
    };

    if (modelInfo.source === 'openrouter') {
      endpoint = 'https://openrouter.ai/api/v1/chat/completions';
      headers = {
        ...headers,
        'Authorization': `Bearer ${openRouterApiKey}`,
        'HTTP-Referer': window.location.origin,
        'X-Title': 'Tangent Chat'
      };
    } else if (modelInfo.source === 'custom' && customApiUrl.value) {
      endpoint = customApiUrl.value;
    }

    const requestBody = modelInfo.source === 'custom' && customApiUrl.value
      ? {
        prompt: `${messageContext.map(m => `${m.role}: ${m.content}`).join('\n')}`,
        stream: true,
        model: modelInfo.id
      }
      : {
        model: modelInfo.id,
        messages: [
          { role: 'system', content: systemPrompt },
          ...messageContext
        ],
        stream: true
      };

    return { endpoint, headers, requestBody };
  };

  const getErrorText = async (response: Response) => {
    let errorText = `API error: ${response.status}`;
    try {
      const errorData = await response.json();
      errorText += ` - ${JSON.stringify(errorData)}`;
    } catch (e) {
      console.error('Could not parse error body', e);
    }
    return errorText;
  };

  // Node management functions
  const addNode = async (
    parentId: string | null,
    branchMessageIndex: number,
    position: { x: number, y: number },
    initialData = {}
  ) => {
    const newId = (Math.max(...nodes.value.map(n => parseInt(n.id))) + 1).toString();
    const parentNode = nodes.value.find(n => n.id === parentId);
    const existingChildren = nodes.value.filter(n => n.parentId === parentId).length;

    const parentMessages = parentNode?.messages || [];
    const contextMessages = parentMessages.slice(0, branchMessageIndex + 1).map(msg => ({
      ...msg,
      timestamp: new Date().toISOString()
    }));

    const newNode: Node = {
      id: newId,
      x: position.x,
      y: position.y + (existingChildren * (CARD_HEIGHT + 20)),
      parentId,
      messages: contextMessages,
      type: 'branch',
      branchMessageIndex,
      streamingContent: null,
      ...initialData
    };

    // Add to local state
    nodes.value.push(newNode);

    // Auto-save if in a chat
    if (chatStore.currentChatId) {
      const nodeId = await chatStore.addNode(chatStore.currentChatId, {
        ...newNode,
        metadata: {
          type: newNode.type,
          url: (newNode as any).url,
          mediaType: (newNode as any).mediaType
        }
      });
      if (nodeId) {
        newNode.id = nodeId;
        // Auto-save the parent node's state as well
        if (parentId) {
          const parentNode = nodes.value.find(n => n.id === parentId);
          if (parentNode) {
            chatStore.autoSave(chatStore.currentChatId, parentId, {
              children: [...(parentNode.children || []), nodeId]
            });
          }
        }
      }
    }

    return newNode;
  };

  const addMessage = async (nodeId: string, message: string | Message) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node) {
      const newMessage: Message = typeof message === 'string'
        ? {
          role: 'assistant',
          content: message,
          timestamp: new Date().toISOString(),
          isStreaming: false
        }
        : {
          ...message,
          role: message.role as 'user' | 'assistant',
          isStreaming: message.isStreaming ?? false
        };

      node.messages = [...(node.messages || []), newMessage];

      // Auto-save messages
      if (chatStore.currentChatId) {
        chatStore.autoSave(chatStore.currentChatId, nodeId, {
          messages: node.messages
        });
      }
    }
  };

  const removeMessage = async (nodeId: string, messageIndex: number) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node && node.messages) {
      node.messages = [
        ...node.messages.slice(0, messageIndex),
        ...node.messages.slice(messageIndex + 1)
      ];

      const childNodes = nodes.value.filter(n => n.parentId === nodeId);
      childNodes.forEach(childNode => {
        if (childNode.branchMessageIndex && childNode.branchMessageIndex >= messageIndex) {
          childNode.branchMessageIndex--;
        }
      });

      // Persist changes if in a chat
      if (chatStore.currentChatId) {
        await chatStore.updateNode(chatStore.currentChatId, nodeId, {
          messages: node.messages
        });

        // Update child nodes if branch indices changed
        for (const childNode of childNodes) {
          if (childNode.branchMessageIndex !== undefined) {
            await chatStore.updateNode(chatStore.currentChatId, childNode.id, {
              branchMessageIndex: childNode.branchMessageIndex
            });
          }
        }
      }
    }
  };


  const updateNodePosition = async (id: string, position: { x: number, y: number }) => {
    const node = nodes.value.find(n => n.id === id);
    if (node) {
      node.x = position.x;
      node.y = position.y;

      // Auto-save position if in a chat
      if (chatStore.currentChatId) {
        chatStore.autoSave(chatStore.currentChatId, id, { x: position.x, y: position.y });
      }
    }
  };

  const removeNode = async (id: string) => {
    // Remove from topics if present
    const topicId = nodeTopics.value.get(id);
    if (topicId !== undefined) {
      const cluster = topicClusters.value.get(topicId);
      if (cluster) {
        cluster.delete(id);
        if (cluster.size === 0) {
          topicClusters.value.delete(topicId);
        }
      }
      nodeTopics.value.delete(id);
    }

    // Remove from backend if in a chat
    if (chatStore.currentChatId) {
      await chatStore.removeNode(chatStore.currentChatId, id);
    }

    // Remove from local state
    nodes.value = nodes.value.filter(n => n.id !== id && n.parentId !== id);
  };

  const updateNodeTitle = async (id: string, title: string) => {
    const node = nodes.value.find(n => n.id === id);
    if (node) {
      node.title = title;

      // Auto-save title
      if (chatStore.currentChatId) {
        chatStore.autoSave(chatStore.currentChatId, id, { title });
      }
    }
  };

  const setStreamingContent = (nodeId: string, content: string | null) => {
    const node = nodes.value.find(n => n.id === nodeId);
    if (node) {
      node.streamingContent = content;
    }
  };

  const loadChatState = async (chatId: string) => {
    try {
      const chatData = await chatStore.loadChat(chatId);
      if (!chatData) throw new Error('Failed to load chat');

      // Clear existing nodes
      nodes.value = [];

      // Convert and load nodes
      const flattenNodes = (node: any): Node[] => {
        const children = node.children || [];
        return [
          {
            id: node.id,
            type: node.type,
            title: node.title,
            x: node.x,
            y: node.y,
            parentId: node.parentId,
            branchMessageIndex: node.branchMessageIndex,
            messages: node.messages || [],
            streamingContent: null,
            ...node.metadata
          },
          ...children.flatMap(flattenNodes)
        ];
      };

      // Load nodes and update state
      nodes.value = flattenNodes(chatData.nodes);
      lastSavedWorkspaceId.value = chatId;

      // Update localStorage
      const state: LocalStorageState = {
        nodes: nodes.value,
        lastSavedWorkspaceId: chatId
      };
      localStorage.setItem('canvasState', JSON.stringify(state));

      return true;
    } catch (error) {
      console.error('Error loading chat state:', error);
      return false;
    }
  };

  const saveAsNewChat = async (title: string) => {
    const rootNode = nodes.value.find(n => !n.parentId);
    if (!rootNode) return null;

    const chatId = await chatStore.createChat(title, {
      type: rootNode.type,
      title: rootNode.title,
      x: rootNode.x,
      y: rootNode.y,
      messages: rootNode.messages,
      metadata: {
        type: rootNode.type,
        url: (rootNode as any).url,
        mediaType: (rootNode as any).mediaType
      }
    });

    if (chatId) {
      // Save all other nodes
      const otherNodes = nodes.value.filter(n => n.parentId);
      for (const node of otherNodes) {
        await chatStore.addNode(chatId, {
          ...node,
          metadata: {
            type: node.type,
            url: (node as any).url,
            mediaType: (node as any).mediaType
          }
        });
      }
    }

    return chatId;
  };

  const saveWorkspace = async (title?: string) => {
    try {
      if (!title) {
        title = `Workspace ${new Date().toLocaleString()}`;
      }

      // Save the root node and its state
      const rootNode = nodes.value.find(n => !n.parentId);
      if (!rootNode) return null;

      const chatId = await chatStore.createChat(title, {
        type: rootNode.type,
        title: rootNode.title,
        x: rootNode.x,
        y: rootNode.y,
        messages: rootNode.messages,
        metadata: {
          type: rootNode.type,
          url: (rootNode as any).url,
          mediaType: (rootNode as any).mediaType
        }
      });

      if (!chatId) throw new Error('Failed to create chat');

      // Save all other nodes
      const otherNodes = nodes.value.filter(n => n.parentId);
      for (const node of otherNodes) {
        await chatStore.addNode(chatId, {
          ...node,
          metadata: {
            type: node.type,
            url: (node as any).url,
            mediaType: (node as any).mediaType
          }
        });
      }

      // Update local state and localStorage
      lastSavedWorkspaceId.value = chatId;
      const state: LocalStorageState = {
        nodes: nodes.value,
        lastSavedWorkspaceId: chatId
      };
      localStorage.setItem('canvasState', JSON.stringify(state));

      return chatId;
    } catch (error) {
      console.error('Error saving workspace:', error);
      return null;
    }
  };

  const setCustomApiUrl = (url: string | null) => {
    customApiUrl.value = url;
    if (url) {
      localStorage.setItem('customApiUrl', url);
    } else {
      localStorage.removeItem('customApiUrl');
    }
  };
  watch(() => nodes.value, (newNodes) => {
    // Save to localStorage
    const state: LocalStorageState = {
      nodes: newNodes,
      lastSavedWorkspaceId: lastSavedWorkspaceId.value
    };
    localStorage.setItem('canvasState', JSON.stringify(state));

    // Auto-save to backend if in a chat
    if (chatStore.currentChatId) {
      newNodes.forEach(node => {
        chatStore.autoSave(chatStore.currentChatId!, node.id, {
          x: node.x,
          y: node.y,
          messages: node.messages,
          title: node.title,
          metadata: {
            type: node.type,
            url: (node as any).url,
            mediaType: (node as any).mediaType
          }
        });
      });
    }
  }, { deep: true });  // Remove the extra "deep: true" text here

  // Move the return statement inside the store definition
  return {
    nodes,
    activeNode,
    isDragging,
    dragOffset,
    viewMode,
    isTransitioning,
    topicClusters,
    nodeTopics,
    customApiUrl,
    connections,
    graphData,
    lastSavedWorkspaceId,

    CARD_WIDTH,
    CARD_HEIGHT,
    HORIZONTAL_SPACING,

    // Updated methods
    addNode,
    updateNodePosition,
    removeNode,
    updateNodeTitle,
    addMessage,
    removeMessage,
    setStreamingContent,
    sendMessage,
    setCustomApiUrl,
    initFromLocalStorage,
    saveWorkspace,
    loadChatState,
    saveAsNewChat
  };
}); // Move this closing parenthesis here
=== END FILE: ./src/stores/canvasStore.ts ===


=== START FILE: ./src/stores/modelStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export interface Model {
    id: string;
    name: string;
    source: 'ollama' | 'openrouter' | 'google';
    description?: string;
    provider?: string;
    version?: string;
    inputTokenLimit?: number;
    outputTokenLimit?: number;
    temperature?: number;
    supportedGenerationMethods?: string[];
}

export const useModelStore = defineStore('models', () => {
    // State
    const ollamaModels = ref<Model[]>([]);
    const openRouterModels = ref<Model[]>([]);
    const googleModels = ref<Model[]>([]);
    const selectedModel = ref<Model | null>(
        localStorage.getItem('selectedModel')
            ? JSON.parse(localStorage.getItem('selectedModel')!)
            : null
    );

    const initialize = async () => {
        await Promise.all([
            fetchOllamaModels(),
            fetchOpenRouterModels(),
            fetchGoogleModels()
        ]);
    };


    // Fetch models from respective APIs
    const fetchOllamaModels = async () => {
        try {
            const response = await fetch('http://localhost:11434/api/tags');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            if (Array.isArray(data.models)) {
                ollamaModels.value = data.models.map((model: any) => ({
                    id: model.name,
                    name: model.name,
                    source: 'ollama' as const
                }));
            }
        } catch (error) {
            console.error('Error fetching Ollama models:', error);
            ollamaModels.value = [];
        }
    };

    const fetchOpenRouterModels = async () => {
        const apiKey = localStorage.getItem('openRouterApiKey');
        if (!apiKey) return;

        try {
            const response = await fetch('https://openrouter.ai/api/v1/models', {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            openRouterModels.value = data.data.map((model: any) => ({
                id: model.id,
                name: model.name.split(':')[1]?.trim() || model.name,
                source: 'openrouter' as const,
                provider: model.name.split(':')[0],
                description: model.description
            }));
        } catch (error) {
            console.error('Error fetching OpenRouter models:', error);
            openRouterModels.value = [];
        }
    };

    const fetchGoogleModels = async () => {
        // Use geminiApiKey to match the component
        const apiKey = localStorage.getItem('geminiApiKey');
        if (!apiKey) {
            console.log('No Gemini API key found');
            return;
        }

        try {
            console.log('Fetching Google models...');
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            console.log('Received models:', data.models?.length || 0);

            // Filter out non-Gemini models and transform the data
            googleModels.value = data.models
                .filter((model: any) => model.name.includes('gemini'))
                .map((model: any) => ({
                    id: model.name,
                    name: model.displayName,
                    source: 'google' as const,
                    description: model.description,
                    version: model.version,
                    inputTokenLimit: model.inputTokenLimit,
                    outputTokenLimit: model.outputTokenLimit,
                    temperature: model.temperature,
                    supportedGenerationMethods: model.supportedGenerationMethods
                }))
                .sort((a: Model, b: Model) => {
                    const aIsExp = a.version?.includes('exp') || false;
                    const bIsExp = b.version?.includes('exp') || false;
                    if (aIsExp !== bIsExp) return aIsExp ? 1 : -1;
                    return b.name.localeCompare(a.name);
                });

            console.log('Processed Gemini models:', googleModels.value.length);
        } catch (error) {
            console.error('Error fetching Google models:', error);
            googleModels.value = [];
        }
    };

    // Get filtered models based on provider and search query
    const getFilteredModels = (provider: string, searchQuery: string) => {
        const query = searchQuery.toLowerCase();
        let models: Model[] = [];

        switch (provider) {
            case 'ollama':
                models = ollamaModels.value;
                break;
            case 'openrouter':
                models = openRouterModels.value;
                break;
            case 'google':
                models = googleModels.value;
                break;
        }

        return models.filter(model =>
            model.name.toLowerCase().includes(query) ||
            model.description?.toLowerCase().includes(query) ||
            model.provider?.toLowerCase().includes(query)
        );
    };

    // Set selected model and persist to localStorage
    const setSelectedModel = (model: Model) => {
        selectedModel.value = model;
        try {
            localStorage.setItem('selectedModel', JSON.stringify(model));
            localStorage.setItem('modelType', model.source);
        } catch (e) {
            console.error('Error storing model:', e);
        }
    };

    // Computed property to get the current model's capabilities
    const selectedModelCapabilities = computed(() => {
        if (!selectedModel.value) return null;

        return {
            supportsVision: selectedModel.value.name.toLowerCase().includes('vision'),
            supportsChat: selectedModel.value.supportedGenerationMethods?.includes('generateContent') || false,
            maxInputTokens: selectedModel.value.inputTokenLimit || 0,
            maxOutputTokens: selectedModel.value.outputTokenLimit || 0
        };
    });

    return {
        selectedModel,
        ollamaModels,
        openRouterModels,
        googleModels,
        initialize,
        getFilteredModels,
        setSelectedModel,
        selectedModelCapabilities
    };
});
=== END FILE: ./src/stores/modelStore.ts ===


=== START FILE: ./src/stores/chatStore.ts ===
=== TYPE: ts ===

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { Node } from '../types/message';

interface ChatSummary {
    id: string;
    title: string;
    createdAt: string;
    updatedAt: string;
    nodeCount: number;
}

interface ChatData {
    id: string;
    title: string;
    createdAt: string;
    updatedAt: string;
    nodes: Node;
}

export const useChatStore = defineStore('chat', () => {
    const currentChatId = ref<string | null>(null);
    const chats = ref<ChatSummary[]>([]);
    const isLoading = ref(false);
    const error = ref<string | null>(null);

    // Load chat list
    const loadChats = async () => {
        isLoading.value = true;
        error.value = null;
        try {
            const response = await fetch('http://127.0.0.1:5000/chats');
            const data = await response.json();
            chats.value = data.chats;
        } catch (e) {
            error.value = 'Failed to load chats';
            console.error(e);
        } finally {
            isLoading.value = false;
        }
    };

    // Create new chat
    const createChat = async (title: string, initialNode: any) => {
        isLoading.value = true;
        error.value = null;
        try {
            const response = await fetch('http://127.0.0.1:5000/chats', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title, initialNode })
            });
            const data = await response.json();
            await loadChats();
            return data.chatId;
        } catch (e) {
            error.value = 'Failed to create chat';
            console.error(e);
            return null;
        } finally {
            isLoading.value = false;
        }
    };

    // Load specific chat
    const loadChat = async (chatId: string) => {
        isLoading.value = true;
        error.value = null;
        try {
            const response = await fetch(`http://127.0.0.1:5000/chats/${chatId}`);
            const data = await response.json();
            currentChatId.value = chatId;
            return data;
        } catch (e) {
            error.value = 'Failed to load chat';
            console.error(e);
            return null;
        } finally {
            isLoading.value = false;
        }
    };

    // Delete chat
    const deleteChat = async (chatId: string) => {
        isLoading.value = true;
        error.value = null;
        try {
            await fetch(`http://127.0.0.1:5000/chats/${chatId}`, { method: 'DELETE' });
            if (currentChatId.value === chatId) {
                currentChatId.value = null;
            }
            await loadChats();
            return true;
        } catch (e) {
            error.value = 'Failed to delete chat';
            console.error(e);
            return false;
        } finally {
            isLoading.value = false;
        }
    };

    // Add node
    const addNode = async (chatId: string, nodeData: any) => {
        try {
            const response = await fetch(`http://127.0.0.1:5000/chats/${chatId}/nodes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(nodeData)
            });
            const data = await response.json();
            return data.nodeId;
        } catch (e) {
            console.error(e);
            return null;
        }
    };

    // Update node
    const updateNode = async (chatId: string, nodeId: string, data: any) => {
        try {
            await fetch(`http://127.0.0.1:5000/chats/${chatId}/nodes/${nodeId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            return true;
        } catch (e) {
            console.error(e);
            return false;
        }
    };

    // Remove node
    const removeNode = async (chatId: string, nodeId: string) => {
        try {
            await fetch(`http://127.0.0.1:5000/chats/${chatId}/nodes/${nodeId}`, {
                method: 'DELETE'
            });
            return true;
        } catch (e) {
            console.error(e);
            return false;
        }
    };

    // Auto-save functionality
    let saveTimeout: number | null = null;
    const autoSave = async (chatId: string, nodeId: string, data: any) => {
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }

        saveTimeout = window.setTimeout(async () => {
            await updateNode(chatId, nodeId, data);
        }, 2000); // Debounced save after 2 seconds of no changes
    };

    // Computed properties
    const currentChat = computed(() =>
        chats.value.find(chat => chat.id === currentChatId.value)
    );

    return {
        currentChatId,
        chats,
        isLoading,
        error,
        currentChat,
        loadChats,
        createChat,
        loadChat,
        deleteChat,
        addNode,
        updateNode,
        removeNode,
        autoSave
    };
});
=== END FILE: ./src/stores/chatStore.ts ===


=== START FILE: ./src/utils/api.ts ===
=== TYPE: ts ===


=== END FILE: ./src/utils/api.ts ===


=== START FILE: ./src/components/ui/Card.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Card.vue -->
<template>
    <div 
      class="rounded-lg border bg-card text-card-foreground shadow"
      :class="className"
    >
      <slot />
    </div>
  </template>
  
  <script setup>
  defineProps({
    className: {
      type: String,
      default: ''
    }
  });
  </script>
=== END FILE: ./src/components/ui/Card.vue ===


=== START FILE: ./src/components/ui/alert/Alert.vue ===
=== TYPE: vue ===

<template>
  <div :class="[
    'relative w-full rounded-lg border p-4',
    variantStyles[variant || 'default'],
    className
  ]" role="alert">
    <slot />
  </div>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'default' | 'destructive',
  className?: string
}

withDefaults(defineProps<Props>(), {
  variant: 'default',
  className: ''
})

const variantStyles = {
  default: 'bg-background text-foreground',
  destructive: 'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive'
}
</script>
=== END FILE: ./src/components/ui/alert/Alert.vue ===


=== START FILE: ./src/components/ui/alert/AlertDescription.vue ===
=== TYPE: vue ===

<!-- src/components/ui/AlertDescription.vue -->
<template>
    <div
      class="text-sm [&_p]:leading-relaxed"
      :class="className"
    >
      <slot />
    </div>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    className?: string
  }>()
  </script>
=== END FILE: ./src/components/ui/alert/AlertDescription.vue ===


=== START FILE: ./src/components/ui/alert/AlertTitle.vue ===
=== TYPE: vue ===

<!-- src/components/ui/AlertTitle.vue -->
<template>
    <h5
      class="mb-1 font-medium leading-none tracking-tight"
      :class="className"
    >
      <slot />
    </h5>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    className?: string
  }>()
  </script>
=== END FILE: ./src/components/ui/alert/AlertTitle.vue ===


=== START FILE: ./src/components/ui/Badge.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Badge.vue -->
<template>
  <div 
    class="inline-flex items-center rounded-md px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
    :class="{
      'bg-primary text-primary-foreground hover:bg-primary/80': variant === 'default',
      'bg-secondary text-secondary-foreground hover:bg-secondary/80': variant === 'secondary',
      'bg-destructive text-destructive-foreground hover:bg-destructive/80': variant === 'destructive',
      'border border-primary/20 bg-primary/10 text-primary hover:bg-primary/20': variant === 'outline'
    }"
  >
    <slot />
  </div>
</template>

<script setup>
defineProps({
  variant: {
    type: String,
    default: 'default',
    validator: (value) => ['default', 'secondary', 'destructive', 'outline'].includes(value)
  }
});
</script>
=== END FILE: ./src/components/ui/Badge.vue ===


=== START FILE: ./src/components/ui/Button.vue ===
=== TYPE: vue ===

<!-- src/components/ui/Button.vue -->
<template>
    <button
      class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
      :class="[
        variantStyles[variant],
        sizeStyles[size],
        className
      ]"
      :disabled="disabled"
      :type="type"
      @click="$emit('click', $event)"
    >
      <slot />
    </button>
  </template>
  
  <script setup lang="ts">
  interface Props {
    variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link'
    size?: 'default' | 'sm' | 'lg' | 'icon'
    className?: string
    disabled?: boolean
    type?: 'button' | 'submit' | 'reset'
  }
  
  withDefaults(defineProps<Props>(), {
    variant: 'default',
    size: 'default',
    className: '',
    disabled: false,
    type: 'button'
  })
  
  defineEmits<{
    (e: 'click', event: MouseEvent): void
  }>()
  
  const variantStyles = {
    default: 'bg-primary text-primary-foreground shadow hover:bg-primary/90',
    destructive: 'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',
    outline: 'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',
    secondary: 'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',
    ghost: 'hover:bg-accent hover:text-accent-foreground',
    link: 'text-primary underline-offset-4 hover:underline'
  }
  
  const sizeStyles = {
    default: 'h-9 px-4 py-2',
    sm: 'h-8 rounded-md px-3 text-xs',
    lg: 'h-10 rounded-md px-8',
    icon: 'h-9 w-9'
  }
  </script>
=== END FILE: ./src/components/ui/Button.vue ===


=== START FILE: ./src/components/messages/MessageInput.vue ===
=== TYPE: vue ===

<!-- src/components/MessageInput.vue -->
<template>
  <div class="message-input-container border-t border-gray-200 dark:border-gray-700 mt-4 pt-4">
    <div class="relative">
      <textarea
        ref="textareaRef"
        v-model="messageInput"
        rows="1"
        class="w-full px-4 py-2.5 resize-none bg-white dark:bg-gray-800 
               border border-gray-200 dark:border-gray-700 rounded-lg pr-24
               text-gray-800 dark:text-gray-200 placeholder-gray-500
               focus:ring-2 focus:ring-primary focus:ring-opacity-50 focus:border-transparent"
        :class="{ 'opacity-50': isLoading }"
        placeholder="Type your message..."
        @keydown.enter.prevent="handleSubmit"
        @input="autoResize"
      ></textarea>
      
      <div class="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-2">
        <!-- The button toggles between "Send" and "Stop" based on isLoading -->
        <button
          class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 
                 transition-colors disabled:opacity-50"
          :disabled="!isLoading && !messageInput.trim()"
          @click="handleToggleButton"
        >
          <!-- If isLoading, show Stop icon; otherwise show Send icon -->
          <template v-if="isLoading">
            <!-- Stop Icon (any you prefer, e.g. XCircle, or lucide StopCircle, etc.) -->
            <StopCircle class="w-5 h-5 text-red-600" />
          </template>
          <template v-else>
            <Send class="w-5 h-5 text-primary" />
          </template>
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick } from 'vue';
import { Send, StopCircle } from 'lucide-vue-next';

const props = defineProps({
  isLoading: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits(['send', 'stop']);

const messageInput = ref('');
const textareaRef = ref(null);

/**
 * Dynamically resize the text area.
 */
const autoResize = () => {
  const textarea = textareaRef.value;
  if (!textarea) return;
  
  textarea.style.height = 'auto';
  textarea.style.height = `${textarea.scrollHeight}px`;
};

/**
 * Called on Enter or Send button click.
 */
const handleSubmit = async () => {
  const message = messageInput.value.trim();
  if (!message || props.isLoading) return;

  emit('send', message);
  messageInput.value = '';
  
  await nextTick();
  autoResize();
};

/**
 * Called if isLoading is true (currently streaming).
 * Emitted up so parent can stop the generation and update store.
 */
const handleStop = () => {
  emit('stop');
};

/**
 * Toggle function for the button click:
 * - If we are loading/streaming => "Stop"
 * - Otherwise => "Send"
 */
const handleToggleButton = () => {
  if (props.isLoading) {
    handleStop();
  } else {
    handleSubmit();
  }
};
</script>

=== END FILE: ./src/components/messages/MessageInput.vue ===


=== START FILE: ./src/components/messages/CodePreview.vue ===
=== TYPE: vue ===

<template>
  <div class="relative mt-3 mb-3">
    <div class="absolute right-2 top-2 flex gap-2">
      <button 
        class="p-1.5 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors shadow-sm"
        @click="copyToClipboard"
      >
        <Clipboard class="w-4 h-4 text-gray-600 dark:text-gray-300" />
      </button>
    </div>
    <pre 
      ref="previewRef"
      :class="[
        'p-4 rounded-lg overflow-x-auto border',
        'bg-gray-100 dark:bg-gray-800',
        'border-gray-200 dark:border-gray-700',
        isDark ? 'hljs-dark' : 'hljs-light'
      ]"
    >
      <code 
        ref="codeRef"
        :class="`language-${props.language} hljs text-sm`"
        v-html="highlightedCode"
      />
    </pre>
    <div v-if="props.isStreaming" class="mt-2 flex gap-1">
      <span class="animate-bounce w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-75 w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-150 w-1.5 h-1.5 bg-primary rounded-full"></span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue';
import hljs from 'highlight.js';
import DOMPurify from 'dompurify';
import { Clipboard } from 'lucide-vue-next';

interface Props {
  content: string;
  isStreaming: boolean;
  language?: string;
}

const props = withDefaults(defineProps<Props>(), {
  language: 'javascript'
});

const previewRef = ref<HTMLElement | null>(null);
const codeRef = ref<HTMLElement | null>(null);
const isDark = ref(false);

// Watch for theme changes
const updateTheme = () => {
  isDark.value = document.documentElement.classList.contains('dark');
};

onMounted(() => {
  // Initialize hljs
  hljs.configure({ 
    ignoreUnescapedHTML: true,
    languages: ['javascript', 'python', 'bash', 'typescript', 'json']
  });

  // Set initial theme
  updateTheme();

  // Watch for theme changes using MutationObserver
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        updateTheme();
      }
    });
  });

  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class']
  });

  // Cleanup
  onUnmounted(() => {
    observer.disconnect();
  });
});

const highlightedCode = computed(() => {
  try {
    // First ensure language is registered
    if (!hljs.getLanguage(props.language)) {
      console.warn(`Language ${props.language} not found, falling back to plaintext`);
      return DOMPurify.sanitize(props.content);
    }

     const result = hljs.highlight(props.content, {
        language: props.language,
      });


    return DOMPurify.sanitize(result.value);
  } catch (err) {
    console.error('Highlighting error:', err);
    return DOMPurify.sanitize(props.content);
  }
});

const copyToClipboard = () => {
  navigator.clipboard.writeText(props.content);
};
</script>

<style>
/* Light theme styles */
:root:not(.dark) .hljs-light {
  --hljs-background: transparent;
  --hljs-comment: #54575a;
  --hljs-keyword: #d73a49;
  --hljs-string: #032f62;
  --hljs-number: #005cc5;
  --hljs-function: #2c0f60;
  --hljs-title: #240b53;
  --hljs-params: #24292e;
  --hljs-built_in: #005cc5;
  --hljs-literal: #005cc5;
  --hljs-variable: #24292e;
  --hljs-type: #d73a49;
  --hljs-attr: #005cc5;
  --hljs-selector: #125f24;
}

/* Dark theme styles */
.dark .hljs-dark {
  --hljs-background: transparent;
  --hljs-comment: #8b949e;
  --hljs-keyword: #ff7b72;
  --hljs-string: #a5d6ff;
  --hljs-number: #79c0ff;
  --hljs-function: #d2a8ff;
  --hljs-title: #d2a8ff;
  --hljs-params: #c9d1d9;
  --hljs-built_in: #79c0ff;
  --hljs-literal: #79c0ff;
  --hljs-variable: #c9d1d9;
  --hljs-type: #ff7b72;
  --hljs-attr: #79c0ff;
  --hljs-selector: #7ee787;
}

/* Common styles */
.hljs {
  background: var(--hljs-background) !important;
  color: var(--hljs-params);
}

.hljs-comment { color: var(--hljs-comment); }
.hljs-keyword { color: var(--hljs-keyword); }
.hljs-string { color: var(--hljs-string); }
.hljs-number { color: var(--hljs-number); }
.hljs-function { color: var(--hljs-function); }
.hljs-title { color: var(--hljs-title); }
.hljs-params { color: var(--hljs-params); }
.hljs-built_in { color: var(--hljs-built_in); }
.hljs-literal { color: var(--hljs-literal); }
.hljs-variable { color: var(--hljs-variable); }
.hljs-type { color: var(--hljs-type); }
.hljs-attr { color: var(--hljs-attr); }
.hljs-selector { color: var(--hljs-selector); }

pre {
  margin: 0;
  white-space: pre-wrap;
  word-break: break-word;
  tab-size: 2;
}

code {
  font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, 'Courier New', monospace;
}
</style>
=== END FILE: ./src/components/messages/CodePreview.vue ===


=== START FILE: ./src/components/messages/MessageContent.vue ===
=== TYPE: vue ===

<template>
  <div class="message-content">
    <!-- If streaming, show chunked output as it arrives -->
    <template v-if="isStreaming">
      <div v-for="(part, index) in streamingParts" :key="index" class="first:mt-0 mt-4">
        <CodePreview v-if="part.type === 'code'" :content="part.content" :is-streaming="!part.complete"
          :language="part.language || 'plaintext'" />
        <div v-else v-html="part.content" class="text-base-content whitespace-pre-wrap" />
      </div>
    </template>

    <!-- Otherwise, render the fully parsed content (once complete) -->
    <template v-else>
      <div v-for="(part, index) in parsedContent" :key="index" class="first:mt-0 mt-4">
        <CodePreview v-if="part.type === 'code'" :content="part.content" :is-streaming="false"
          :language="part.language" />
        <div v-else v-html="part.content" class="text-base-content whitespace-pre-wrap" />
      </div>
    </template>

    <!-- Optional "AI typing" indicator -->
    <div v-if="isStreaming" class="mt-2 flex gap-1">
      <span class="animate-bounce w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-75 w-1.5 h-1.5 bg-primary rounded-full"></span>
      <span class="animate-bounce delay-150 w-1.5 h-1.5 bg-primary rounded-full"></span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import CodePreview from './CodePreview.vue'
import { marked } from 'marked'
import DOMPurify from 'dompurify'

interface Props {
  content: string
  isStreaming?: boolean
}

interface ContentPart {
  type: 'text' | 'code'
  content: string
  language?: string
  complete?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  isStreaming: false
})

// Store the last complete content
const lastCompleteContent = ref('')

// Keep track of streaming parts
const streamingParts = ref<ContentPart[]>([])

// Watch for content changes during streaming
watch(
  () => props.content,
  async (newContent) => {
    if (!props.isStreaming) {
      // Store the complete content when streaming ends
      lastCompleteContent.value = newContent
      return
    }

    const parts: ContentPart[] = []
    let inCodeBlock = false
    let codeLanguage = ''
    let currentBuffer = ''
    let i = 0

    while (i < newContent.length) {
      if (newContent.slice(i, i + 3) === '```') {
        if (!inCodeBlock) {
          if (currentBuffer) {
            const html = await marked(currentBuffer)
            const safeHTML = DOMPurify.sanitize(html as string)
            parts.push({
              type: 'text',
              content: safeHTML,
              complete: true
            })
            currentBuffer = ''
          }
          let endOfLine = newContent.indexOf('\n', i + 3)
          if (endOfLine === -1) endOfLine = newContent.length
          codeLanguage = newContent.slice(i + 3, endOfLine).trim()

          inCodeBlock = true
          i = endOfLine + 1
        } else {
          parts.push({
            type: 'code',
            content: currentBuffer.trim(),
            language: codeLanguage || 'plaintext',
            complete: true
          })

          inCodeBlock = false
          codeLanguage = ''
          currentBuffer = ''
          i += 3
        }
      } else {
        currentBuffer += newContent[i]
        i++
      }
    }

    if (currentBuffer) {
      if (inCodeBlock) {
        parts.push({
          type: 'code',
          content: currentBuffer,
          language: codeLanguage || 'plaintext',
          complete: false
        })
      } else {
        const html = await marked(currentBuffer)
        const safeHTML = DOMPurify.sanitize(html)
        parts.push({
          type: 'text',
          content: safeHTML,
          complete: false
        })
      }
    }

    streamingParts.value = parts
  }
)

// Parse content for non-streaming mode
const parsedContent = computed<ContentPart[]>(() => {
  // Use the last complete content instead of props.content
  const contentToProcess = lastCompleteContent.value || props.content
  const parts: ContentPart[] = []
  let inCodeBlock = false
  let codeLanguage = ''
  let currentBuffer = ''

  const processMarkdown = (text: string) => {
    if (!text) return
    const html = marked(text)
    const safeHTML = DOMPurify.sanitize(html as string)
    parts.push({
      type: 'text',
      content: safeHTML,
      complete: true
    })
  }

  const lines = contentToProcess.split('\n')

  for (const line of lines) {
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        parts.push({
          type: 'code',
          content: currentBuffer,
          language: codeLanguage || 'plaintext',
          complete: true
        })
        currentBuffer = ''
        codeLanguage = ''
        inCodeBlock = false
      } else {
        if (currentBuffer) processMarkdown(currentBuffer)
        currentBuffer = ''
        codeLanguage = line.slice(3).trim()
        inCodeBlock = true
      }
    } else {
      currentBuffer += currentBuffer ? '\n' + line : line
    }
  }

  if (inCodeBlock) {
    parts.push({
      type: 'code',
      content: currentBuffer,
      language: codeLanguage || 'plaintext',
      complete: true
    })
  } else if (currentBuffer) {
    processMarkdown(currentBuffer)
  }

  return parts
})
</script>
=== END FILE: ./src/components/messages/MessageContent.vue ===


=== START FILE: ./src/components/messages/MessageTimestamp.vue ===
=== TYPE: vue ===


<!-- MessageTimestamp.vue -->
<template>
    <div
      class="absolute flex items-center px-3 py-1.5 gap-1.5 text-xs font-mono rounded-full 
             bg-white dark:bg-gray-800 shadow-sm border border-gray-200 dark:border-gray-700
             text-gray-600 dark:text-gray-400 hover:bg-gray-50 dark:hover:bg-gray-700 
             transition-all duration-200"
      :class="side === 'right' ? 'left-[calc(100%+8px)] top-4' : 'right-[calc(100%+8px)] top-4'"
    >
      <Timer class="w-3 h-3" />
      <span>{{ formattedTime }}</span>
    </div>
  </template>
  
  <script setup lang="ts">
  // MessageTimestamp.vue
import { computed } from 'vue';
import { Timer } from 'lucide-vue-next';

const props = defineProps({
  timestamp: {
    type: String,
    required: true
  },
  side: {
    type: String,
    default: 'right',
    validator: (value: string) => ['left', 'right'].includes(value)
  }
});

const formattedTime = computed(() => {
  const date = new Date(props.timestamp);
  return `${
    date.getHours().toString().padStart(2, '0')
  }:${
    date.getMinutes().toString().padStart(2, '0')
  }:${
    date.getSeconds().toString().padStart(2, '0')
  }`;
});
  </script>
  
  <!-- Updated styles for BranchNode.vue -->
  <style>
  .message-bubble {
    @apply relative transition-all duration-200 rounded-lg p-4;
  }
  
  .message-bubble.user {
    @apply bg-blue-900/20 border-l-4 border-blue-500;
  }
  
  .message-bubble.assistant {
    @apply bg-purple-900/20 border-l-4 border-purple-500;
  }
  
  .message-bubble.inherited {
    @apply opacity-75 border-dashed;
  }
  
  .node-card {
    @apply backdrop-blur bg-gray-900/30 transition-all duration-300 border border-gray-700/50 rounded-lg;
  }
  
  .node-card:hover {
    @apply shadow-lg shadow-black/20 border-gray-600/50;
  }
  
  .selected .node-card {
    @apply ring-2 ring-blue-500/50;
  }
  
  .streaming .node-card {
    @apply relative;
  }
  
  .streaming .node-card::before {
    content: '';
    @apply absolute inset-0 rounded-lg;
    background: linear-gradient(90deg, 
      theme('colors.blue.500') 0%,
      theme('colors.purple.500') 50%,
      theme('colors.blue.500') 100%
    );
    background-size: 200% 100%;
    animation: flowBorder 4s linear infinite;
    z-index: 0;
    opacity: 0.2;
  }
  
  @keyframes flowBorder {
    0% { background-position: 100% 0; }
    100% { background-position: -100% 0; }
  }
  </style>
=== END FILE: ./src/components/messages/MessageTimestamp.vue ===


=== START FILE: ./src/components/tokenizer/DirectoryTokenizer.vue ===
=== TYPE: vue ===

<template>
    <div class="min-h-screen bg-background/40 backdrop-blur-md p-6 border border-border/40">
      <div class="max-w-6xl mx-auto">
        <div class="flex justify-between items-center mb-8">
          <div class="flex items-center space-x-4">
            <h1 class="text-3xl font-bold text-foreground">Tokenic</h1>
            <div class="relative flex space-x-2">
              <select v-model="optimizationLevel"
                      class="w-44 px-3 py-2 bg-background border rounded-lg shadow-sm">
                <option value="low">Conservative</option>
                <option value="medium">Standard</option>
                <option value="aggressive">Aggressive</option>
              </select>
              <select v-model="selectedModel"
                      class="w-full px-4 py-2 bg-background/80 backdrop-blur-sm border rounded-lg appearance-none cursor-pointer">
                <optgroup v-for="(models, category) in groupedModels" :key="category" :label="category">
                  <option v-for="model in models" :key="model" :value="model">
                    {{ model }}
                  </option>
                </optgroup>
              </select>
              <div class="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none">
                <span class="i-lucide-chevron-down h-4 w-4 text-muted-foreground" />
              </div>
            </div>
          </div>
        </div>
  
        <!-- Tab Selection -->
        <div class="flex gap-4 border-b mb-6">
          <button
            v-for="tab in tabs"
            :key="tab.id"
            @click="activeTab = tab.id"
            class="px-4 py-2 -mb-px transition-colors relative"
            :class="[
              activeTab === tab.id
                ? 'border-b-2 border-primary text-primary font-medium'
                : 'text-muted-foreground hover:text-foreground'
            ]"
          >
            {{ tab.name }}
          </button>
        </div>
  
        <!-- File Processing -->
        <div v-if="activeTab === 'file'" class="space-y-6">
          <div class="flex items-center gap-4">
            <div class="flex-1 relative">
              <input
                v-model="filePath"
                type="text"
                placeholder="Enter file path..."
                class="w-full px-4 py-3 bg-background border rounded-lg pr-10"
                @keyup.enter="optimizeFile"
              />
              <button
                v-if="filePath"
                @click="filePath = ''"
                class="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <span class="i-lucide-x h-4 w-4" />
              </button>
            </div>
            <button
              @click="optimizeFile"
              class="px-6 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              :disabled="isProcessing || !filePath"
            >
              {{ isProcessing ? 'Processing...' : 'Optimize' }}
            </button>
          </div>
        </div>
  
        <!-- Directory Processing -->
        <div v-if="activeTab === 'directory'" class="space-y-6">
          <div class="flex items-center gap-4">
            <div class="flex-1 relative">
              <input
                v-model="directory"
                type="text"
                placeholder="Enter directory path..."
                class="w-full px-4 py-3 bg-background border rounded-lg pr-10"
                @keyup.enter="processDirectory"
              />
              <button
                v-if="directory"
                @click="directory = ''"
                class="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <span class="i-lucide-x h-4 w-4" />
              </button>
            </div>
            <button
              @click="processDirectory"
              class="px-6 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              :disabled="isProcessing || !directory"
            >
              {{ isProcessing ? 'Processing...' : 'Process Directory' }}
            </button>
          </div>
        </div>
  
        <!-- Raw Text Input -->
        <div v-if="activeTab === 'raw'" class="space-y-6">
          <div class="flex items-center gap-4 mb-4">
            <select v-model="rawInputType" class="px-4 py-3 bg-background border rounded-lg">
              <option value="system">System</option>
              <option value="user">User</option>
              <option value="assistant">Assistant</option>
            </select>
            <button
              @click="optimizeRawText"
              class="px-6 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              :disabled="isProcessing || !rawText"
            >
              {{ isProcessing ? 'Processing...' : 'Optimize' }}
            </button>
          </div>
          <div class="relative">
            <textarea
              v-model="rawText"
              placeholder="Enter your text here..."
              class="w-full h-48 p-4 bg-background border rounded-lg font-mono text-sm resize-none"
              @keyup.ctrl.enter="optimizeRawText"
            />
            <div v-if="rawText" class="absolute top-2 right-2">
              <button @click="rawText = ''" class="p-1 hover:bg-muted rounded">
                <span class="i-lucide-x h-4 w-4 text-muted-foreground" />
              </button>
            </div>
          </div>
        </div>
  
        <!-- Results Display -->
        <div v-if="currentResult" class="mt-8 bg-card border rounded-lg shadow-sm">
          <!-- Header Stats -->
          <div class="p-4 border-b">
            <div v-if="currentResult.filepath" class="mb-2 text-sm text-muted-foreground">
              {{ currentResult.filepath }}
            </div>
            <div class="flex items-center justify-between">
              <div class="flex gap-6 text-sm">
                <div>
                  <span class="text-muted-foreground">Original Tokens:</span>
                  <span class="ml-2 font-medium">{{ currentResult.token_map.original.token_count }}</span>
                </div>
                <div>
                  <span class="text-muted-foreground">Optimized Tokens:</span>
                  <span class="ml-2 font-medium">{{ currentResult.token_map.optimized.token_count }}</span>
                </div>
                <div>
                  <span class="text-muted-foreground">Reduction:</span>
                  <span class="ml-2 font-medium">
                    {{
                      (
                        (currentResult.token_map.original.token_count -
                          currentResult.token_map.optimized.token_count) /
                        currentResult.token_map.original.token_count
                      * 100).toFixed(1)
                    }}%
                  </span>
                </div>
              </div>
              <div class="text-sm text-muted-foreground">
                Model: {{ currentResult.model }}
              </div>
            </div>
          </div>
  
          <!-- Token Visualization -->
          <div class="grid grid-cols-2 gap-6 p-6">
            <!-- Original Panel -->
            <div>
              <h4 class="font-medium mb-2">Original</h4>
              <div class="max-h-[400px] overflow-auto">
                <pre
                  class="p-4 bg-muted rounded-lg font-mono text-sm whitespace-normal leading-tight"
                  style="margin: 0;"
                >
  <template v-for="(token, idx) in currentResult.token_map.original.tokens" :key="idx">
    <span
      class="token"
      :class="{
        'bg-destructive/20 text-destructive': isRemovedToken(token),
        'bg-success/20 text-success': isNewToken(token),
        'opacity-50': isRemovedToken(token)
      }"
    >
      {{ token.trim() }}
    </span><span v-if="idx < currentResult.token_map.original.tokens.length - 1"> </span>
  </template>
                </pre>
              </div>
            </div>
  
            <!-- Removed Tokens Panel -->
            <div>
              <h4 class="font-medium mb-2">Removed Tokens</h4>
              <div class="max-h-[400px] overflow-auto">
                <pre
                  class="p-4 bg-muted rounded-lg font-mono text-sm whitespace-normal leading-tight"
                  style="margin: 0;"
                >
  <template v-for="(token, idx) in removedTokens" :key="idx">
    <span class="token bg-destructive/20 text-destructive">
      {{ token.trim() }}
    </span><span v-if="idx < removedTokens.length - 1"> </span>
  </template>
                </pre>
              </div>
            </div>
          </div>
  
          <!-- Token Analysis -->
          <div class="p-4 border-t bg-muted">
            <div class="grid grid-cols-3 gap-8">
              <div>
                <p class="text-sm text-muted-foreground mb-1">Removed Tokens</p>
                <p class="text-2xl font-bold">{{ getRemovedTokenCount() }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground mb-1">New Tokens</p>
                <p class="text-2xl font-bold">{{ getNewTokenCount() }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground mb-1">Token Savings</p>
                <p class="text-2xl font-bold">{{ getTokenSavings() }}</p>
              </div>
            </div>
          </div>
        </div>
  
        <!-- Bundle Results -->
        <div v-if="activeTab === 'directory' && processedFiles.length" class="mt-8 space-y-4">
          <div class="bg-card border rounded-lg p-4">
            <h3 class="text-lg font-medium mb-4">Bundle Summary</h3>
            <div class="grid grid-cols-4 gap-6">
              <div>
                <p class="text-sm text-muted-foreground">Total Files</p>
                <p class="text-2xl font-bold">{{ processedFiles.length }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground">Total Original Tokens</p>
                <p class="text-2xl font-bold">{{ totalOriginalTokens }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground">Total Optimized Tokens</p>
                <p class="text-2xl font-bold">{{ totalOptimizedTokens }}</p>
              </div>
              <div>
                <p class="text-sm text-muted-foreground">Average Reduction</p>
                <p class="text-2xl font-bold">
                  {{
                    (
                      (totalOriginalTokens - totalOptimizedTokens) /
                        totalOriginalTokens
                    * 100).toFixed(1)
                  }}%
                </p>
              </div>
            </div>
          </div>
        </div>
  
      </div>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed, onMounted } from 'vue'
  
  interface TokenMap {
    text: string
    token_count: number
    tokens: string[]
  }
  
  interface ProcessedResult {
    filepath?: string
    token_map: {
      original: TokenMap
      optimized: TokenMap
    }
    optimization_level: string
    model: string
  }
  
  interface Tab {
    id: 'file' | 'directory' | 'raw'
    name: string
  }
  
  const tabs: Tab[] = [
    { id: 'file', name: 'Single File' },
    { id: 'directory', name: 'Directory' },
    { id: 'raw', name: 'Raw Text' }
  ]
  
  const activeTab = ref<Tab['id']>('file')
  const directory = ref('')
  const filePath = ref('')
  const rawText = ref('')
  const rawInputType = ref<'system' | 'user' | 'assistant'>('user')
  const optimizationLevel = ref('medium')
  const isProcessing = ref(false)
  const currentResult = ref<ProcessedResult | null>(null)
  const processedFiles = ref<ProcessedResult[]>([])
  const selectedModel = ref('gpt-4')
  const availableModels = ref<string[]>([])
  
  const groupedModels = computed(() => {
    return {
      Popular: availableModels.value.filter(m =>
        ['gpt-4', 'gpt-3.5-turbo', 'gpt-4-1106-preview'].includes(m)
      ),
      'Open-Source Models': availableModels.value.filter(m =>
        m.includes('llama') || m.includes('meta')
      ),
      'OpenAI Models': availableModels.value.filter(m =>
        m.includes('gpt') && !['gpt-4','gpt-3.5-turbo','gpt-4-1106-preview'].includes(m)
      ),
      Legacy: availableModels.value.filter(m =>
        ['davinci','curie','babbage','ada'].includes(m)
      )
    }
  })
  
  const totalOriginalTokens = computed(() => {
    return processedFiles.value.reduce((sum, file) =>
      sum + file.token_map.original.token_count, 0
    )
  })
  
  const totalOptimizedTokens = computed(() => {
    return processedFiles.value.reduce((sum, file) =>
      sum + file.token_map.optimized.token_count, 0
    )
  })
  
  onMounted(async () => {
    // try {
    //   const response = await fetch('http://127.0.0.1:5000/models')
    //   const data = await response.json()
    //   availableModels.value = data.models
    // } catch (error) {
    //   console.error('Error fetching models:', error)
    // }
  })
  
  const removedTokens = computed(() => {
    if (!currentResult.value) return []
    const original = currentResult.value.token_map.original.tokens
    const optimized = currentResult.value.token_map.optimized.tokens
    return original.filter(token => !optimized.includes(token))
  })
  
  const isRemovedToken = (token: string) => {
    if (!currentResult.value) return false
    return !currentResult.value.token_map.optimized.tokens.includes(token)
  }
  
  const isNewToken = (token: string) => {
    if (!currentResult.value) return false
    return (
      currentResult.value.token_map.optimized.tokens.includes(token) &&
      !currentResult.value.token_map.original.tokens.includes(token)
    )
  }
  
  const getRemovedTokenCount = () => {
    if (!currentResult.value) return 0
    return currentResult.value.token_map.original.tokens.filter(token =>
      isRemovedToken(token)
    ).length
  }
  
  const getNewTokenCount = () => {
    if (!currentResult.value) return 0
    return currentResult.value.token_map.optimized.tokens.filter(token =>
      isNewToken(token)
    ).length
  }
  
  const getTokenSavings = () => {
    if (!currentResult.value) return 0
    return (
      currentResult.value.token_map.original.token_count -
      currentResult.value.token_map.optimized.token_count
    )
  }
  
  const optimizeFile = async () => {
    if (!filePath.value) return
    isProcessing.value = true
    try {
      const response = await fetch('http://127.0.0.1:5000/optimize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filepath: filePath.value,
          level: optimizationLevel.value,
          model: selectedModel.value
        }),
      })
  
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to optimize file')
      }
  
      const data = await response.json()
      currentResult.value = data
    } catch (error) {
      console.error('Error optimizing file:', error)
    } finally {
      isProcessing.value = false
    }
  }
  
  const processDirectory = async () => {
    if (!directory.value) return
    isProcessing.value = true
    try {
      const response = await fetch('http://127.0.0.1:5000/bundle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          directory: directory.value,
          level: optimizationLevel.value,
          model: selectedModel.value
        }),
      })
  
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to process directory')
      }
  
      const data = await response.json()
      processedFiles.value = data.files
      if (data.files.length > 0) {
        currentResult.value = data.files[0]
      }
    } catch (error) {
      console.error('Error processing directory:', error)
    } finally {
      isProcessing.value = false
    }
  }
  
  const optimizeRawText = async () => {
    if (!rawText.value) return
    isProcessing.value = true
    try {
      const response = await fetch('http://127.0.0.1:5000/optimize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: rawText.value,
          type: rawInputType.value,
          level: optimizationLevel.value,
          model: selectedModel.value
        }),
      })
  
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Failed to optimize text')
      }
  
      const data = await response.json()
      currentResult.value = data
    } catch (error) {
      console.error('Error optimizing text:', error)
    } finally {
      isProcessing.value = false
    }
  }
  </script>
  
  <style>
  .token {
    display: inline-block;
    border-radius: 2px;
    padding: 0 2px;
    margin: 0 1px;
  }
  </style>
  
=== END FILE: ./src/components/tokenizer/DirectoryTokenizer.vue ===


=== START FILE: ./src/components/workspace/WorkspaceMenu.vue ===
=== TYPE: vue ===

<template>
    <div class="relative">
        <!-- Main Button -->
        <button @click="isOpen = !isOpen" class="btn btn-sm gap-2 bg-base-200/90 backdrop-blur hover:bg-base-300/90">
            <FolderOpen class="w-4 h-4" />
            <span v-if="currentWorkspace">{{ currentWorkspace.title }}</span>
            <span v-else>Untitled Workspace</span>
            <ChevronDown class="w-4 h-4 transition-transform" :class="{ 'rotate-180': isOpen }" />
        </button>

        <!-- Dropdown Menu -->
        <div v-if="isOpen"
            class="absolute top-full mt-2 left-0 w-80 bg-base-200/95 backdrop-blur border border-base-300 rounded-lg shadow-lg p-2 space-y-2"
            v-click-outside="() => isOpen = false">
            <!-- Save Current -->
            <div v-if="!currentWorkspace || isEditing" class="p-2">
                <input ref="titleInput" v-model="workspaceTitle" @keyup.enter="handleSave" class="input input-sm w-full"
                    :placeholder="currentWorkspace ? 'Rename workspace...' : 'Name your workspace...'" />
                <div class="flex justify-end gap-2 mt-2">
                    <button @click="isEditing = false" class="btn btn-sm btn-ghost">
                        Cancel
                    </button>
                    <button @click="handleSave" class="btn btn-sm btn-primary">
                        {{ currentWorkspace ? 'Rename' : 'Save' }}
                    </button>
                </div>
            </div>

            <!-- Quick Actions -->
            <div v-else class="flex gap-2 p-2">
                <button @click="isEditing = true" class="btn btn-sm btn-ghost flex-1">
                    {{ currentWorkspace ? 'Rename' : 'Save As...' }}
                </button>
                <button v-if="currentWorkspace" @click="handleDelete"
                    class="btn btn-sm btn-ghost text-destructive hover:bg-destructive/10">
                    Delete
                </button>
            </div>

            <!-- Saved Workspaces -->
            <div v-if="savedWorkspaces.length" class="border-t border-base-300">
                <div class="py-2 px-3 text-sm text-base-content/60">
                    Recent Workspaces
                </div>
                <button v-for="workspace in savedWorkspaces" :key="workspace.id" @click="loadWorkspace(workspace.id)"
                    class="flex items-center gap-3 w-full p-2 hover:bg-base-300/50 rounded-md transition-colors"
                    :class="{ 'bg-primary/10': workspace.id === currentWorkspace?.id }">
                    <div class="flex-1 text-left">
                        <div class="font-medium">{{ workspace.title }}</div>
                        <div class="text-xs text-base-content/60">
                            {{ new Date(workspace.updatedAt).toLocaleString() }}
                        </div>
                    </div>
                    <ChevronRight class="w-4 h-4 text-base-content/40" />
                </button>
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, nextTick } from 'vue';
import { FolderOpen, ChevronDown, ChevronRight } from 'lucide-vue-next';
import { useCanvasStore } from '@/stores/canvasStore';
import { useChatStore } from '@/stores/chatStore';
import type { ChatSummary } from '@/types/chat'; // Make sure to create this type

const canvasStore = useCanvasStore();
const chatStore = useChatStore();

onMounted(async () => {
    await chatStore.loadChats();
});

const isOpen = ref(false);
const isEditing = ref(false);
const workspaceTitle = ref('');
const titleInput = ref<HTMLInputElement>();

// Use chats instead of workspaces
const savedWorkspaces = computed(() =>
    chatStore.chats.sort((a, b) =>
        new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    )
);

const currentWorkspace = computed(() =>
    chatStore.chats.find(chat => chat.id === canvasStore.lastSavedWorkspaceId)
);

const handleSave = async () => {
    if (!workspaceTitle.value.trim()) return;

    const workspaceId = await canvasStore.saveWorkspace(workspaceTitle.value);
    if (workspaceId) {
        await chatStore.loadChats();
        workspaceTitle.value = '';
        isEditing.value = false;
        isOpen.value = false;
    }
};

const loadWorkspace = async (id: string) => {
    await canvasStore.loadChatState(id);
    isOpen.value = false;
};

const handleDelete = async () => {
    if (!currentWorkspace.value) return;

    if (await window.confirm('Delete this workspace? This cannot be undone.')) {
        await chatStore.deleteChat(currentWorkspace.value.id);
        canvasStore.lastSavedWorkspaceId = null;
        isOpen.value = false;
    }
};



watch(isEditing, async (newValue) => {
    if (newValue) {
        workspaceTitle.value = currentWorkspace.value?.title || '';
        await nextTick();
        titleInput.value?.focus();
    }
});
</script>
=== END FILE: ./src/components/workspace/WorkspaceMenu.vue ===


=== START FILE: ./src/components/models/ModelSelector.vue ===
=== TYPE: vue ===

<template>
  <div class="relative inline-block">
    <!-- Provider Tabs Container -->
    <div class="flex h-10 mb-2 bg-base-200 rounded-lg p-1">
      <!-- Ollama Tab -->
      <button @click="activeProvider = 'ollama'"
        class="relative flex items-center gap-2 px-3 rounded-md transition-all duration-300"
        :class="{
          'bg-base-100 shadow-sm flex-1': activeProvider === 'ollama',
          'w-10 hover:bg-base-300': activeProvider !== 'ollama'
        }">
        <span class="w-6 h-6 flex items-center justify-center">
          <img :src="ollama" alt="Ollama" class="w-5 h-5 object-contain" />
        </span>
        <span class="truncate transition-opacity duration-300"
          :class="{ 'opacity-0 w-0': activeProvider !== 'ollama' }">
          Ollama
        </span>
      </button>

      <!-- OpenRouter Tab -->
      <button @click="activeProvider = 'openrouter'"
        class="relative flex items-center gap-2 px-3 rounded-md transition-all duration-300"
        :class="{
          'bg-base-100 shadow-sm flex-1': activeProvider === 'openrouter',
          'w-10 hover:bg-base-300': activeProvider !== 'openrouter'
        }">
        <span class="w-6 h-6 flex items-center justify-center">
          <svg :width="activeProvider === 'openrouter' ? 20 : 12" :height="activeProvider === 'openrouter' ? 20 : 12"
            viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" fill="currentColor" stroke="currentColor"
            class="transition-all duration-300">
            <g clip-path="url(#clip0_205_3)">
              <path d="M3 248.945C18 248.945 76 236 106 219C136 202 136 202 198 158C276.497 102.293 332 120.945 423 120.945"
                stroke-width="90" />
              <path d="M511 121.5L357.25 210.268L357.25 32.7324L511 121.5Z" />
              <path d="M0 249C15 249 73 261.945 103 278.945C133 295.945 133 295.945 195 339.945C273.497 395.652 329 377 420 377"
                stroke-width="90" />
              <path d="M508 376.445L354.25 287.678L354.25 465.213L508 376.445Z" />
            </g>
          </svg>
        </span>
        <span class="truncate transition-opacity duration-300"
          :class="{ 'opacity-0 w-0': activeProvider !== 'openrouter' }">
          OpenRouter
        </span>
      </button>

      <!-- Google Tab -->
      <button @click="activeProvider = 'google'"
        class="relative flex items-center gap-2 px-3 rounded-md transition-all duration-300"
        :class="{
          'bg-base-100 shadow-sm flex-1': activeProvider === 'google',
          'w-10 hover:bg-base-300': activeProvider !== 'google'
        }">
        <span class="w-6 h-6 flex items-center justify-center">
          <img :src="google" alt="Google" class="w-5 h-5 object-contain" />
        </span>
        <span class="truncate transition-opacity duration-300"
          :class="{ 'opacity-0 w-0': activeProvider !== 'google' }">
          Google
        </span>
      </button>

      <!-- Custom Provider Tab -->
      <button @click="activeProvider = 'custom'"
        class="relative flex items-center gap-2 px-3 rounded-md transition-all duration-300"
        :class="{
          'bg-base-100 shadow-sm flex-1': activeProvider === 'custom',
          'w-10 hover:bg-base-300': activeProvider !== 'custom'
        }">
        <span class="w-6 h-6 flex items-center justify-center">
          <Plus class="w-5 h-5" />
        </span>
        <span class="truncate transition-opacity duration-300"
          :class="{ 'opacity-0 w-0': activeProvider !== 'custom' }">
          Custom
        </span>
      </button>
    </div>

    <!-- Model Selection Button -->
    <button @click="toggleDropdown" @keydown.space.prevent="toggleDropdown" @keydown.enter.prevent="toggleDropdown"
      @keydown.m.prevent="focusModelSelector"
      class="w-64 bg-base-100 border border-base-300 rounded-md px-3 py-2 text-sm flex items-center justify-between hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
      ref="modelButton">
      <div class="flex items-center gap-2 overflow-hidden">
        <span v-if="modelStore.selectedModel" class="flex items-center gap-2">
          <Badge :variant="getProviderVariant(modelStore.selectedModel.source)" class="text-xs">
            {{ getProviderName(modelStore.selectedModel.source) }}
          </Badge>
          <span class="font-medium truncate text-base-content">{{ modelStore.selectedModel.name }}</span>
        </span>
        <span v-else class="text-base-content">Select Model (M)</span>
      </div>
      <ChevronDown class="w-4 h-4 transition-transform text-base-content" :class="{ 'rotate-180': isOpen }" />
    </button>

    <!-- Dropdown Menu -->
    <div v-show="isOpen"
      class="absolute right-0 mt-2 w-96 bg-base-100 border border-base-300 rounded-md shadow-lg z-30">
      <!-- Custom Provider Form -->
      <div v-if="activeProvider === 'custom'" class="p-4">
        <h3 class="text-lg font-medium mb-4">Connect Custom Provider</h3>
        <form @submit.prevent="handleCustomProviderSubmit">
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium mb-1">Provider</label>
              <select v-model="customProvider" class="w-full p-2 border rounded-md bg-base-100">
                <option value="anthropic">Anthropic</option>
                <option value="openai">OpenAI</option>
                <option value="other">Other</option>
              </select>
            </div>
            <div>
              <label class="block text-sm font-medium mb-1">API Key</label>
              <input type="password" v-model="apiKey" placeholder="Enter your API key"
                class="w-full p-2 border rounded-md bg-base-100" />
            </div>
            <div v-if="customProvider === 'other'">
              <label class="block text-sm font-medium mb-1">API Endpoint</label>
              <input type="text" v-model="apiEndpoint" placeholder="https://api.example.com"
                class="w-full p-2 border rounded-md bg-base-100" />
            </div>
            <button type="submit"
              class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 transition-colors">
              Connect Provider
            </button>
          </div>
        </form>
      </div>

      <!-- Regular Model Selection -->
      <template v-else>
        <!-- Search Bar -->
        <div class="p-3 border-b border-base-300">
          <div class="relative">
            <Search class="absolute left-3 top-2.5 w-4 h-4 text-gray-400" />
            <input v-model="searchQuery" type="text" ref="searchInput"
              class="w-full pl-9 pr-3 py-2 border border-base-300 rounded-md bg-base-100 text-sm placeholder:text-gray-400 text-base-content"
              placeholder="Search models... (/)" @keydown.up.prevent="navigateList('up')"
              @keydown.down.prevent="navigateList('down')" @keydown.enter.prevent="selectHighlighted"
              @keydown.esc.prevent="closeDropdown" />
          </div>
        </div>

        <!-- Models List -->
        <div class="max-h-[60vh] overflow-y-auto bg-base-100" role="listbox" ref="modelsList">
          <div v-for="(model, index) in filteredModels" :key="model.id"
            class="border-b border-base-300 last:border-0 cursor-pointer hover:bg-base-200"
            :class="{ 'bg-blue-50 dark:bg-blue-900': highlightedIndex === index }" @click="selectModel(model)"
            @keydown.enter="selectModel(model)" @mouseover="highlightedIndex = index" role="option"
            :aria-selected="highlightedIndex === index" tabindex="0">
            <div class="p-3">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                  <Badge :variant="getProviderVariant(model.source)" class="text-xs">
                    {{ getProviderName(model.source) }}
                  </Badge>
                  <span class="font-medium text-base-content">{{ model.name }}</span>
                </div>
              </div>
              <p v-if="model.description" class="mt-1 text-xs text-gray-500 text-base-content line-clamp-2">
                {{ model.description }}
              </p>
            </div>
          </div>

          <!-- Empty State -->
          <div v-if="filteredModels.length === 0" class="p-8 text-center text-gray-500 text-base-content">
            <p class="text-sm">No models available for {{ getProviderName(activeProvider) }}</p>
          </div>
        </div>
      </template>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount, nextTick } from 'vue';
import { ChevronDown, Search, Plus } from 'lucide-vue-next';
import Badge from '../ui/Badge.vue';
import { useModelStore } from '../../stores/modelStore';
import type { Model } from '../../stores/modelStore';
import google from '@/assets/google.jpeg';
import ollama from '@/assets/ollama.jpeg';

// Define props
const props = defineProps<{
  apiKey?: string;
}>();

const emit = defineEmits<{
  (e: 'select', model: Model): void;
}>();

const modelStore = useModelStore();

// Refs
const isOpen = ref(false);
const searchQuery = ref('');
const highlightedIndex = ref(0);
const modelButton = ref<HTMLButtonElement | null>(null);
const searchInput = ref<HTMLInputElement | null>(null);
const modelsList = ref<HTMLDivElement | null>(null);
const activeProvider = ref<'ollama' | 'openrouter' | 'google' | 'custom'>('ollama');

// Custom provider form state
const customProvider = ref('anthropic');
const apiKey = ref('');
const apiEndpoint = ref('');

// Provider helpers
const getProviderName = (source: string) => {
  switch (source) {
    case 'ollama': return 'Local';
    case 'openrouter': return 'Cloud';
    case 'google': return 'Google';
    case 'anthropic': return 'Anthropic';
    case 'openai': return 'OpenAI';
    default: return source;
  }
};

const getProviderVariant = (source: string) => {
  switch (source) {
    case 'ollama': return 'default';
    case 'openrouter': return 'secondary';
    case 'google': return 'outline';
    case 'anthropic': return 'secondary';
    case 'openai': return 'default';
    default: return 'default';
  }
};

// Computed
const filteredModels = computed(() => {
  return modelStore.getFilteredModels(activeProvider.value, searchQuery.value);
});

// Methods
const handleCustomProviderSubmit = () => {
  console.log('Connecting to custom provider:', {
    provider: customProvider.value,
    apiKey: apiKey.value,
    endpoint: apiEndpoint.value
  });
  apiKey.value = '';
  apiEndpoint.value = '';
  closeDropdown();
};

const navigateList = (direction: 'up' | 'down') => {
  const maxIndex = filteredModels.value.length - 1;
  if (direction === 'up') {
    highlightedIndex.value = highlightedIndex.value <= 0 ? maxIndex : highlightedIndex.value - 1;
  } else {
    highlightedIndex.value = highlightedIndex.value >= maxIndex ? 0 : highlightedIndex.value + 1;
  }
};

const selectHighlighted = () => {
  const model = filteredModels.value[highlightedIndex.value];
  if (model) {
    selectModel(model);
  }
};

const selectModel = (model: Model) => {
  modelStore.setSelectedModel(model);
  emit('select', model);
  closeDropdown();
};

const toggleDropdown = () => {
  isOpen.value = !isOpen.value;
  if (isOpen.value) {
    nextTick(() => {
      searchInput.value?.focus();
    });
  }
};

const closeDropdown = () => {
  isOpen.value = false;
  searchQuery.value = '';
  modelButton.value?.focus();
};

const focusModelSelector = () => {
  toggleDropdown();
};

// Lifecycle hooks
onMounted(async () => {
  await modelStore.initialize();
  document.addEventListener('keydown', handleGlobalKeydown);
});
onBeforeUnmount(() => {
  document.removeEventListener('keydown', handleGlobalKeydown);
});

const handleGlobalKeydown = (e: KeyboardEvent) => {
  // Check if the active element is an input, textarea, or contenteditable element
  const activeElement = document.activeElement;
  const isTyping = activeElement instanceof HTMLInputElement || 
                   activeElement instanceof HTMLTextAreaElement || 
                   activeElement?.getAttribute('contenteditable') === 'true';

  // Only handle 'M' shortcut if user is not typing
  if (e.key === 'm' && !isOpen.value && !isTyping) {
    e.preventDefault();
    focusModelSelector();
  }

  // These shortcuts should still work when the dropdown is open
  if (isOpen.value) {
    if (e.key === '/') {
      e.preventDefault();
      searchInput.value?.focus();
    }
    if (e.key === 'Escape') {
      closeDropdown();
    }
  }
};
</script>
=== END FILE: ./src/components/models/ModelSelector.vue ===


=== START FILE: ./src/components/canvas/clustermap/BottomSheetCluster.vue ===
=== TYPE: vue ===

<template>
  <div>
    <!-- Bottom Sheet Pull Tab -->
    <div 
      class="fixed bottom-0 left-1/2 -translate-x-1/2 w-24 h-1.5 rounded-full bg-base-300/50 cursor-pointer hover:bg-base-300 transition-colors mb-2"
      @mouseenter="handleShowSheet"
      @mouseleave="startHideTimer"
    />

    <!-- Bottom Sheet -->
    <div 
      class="fixed mx-4 left-0 right-0 bg-base-200/95 backdrop-blur border-t border-base-300 shadow-lg transition-all duration-300 ease-in-out rounded-t-lg"
      :class="[
        isOpen ? 'bottom-0' : '-bottom-[500px]',
        'transform'
      ]"
      :style="{ height: '500px' }"
      @mouseenter="handleShowSheet"
      @mouseleave="handleHideSheet"
    >
      <!-- Header -->
      <div class="flex items-center justify-between px-6 py-2 border-b border-base-300">
        <h3 class="text-lg font-medium">Topic Clusters</h3>
        <button 
          class="p-1.5 hover:bg-base-300 rounded-lg transition-colors"
          @click="handleHideSheet"
        >
          <span class="sr-only">Close</span>
          <XIcon class="w-5 h-5" />
        </button>
      </div>

      <!-- Content -->
      <div class="p-6 h-full">
        <TopicClusterViz 
          :width="vizWidth" 
          :height="400"
          :selected-topic="selectedTopic"
          @select-node="handleTopicSelect"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onBeforeUnmount } from 'vue';
import { XIcon } from 'lucide-vue-next';
import TopicClusterViz from './TopicClusterViz.vue';

const props = defineProps<{
  selectedTopic?: string;
}>();

const emit = defineEmits<{
  (e: 'select-topic', topicId: string): void;
}>();

const isOpen = ref(false);
const hideTimer = ref<number | null>(null);
const windowWidth = ref(window.innerWidth);

const vizWidth = computed(() => windowWidth.value - 80);

const handleShowSheet = () => {
  if (hideTimer.value) {
    clearTimeout(hideTimer.value);
    hideTimer.value = null;
  }
  isOpen.value = true;
};

const handleHideSheet = () => {
  isOpen.value = false;
};

const startHideTimer = () => {
  hideTimer.value = window.setTimeout(() => {
    if (!isOpen.value) return;
    handleHideSheet();
  }, 300);
};

const handleTopicSelect = (node: any) => {
  emit('select-topic', node.id);
};

onMounted(() => {
  const handleResize = () => {
    windowWidth.value = window.innerWidth;
  };
  
  window.addEventListener('resize', handleResize);
  
  onBeforeUnmount(() => {
    window.removeEventListener('resize', handleResize);
    if (hideTimer.value) {
      clearTimeout(hideTimer.value);
    }
  });
});
</script>

<style scoped>
.bottom-sheet-enter-active,
.bottom-sheet-leave-active {
  transition: transform 0.3s ease-in-out;
}

.bottom-sheet-enter-from,
.bottom-sheet-leave-to {
  transform: translateY(100%);
}
</style>
=== END FILE: ./src/components/canvas/clustermap/BottomSheetCluster.vue ===


=== START FILE: ./src/components/canvas/clustermap/TopicClusterViz.vue ===
=== TYPE: vue ===

<template>
    <div ref="containerRef" class="topic-cluster-viz h-full w-full">
        <!-- Granularity Toggle -->
        <div class="absolute top-4 left-4 z-10 flex gap-2">
            <button v-for="level in ['message', 'branch', 'workspace']" :key="level"
                class="px-3 py-1.5 text-sm rounded-full transition-colors" :class="[
                    granularity === level
                        ? 'bg-primary text-primary-foreground'
                        : 'bg-base-200/90 backdrop-blur hover:bg-base-300/90'
                ]" @click="granularity = level">
                {{ level.charAt(0).toUpperCase() + level.slice(1) }}
            </button>
        </div>

        <!-- Loading State -->
        <div v-if="isLoading"
            class="absolute inset-0 flex items-center justify-center bg-background/50 backdrop-blur z-20">
            <div class="loading loading-spinner loading-lg text-primary"></div>
        </div>

        <!-- Topic Labels Layer -->
        <div ref="labelRendererRef" class="absolute inset-0 pointer-events-none z-10"></div>
    </div>
</template>

<script setup lang="ts">
import { ref, shallowRef, onMounted, onBeforeUnmount, watch, nextTick } from 'vue';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';

interface Topic {
    id: string;
    label: string;
    score: number;
    messageCount: number;
    children?: Topic[];
}

interface Props {
    selectedTopic?: string;
}

const props = defineProps<Props>();
const emit = defineEmits<{
    (e: 'select-topic', topic: Topic): void;
}>();

// Refs
const containerRef = ref<HTMLDivElement | null>(null);
const labelRendererRef = ref<HTMLDivElement | null>(null);
const isLoading = ref(true);
const granularity = ref<'message' | 'branch' | 'workspace'>('workspace');

// Scene objects using shallowRef to avoid reactivity issues
const sceneObjects = shallowRef({
    scene: new THREE.Scene(),
    camera: null as THREE.PerspectiveCamera | null,
    renderer: null as THREE.WebGLRenderer | null,
    labelRenderer: null as CSS2DRenderer | null,
    controls: null as OrbitControls | null,
    topicObjects: new Map<string, {
        mesh: THREE.Mesh,
        label: CSS2DObject,
        position: THREE.Vector3,
        connections: THREE.Line[]
    }>(),
});

// Mock data - replace with real data fetching
const topics = ref<Topic[]>([
    {
        id: '1',
        label: 'React Components',
        score: 0.85,
        messageCount: 15,
        children: []
    },
    {
        id: '2',
        label: 'Neural Networks',
        score: 0.92,
        messageCount: 8,
        children: []
    }
]);

const initScene = () => {
    if (!containerRef.value || !labelRendererRef.value) return;

    const width = containerRef.value.clientWidth;
    const height = containerRef.value.clientHeight;

    // Scene setup with fog for depth effect
    sceneObjects.value.scene.background = new THREE.Color(0xf0f0f0);
    sceneObjects.value.scene.fog = new THREE.Fog(0xf0f0f0, 200, 800);

    // Camera
    sceneObjects.value.camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
    sceneObjects.value.camera.position.set(200, 100, 200);
    sceneObjects.value.camera.lookAt(0, 0, 0);

    // Renderer
    sceneObjects.value.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    sceneObjects.value.renderer.setSize(width, height);
    sceneObjects.value.renderer.setPixelRatio(window.devicePixelRatio);
    sceneObjects.value.renderer.shadowMap.enabled = true;
    containerRef.value.appendChild(sceneObjects.value.renderer.domElement);

    // Label renderer
    sceneObjects.value.labelRenderer = new CSS2DRenderer();
    sceneObjects.value.labelRenderer.setSize(width, height);
    sceneObjects.value.labelRenderer.domElement.style.position = 'absolute';
    sceneObjects.value.labelRenderer.domElement.style.top = '0';
    sceneObjects.value.labelRenderer.domElement.style.pointerEvents = 'none';
    labelRendererRef.value.appendChild(sceneObjects.value.labelRenderer.domElement);

    // Controls
    sceneObjects.value.controls = new OrbitControls(
        sceneObjects.value.camera,
        sceneObjects.value.renderer.domElement
    );
    sceneObjects.value.controls.enableDamping = true;
    sceneObjects.value.controls.dampingFactor = 0.05;
    sceneObjects.value.controls.enableZoom = true;
    sceneObjects.value.controls.enablePan = true;
    sceneObjects.value.controls.minDistance = 100;
    sceneObjects.value.controls.maxDistance = 500;
    sceneObjects.value.controls.maxPolarAngle = Math.PI / 1.5;
    sceneObjects.value.controls.autoRotate = true;
    sceneObjects.value.controls.autoRotateSpeed = 0.5;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    sceneObjects.value.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(200, 200, 200);
    directionalLight.castShadow = true;
    sceneObjects.value.scene.add(directionalLight);

    // Add subtle hemisphere light
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.2);
    sceneObjects.value.scene.add(hemiLight);
};

const handleResize = () => {
    if (!containerRef.value || !sceneObjects.value.camera || !sceneObjects.value.renderer || !sceneObjects.value.labelRenderer) return;

    const width = containerRef.value.clientWidth;
    const height = containerRef.value.clientHeight;

    sceneObjects.value.camera.aspect = width / height;
    sceneObjects.value.camera.updateProjectionMatrix();

    sceneObjects.value.renderer.setSize(width, height);
    sceneObjects.value.labelRenderer.setSize(width, height);
};

const createTopicSphere = (topic: Topic, index: number, total: number) => {
    const { scene } = sceneObjects.value;
    if (!scene || !containerRef.value) return;

    // Calculate sphere size based on score and message count
    const maxSize = 15;
    const minSize = 5;
    const size = minSize + (maxSize - minSize) * topic.score;

    // Create sphere with custom geometry
    const geometry = new THREE.SphereGeometry(size, 32, 32);
    const material = new THREE.MeshPhysicalMaterial({
        color: new THREE.Color().setHSL(index / total, 0.7, 0.6),
        transparent: true,
        opacity: 0.8,
        metalness: 0.2,
        roughness: 0.3,
        clearcoat: 0.4
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    // Calculate position on a 3D spiral
    const turns = 1;  // Number of turns around the spiral
    const heightScale = 100;  // Vertical scale of the spiral

    const theta = (index / total) * Math.PI * 2 * turns;
    const radius = 100 + (index / total) * 50;  // Increasing radius
    const y = ((index / total) - 0.5) * heightScale;

    const position = new THREE.Vector3(
        Math.cos(theta) * radius,
        y,
        Math.sin(theta) * radius
    );
    mesh.position.copy(position);

    // Create label
    const labelDiv = document.createElement('div');
    labelDiv.className = 'topic-label px-2 py-1 bg-base-200/90 backdrop-blur rounded text-sm pointer-events-auto cursor-pointer';
    labelDiv.textContent = `${topic.label} (${topic.messageCount})`;
    labelDiv.addEventListener('click', () => emit('select-topic', topic));

    const label = new CSS2DObject(labelDiv);
    label.position.set(0, size + 5, 0);
    mesh.add(label);

    scene.add(mesh);
    sceneObjects.value.topicObjects.set(topic.id, {
        mesh,
        label,
        position,
        connections: []
    });
};

const createConnections = () => {
    const { scene } = sceneObjects.value;
    if (!scene) return;

    // Create connections between topics
    topics.value.forEach((topic, i) => {
        if (i === 0) return;

        const startObj = sceneObjects.value.topicObjects.get(topics.value[i - 1].id);
        const endObj = sceneObjects.value.topicObjects.get(topic.id);

        if (startObj && endObj) {
            // Create curved connection
            const midPoint = new THREE.Vector3().addVectors(
                startObj.position,
                endObj.position
            ).multiplyScalar(0.5);

            // Add some height to the midpoint
            midPoint.y += 20;

            const curve = new THREE.QuadraticBezierCurve3(
                startObj.position,
                midPoint,
                endObj.position
            );

            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const material = new THREE.LineBasicMaterial({
                color: 0x999999,
                transparent: true,
                opacity: 0.3,
                linewidth: 1
            });

            const connection = new THREE.Line(geometry, material);
            scene.add(connection);

            // Store connection reference
            startObj.connections.push(connection);
            endObj.connections.push(connection);
        }
    });
};

const animate = () => {
    if (!sceneObjects.value.renderer || !sceneObjects.value.scene || !sceneObjects.value.camera) return;

    requestAnimationFrame(animate);

    if (sceneObjects.value.controls) {
        sceneObjects.value.controls.update();
    }

    sceneObjects.value.renderer.render(sceneObjects.value.scene, sceneObjects.value.camera);

    if (sceneObjects.value.labelRenderer) {
        sceneObjects.value.labelRenderer.render(sceneObjects.value.scene, sceneObjects.value.camera);
    }
};

// Lifecycle hooks
onMounted(async () => {
    await nextTick();
    initScene();

    // Create topic spheres
    topics.value.forEach((topic, index) => {
        createTopicSphere(topic, index, topics.value.length);
    });

    // Create connections after all spheres are created
    createConnections();

    // Start animation loop
    animate();

    // Add resize observer
    const resizeObserver = new ResizeObserver(handleResize);
    if (containerRef.value) {
        resizeObserver.observe(containerRef.value);
    }

    isLoading.value = false;

    // Cleanup
    onBeforeUnmount(() => {
        resizeObserver.disconnect();

        // Dispose of all Three.js objects
        sceneObjects.value.topicObjects.forEach((obj) => {
            obj.mesh.geometry.dispose();
            (obj.mesh.material as THREE.Material).dispose();
            obj.connections.forEach(connection => {
                connection.geometry.dispose();
                (connection.material as THREE.Material).dispose();
                sceneObjects.value.scene.remove(connection);
            });
            sceneObjects.value.scene.remove(obj.mesh);
        });

        sceneObjects.value.renderer?.dispose();
        sceneObjects.value.scene.clear();
    });
});

// Watch for topic selection
watch(() => props.selectedTopic, (newTopic) => {
    if (!newTopic || !sceneObjects.value.camera || !sceneObjects.value.controls) return;

    const selectedObject = sceneObjects.value.topicObjects.get(newTopic);
    if (selectedObject) {
        // Disable auto-rotation when focusing on a topic
        sceneObjects.value.controls.autoRotate = false;

        const targetPosition = selectedObject.position.clone();
        const distance = 100; // Distance to view from
        const offset = new THREE.Vector3(distance, distance / 2, distance);

        const duration = 1000;
        const startPosition = sceneObjects.value.camera.position.clone();
        const startTime = Date.now();

        const animateCamera = () => {
            const currentTime = Date.now();
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Smooth easing
            const easeProgress = 1 - Math.pow(1 - progress, 3);

            sceneObjects.value.camera!.position.lerpVectors(
                startPosition,
                targetPosition.clone().add(offset),
                easeProgress
            );

            sceneObjects.value.controls!.target.lerpVectors(
                sceneObjects.value.controls!.target,
                targetPosition,
                easeProgress
            );

            if (progress < 1) {
                requestAnimationFrame(animateCamera);
            } else {
                // Re-enable auto-rotation after animation
                setTimeout(() => {
                    if (sceneObjects.value.controls) {
                        sceneObjects.value.controls.autoRotate = true;
                    }
                }, 1000);
            }
        };

        animateCamera();
    }
});

// Watch for granularity changes
watch(granularity, (newGranularity) => {
    console.log(`Updating visualization for ${newGranularity} granularity`);
    // Here you would fetch and update topics based on granularity
});
</script>

<style scoped>
.topic-cluster-viz {
    position: relative;
    overflow: hidden;
    touch-action: none;
}

.topic-label {
    transition: all 0.2s ease;
    pointer-events: all;
    user-select: none;
    white-space: nowrap;
}

.topic-label:hover {
    transform: scale(1.1);
    background-color: rgb(var(--color-primary) / 0.1);
}

/* Ensure proper rendering of Three.js canvas */
:deep(canvas) {
    width: 100% !important;
    height: 100% !important;
    touch-action: none;
    outline: none;
}

/* Label renderer styling */
:deep(.css2drenderer) {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
}

/* Make labels interactive while keeping parent non-interactive */
:deep(.css2drenderer *) {
    pointer-events: all;
}

/* Ensure controls work properly */
:deep(.orbit-controls) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* GPU acceleration */
:deep(canvas),
.topic-cluster-viz {
    transform: translateZ(0);
    backface-visibility: hidden;
    perspective: 1000px;
}

/* Loading state */
.loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
</style>
=== END FILE: ./src/components/canvas/clustermap/TopicClusterViz.vue ===


=== START FILE: ./src/components/canvas/InfiniteCanvas.vue ===
=== TYPE: vue ===

<template>
  <div class="fixed overflow-hidden bg-background transition-all duration-300" :style="{
    left: sidePanelOpen ? '40vw' : '0',
    right: '0',
    top: '0',
    bottom: '0'
  }" @dragenter.prevent="handleDragEnter" @dragover.prevent="handleDragOver" @dragleave.prevent="handleDragLeave"
    @drop.prevent="handleDrop">

    <!-- Main Canvas -->
    <div ref="canvasRef" class="absolute inset-0 transition-transform duration-500 ease-in-out"
      @mousemove="handleMouseMove" @mouseup="handleMouseUp" @mouseleave="handleMouseUp"
      @mousedown="handleCanvasMouseDown" tabindex="0" @keydown="handleKeyDown">

      <!-- Canvas Transform Container -->
      <div class="absolute transform-gpu" :style="transformStyle"
        :class="{ 'transition-transform-overview': isWorkspaceOverview }">
        <!-- Overview Mode -->
        <template v-if="isWorkspaceOverview">
          <div class="absolute" :style="nodesLayerStyle">
            <div v-for="workspace in workspaces" :key="workspace.id"
              class="workspace-node relative p-6 bg-base-200/90 backdrop-blur rounded-xl border border-base-300 transition-all duration-500 hover:shadow-lg hover:-translate-y-1 cursor-pointer"
              :style="{
                position: 'absolute',
                left: `${workspace.x}px`,
                top: `${workspace.y}px`,
                transform: workspace.isExpanding ? 'scale(2)' : 'scale(1)',
                opacity: workspace.isExpanding ? 0 : 1,
                width: '300px'
              }" :data-workspace-id="workspace.id" @click="handleWorkspaceSelect(workspace)">
              <div class="text-lg font-semibold mb-2">
                {{ workspace.title }}
              </div>
              <div class="text-sm text-base-content/60 space-y-1">
                <div>
                  {{ workspace.nodeCount }} branches
                </div>
                <div>
                  Last updated: {{ new Date(workspace.lastUpdated).toLocaleString() }}
                </div>
              </div>
            </div>
          </div>
        </template>

        <!-- Detailed Workspace View -->
        <template v-else>
          <!-- SVG Layer for Connections -->
          <svg class="absolute pointer-events-none overflow-visible" style="z-index: 1" :style="svgStyle"
            viewBox="0 0 100000 100000" preserveAspectRatio="none">
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" class="fill-primary" />
              </marker>
            </defs>

            <template v-for="connection in store.connections" :key="`${connection.parent.id}-${connection.child.id}`">
              <SplineConnector :start-node="connection.parent" :end-node="connection.child"
                :card-width="store.CARD_WIDTH" :card-height="store.CARD_HEIGHT"
                :is-active="isConnectionActive(connection)" :zoom-level="zoom" />
            </template>
          </svg>

          <!-- Nodes Layer -->
          <div class="absolute" :style="nodesLayerStyle" style="z-index: 2">
            <template v-for="node in store.nodes" :key="node.id">
              <MediaBranchNode v-if="node.type === 'media'" :ref="(el) => { if (el) mediaNodesRef[node.id] = el }"
                :node="node" :is-selected="isNodeFocused(node.id)" :selected-model="selectedModel"
                :open-router-api-key="openRouterApiKey" :zoom="zoom" :model-registry="modelRegistry"
                @select="handleNodeSelect(node.id)" @drag-start="handleDragStart" @create-branch="handleCreateBranch"
                @update-title="store.updateNodeTitle"
                @resend="(userMessageIndex) => handleResend(node.id, userMessageIndex)"
                @delete="() => store.removeNode(node.id)" :style="{
                  transform: `translate(${node.x}px, ${node.y}px)`,
                  transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
                }" />

              <WebBranchNode v-else-if="node.type === 'web'" :node="node" :is-selected="isNodeFocused(node.id)"
                :selected-model="selectedModel" :open-router-api-key="openRouterApiKey" :zoom="zoom"
                :model-registry="modelRegistry" @select="handleNodeSelect(node.id)" @drag-start="handleDragStart"
                @create-branch="handleCreateBranch" @update-title="store.updateNodeTitle"
                @resend="(userMessageIndex) => handleResend(node.id, userMessageIndex)"
                @delete="() => store.removeNode(node.id)" :style="{
                  transform: `translate(${node.x}px, ${node.y}px)`,
                  transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
                }" />

              <BranchNode v-else :node="node" :is-selected="isNodeFocused(node.id)" :selected-model="selectedModel"
                :open-router-api-key="openRouterApiKey" :zoom="zoom" :model-registry="modelRegistry"
                @select="handleNodeSelect(node.id)" @drag-start="handleDragStart" @create-branch="handleCreateBranch"
                @update-title="store.updateNodeTitle"
                @resend="(userMessageIndex) => handleResend(node.id, userMessageIndex)"
                @delete="() => store.removeNode(node.id)" :style="{
                  transform: `translate(${node.x}px, ${node.y}px)`,
                  transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
                }" />
            </template>
          </div>
        </template>
      </div>
    </div>

    <!-- Overlays -->
    <div v-show="isDraggingFile"
      class="absolute inset-0 bg-primary/20 backdrop-blur-sm flex items-center justify-center pointer-events-none z-50">
      <div class="text-2xl font-semibold text-primary">
        Drop media to create a new node
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, nextTick, onMounted, onBeforeUnmount, watch } from 'vue';
import BranchNode from './node/BranchNode.vue';
import WebBranchNode from './node/WebBranchNode.vue';
import MediaBranchNode from './node/MediaBranchNode.vue';
import SplineConnector from './spline/SplineConnector.vue';
import { useCanvasStore } from '../../stores/canvasStore';
import { useChatStore } from '../../stores/chatStore';
// Add near the top with other refs
const modelRegistry = ref(new Map<string, ModelInfo>());

// Add the ModelInfo interface
interface ModelInfo {
  id: string;
  name: string;
  source: 'ollama' | 'openrouter' | 'custom';
  provider?: string;
}

const store = useCanvasStore();
const chatStore = useChatStore();
const canvasRef = ref(null);

// State
const props = defineProps({
  selectedModel: {
    type: String,
    required: true,
    default: ''
  },
  openRouterApiKey: {
    type: String,
    required: true
  },
  modelType: {
    type: String,
    required: true,
    default: ''
  },
  sidePanelOpen: {
    type: Boolean,
    required: true
  },
  autoZoomEnabled: {
    type: Boolean,
    required: true
  },
  zoom: {  // Add this prop definition
    type: Number,
    required: true,
    default: 1
  }
});


const emit = defineEmits(['update:zoom', 'update:autoZoomEnabled']);

// Modify zoom ref to be computed
const zoom = computed({
  get: () => props.zoom,
  set: (value) => emit('update:zoom', value)
});

// Modify autoZoomEnabled to use prop
watch(() => props.autoZoomEnabled, (newValue) => {
  if (newValue) {
    autoFitNodes();
  }
});

const panX = ref(0);
const panY = ref(0);
const isPanning = ref(false);
const lastPanPosition = ref({ x: 0, y: 0 });
const focusedNodeId = ref(null);
const focusedTopicId = ref<string | null>(null);
const isDraggingFile = ref(false);
const mediaNodesRef = ref<InstanceType<typeof MediaBranchNode>[]>([]);


const lastActivityTimestamp = ref(Date.now());
const autoZoomEnabled = ref(true);
const isAutoZooming = ref(false);
const AUTO_CENTER_DELAY = 30000; // 30 seconds
const inactivityTimer = ref(null);

const isClusterVizFocused = ref(false);
const windowSize = ref({
  width: typeof window !== 'undefined' ? window.innerWidth : 1920,
  height: typeof window !== 'undefined' ? window.innerHeight : 1080
});

const isWorkspaceOverview = ref(true);  // Whether we're showing workspaces list
const expandingWorkspaceId = ref<string | null>(null); // For transition animation
const workspaces = computed(() => chatStore.chats.map(chat => ({
  id: chat.id,
  title: chat.title,
  nodeCount: chat.nodeCount,
  lastUpdated: chat.updatedAt,
  x: chat.x || Math.random() * 1000, // We'll need to store/persist positions
  y: chat.y || Math.random() * 1000,
  isExpanding: expandingWorkspaceId.value === chat.id
})));

const isBrowser = typeof window !== 'undefined';

const isFocusedMode = ref(true);
const rootNodeId = ref<string | null>(null);


// Helper Functions
const getNodeCenter = (node) => ({
  x: node.x + store.CARD_WIDTH / 2,
  y: node.y + store.CARD_HEIGHT / 2
});


// Modify the existing transformStyle computed property
const transformStyle = computed(() => {
  if (isWorkspaceOverview.value) {
    return {
      transform: `scale(1) translate(0, 0)`,
      transformOrigin: '0 0',
      transition: 'transform 0.3s ease-out'
    };
  }

  if (isFocusedMode.value && rootNodeId.value) {
    // In focused mode, center the root node and make it 75% of viewport
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const nodeWidth = store.CARD_WIDTH;
    const nodeHeight = store.CARD_HEIGHT;

    // Calculate scale to fit 75% of viewport while maintaining aspect ratio
    const scaleX = (vw * 0.75) / nodeWidth;
    const scaleY = (vh * 0.75) / nodeHeight;
    const scale = Math.min(scaleX, scaleY);

    // Center the node
    const translateX = (vw - nodeWidth * scale) / 2;
    const translateY = (vh - nodeHeight * scale) / 2;

    return {
      transform: `translate(${translateX}px, ${translateY}px) scale(${scale})`,
      transformOrigin: '0 0',
      transition: 'transform 0.3s ease-out'
    };
  }

  // Regular canvas transform for non-focused mode
  return {
    transform: `scale(${zoom.value}) translate(${panX.value / zoom.value}px, ${panY.value / zoom.value}px)`,
    transformOrigin: '0 0',
    width: '100000px',
    height: '100000px',
    transition: store.isTransitioning ? 'transform 0.3s ease-out' : 'none'
  };
});

const svgStyle = computed(() => ({
  width: '100000px',
  height: '100000px'
}));

const nodesLayerStyle = computed(() => ({
  width: '100000px',
  height: '100000px',
  left: 0,
  top: 0
}));


const handleNodeSelect = (nodeId: string) => {
  centerOnNode(nodeId);
  focusedNodeId.value = nodeId;
};

const handleWheel = (e) => {
  resetInactivityTimer();
  // If it's a zoom event (Ctrl/Cmd + wheel)
  if (e.metaKey || e.ctrlKey) {
    e.preventDefault();

    const ZOOM_SENSITIVITY = 0.001;
    const ZOOM_MIN = 0.1;
    const ZOOM_MAX = 5;

    const rect = canvasRef.value.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const mouseContentX = (mouseX - panX.value) / zoom.value;
    const mouseContentY = (mouseY - panY.value) / zoom.value;

    const delta = -e.deltaY;
    const newZoom = Math.min(
      Math.max(zoom.value * (1 + delta * ZOOM_SENSITIVITY), ZOOM_MIN),
      ZOOM_MAX
    );

    zoom.value = newZoom;
    panX.value = mouseX - mouseContentX * newZoom;
    panY.value = mouseY - mouseContentY * newZoom;
  } else {
    panX.value -= e.deltaX;
    panY.value -= e.deltaY;
  }
};

const centerCanvas = () => {
  zoom.value = 1;
  panX.value = 0;
  panY.value = 0;
}

onMounted(() => {
  if (isBrowser) {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('dragenter', handleDragEnter);
    window.addEventListener('dragleave', handleDragLeave);
    if (canvasRef.value) {
      canvasRef.value.addEventListener('wheel', handleWheel, { passive: false });
    }

    if (store.nodes.length) {

      centerCanvas();

    }

    resetInactivityTimer();
  }
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyDown);
  window.removeEventListener('dragenter', handleDragEnter);
  window.removeEventListener('dragleave', handleDragLeave);
  if (canvasRef.value) {
    canvasRef.value.removeEventListener('wheel', handleWheel);
  }
  if (inactivityTimer.value) {
    clearTimeout(inactivityTimer.value);
  }
});

watch(() => store.nodes.length, () => {
  resetInactivityTimer();
});

watch(() => store.nodes.length, (newLength, oldLength) => {
  if (newLength === 1 && oldLength === 0) {
    rootNodeId.value = store.nodes[0].id;
  }
});

const handleDragEnter = (e: DragEvent) => {
  e.preventDefault();
  e.stopPropagation();

  // Check for both files and URLs
  if (e.dataTransfer?.types.includes('Files') || e.dataTransfer?.types.includes('text/uri-list')) {
    isDraggingFile.value = true;
    console.log('Drag enter with file or URL');
  }
};

const handleDragOver = (e: DragEvent) => {
  e.preventDefault();
  e.stopPropagation();

  // Set dropEffect to 'copy' to indicate we'll copy the file
  if (e.dataTransfer) {
    e.dataTransfer.dropEffect = 'copy';
  }
};


const handleWorkspaceSelect = (workspace: { id: string }) => {
  // Start expansion animation
  expandingWorkspaceId.value = workspace.id;
  isWorkspaceOverview.value = false;

  // Calculate the workspace node's current center position
  const workspaceNode = document.querySelector(
    `[data-workspace-id="${workspace.id}"]`
  );
  const rect = workspaceNode?.getBoundingClientRect();
  if (!rect) return;

  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;

  // Animate canvas to center on this point
  const targetScale = 2;
  const duration = 500;
  const startPosition = {
    x: panX.value,
    y: panY.value,
    scale: zoom.value
  };

  // Animation frame
  const animate = (progress: number) => {
    const easeProgress = 1 - Math.pow(1 - progress, 3); // Cubic ease out

    zoom.value = startPosition.scale +
      (targetScale - startPosition.scale) * easeProgress;

    panX.value = startPosition.x +
      (centerX - startPosition.x) * easeProgress;
    panY.value = startPosition.y +
      (centerY - startPosition.y) * easeProgress;
  };

  // Run animation
  store.isTransitioning = true;
  const startTime = Date.now();

  const tick = () => {
    const progress = Math.min(1, (Date.now() - startTime) / duration);
    animate(progress);

    if (progress < 1) {
      requestAnimationFrame(tick);
    } else {
      // Animation complete - load workspace
      store.loadChatState(workspace.id).then(() => {
        store.isTransitioning = false;
      });
    }
  };
  requestAnimationFrame(tick);
};

const returnToOverview = () => {
  console.log('Returning to overview');
  isWorkspaceOverview.value = true;

  // Refresh the chat list so the overview has up-to-date data
  chatStore.loadChats();

  // Reset pan/zoom
  zoom.value = 1;
  panX.value = 0;
  panY.value = 0;

  // Then auto-fit so the random positions get centered nicely
  nextTick(() => {
    autoFitNodes();
  });
};

const handleDragLeave = (e: DragEvent) => {
  e.preventDefault();
  e.stopPropagation();

  // Only hide overlay if leaving the canvas container
  const rect = e.currentTarget?.getBoundingClientRect();
  if (rect) {
    const { clientX, clientY } = e;
    if (
      clientX <= rect.left ||
      clientX >= rect.right ||
      clientY <= rect.top ||
      clientY >= rect.bottom
    ) {
      isDraggingFile.value = false;
      console.log('Drag leave canvas');
    }
  }
};
const handleDrop = async (e: DragEvent) => {
  e.preventDefault();
  e.stopPropagation();

  isDraggingFile.value = false;
  console.log('Drop event:', {
    selectedModel: props.selectedModel,
    modelType: props.modelType,
    apiKey: !!props.openRouterApiKey
  });

  // Calculate drop position in canvas coordinates first since we'll need it for both cases
  const rect = canvasRef.value?.getBoundingClientRect();
  if (!rect) {
    console.log('No canvas rect found');
    return;
  }

  const x = (e.clientX - rect.left - panX.value) / zoom.value;
  const y = (e.clientY - rect.top - panY.value) / zoom.value;

  // Check for URL first
  const url = e.dataTransfer?.getData('text/uri-list') || e.dataTransfer?.getData('text/plain');
  if (url && url.startsWith('http')) {
    console.log('URL dropped:', url);

    // Create new web node
    const newNode = store.addNode(null, -1, { x, y }, {
      type: 'web',
      title: url,
      url: url
    });

    // Center on new node
    centerOnNode(newNode.id);
    return;
  }

  // If not URL, check for files
  const files = e.dataTransfer?.files;
  if (!files?.length) {
    console.log('No files or URLs in drop');
    return;
  }

  const file = files[0];
  console.log('File type:', file.type);

  if (!file.type.startsWith('image/') && !file.type.startsWith('video/')) {
    console.log('Invalid file type:', file.type);
    alert('Only image and video files are supported');
    return;
  }

  console.log('Creating media node at', { x, y });

  // Create new media node
  const newNode = store.addNode(null, -1, { x, y }, {
    type: 'media',
    title: file.name
  });

  // Wait for next tick to ensure refs are updated
  await nextTick();

  // Get the media node instance from our ref
  const mediaNode = mediaNodesRef.value[newNode.id];
  if (!mediaNode) {
    console.error('Media node not found after creation');
    store.removeNode(newNode.id);
    return;
  }

  try {
    const apiType = props.selectedModel.includes('gemini') ? 'gemini' :
      props.selectedModel.includes('/') && !props.selectedModel.includes('gemini') ? 'openrouter' : 'ollama';

    console.log('Processing media with:', {
      apiType,
      model: props.selectedModel
    });

    // Get the correct API key based on the API type
    const apiKey = apiType === 'gemini'
      ? localStorage.getItem('geminiApiKey')  // Use Gemini API key for Gemini models
      : props.openRouterApiKey;               // Use OpenRouter API key for OpenRouter models

    // Process the media file
    await mediaNode.processMedia(
      file,
      apiType,
      apiKey
    );

    // Center on new node
    centerOnNode(newNode.id);

  } catch (error) {
    console.error('Error processing media:', error);
    store.removeNode(newNode.id);
    alert('Failed to process media file');
  }
};

const centerOnNode = (nodeId) => {
  const node = store.nodes.find(n => n.id === nodeId);
  if (!node) return;

  store.isTransitioning = true;
  const center = getNodeCenter(node);

  const rect = canvasRef.value.getBoundingClientRect();

  // Calculate horizontal centering as before
  panX.value = (rect.width / 2) - (center.x * zoom.value);

  // Add vertical offset to account for input window
  // Move the node up by 20% of viewport height
  const verticalOffset = rect.height * 0.2;
  panY.value = (rect.height / 2) - (center.y * zoom.value) + verticalOffset;

  focusedNodeId.value = nodeId;

  setTimeout(() => {
    store.isTransitioning = false;
  }, 300);
};

const handleCreateBranch = (parentId: string, messageIndex: number, position: { x: number, y: number }, initialData: any) => {
  // Exit focused mode when creating a branch
  isFocusedMode.value = false;

  // Existing branch creation logic...
  const parentNode = store.nodes.find(n => n.id === parentId);
  if (!parentNode) return;

  const existingBranches = store.nodes.filter(n => n.parentId === parentId);
  const verticalOffset = existingBranches.length * (store.CARD_HEIGHT + 20);

  const adjustedPosition = {
    x: position.x,
    y: parentNode.y + verticalOffset
  };

  // Create the new node
  const newNode = store.addNode(parentId, messageIndex, adjustedPosition, {
    ...initialData,
    // Ensure vertical offset is preserved in node data
    y: adjustedPosition.y
  });

  // First center on the new node
  centerOnNode(newNode.id);

  // After creating branch, fit all nodes in view
  setTimeout(() => {
    autoFitNodes();
  }, 400);
};

const handleResend = async (nodeId: string, userMessageIndex: number) => {
  const node = store.nodes.find(n => n.id === nodeId);
  if (!node || !node.messages) return;

  const userMsg = node.messages[userMessageIndex];
  if (!userMsg || userMsg.role !== 'user') return;

  // Remove the AI response that follows this user message
  store.removeMessage(nodeId, userMessageIndex + 1);

  // Set up model info in registry before sending
  let modelInfo: ModelInfo;
  if (props.selectedModel === 'custom_model') {
    modelInfo = {
      id: 'custom_model',
      name: 'Custom Model',
      source: 'custom'
    };
  } else {
    modelInfo = {
      id: props.selectedModel,
      name: props.selectedModel.includes('/') ? props.selectedModel.split('/')[1] : props.selectedModel,
      source: props.modelType === 'ollama' ? 'ollama' : 'openrouter',
      provider: props.modelType === 'openrouter' ? props.selectedModel.split('/')[0] : undefined
    };
  }

  modelRegistry.value.set(props.selectedModel, modelInfo);

  // Pass false for addUserMessage since we're reusing the existing message
  await store.sendMessage(nodeId, userMsg.content, props.selectedModel, props.openRouterApiKey, false);
};

const findNodeInDirection = (currentNode, connections, direction) => {
  const connectedNodes = connections
    .filter(conn =>
      conn.parent.id === currentNode.id ||
      conn.child.id === currentNode.id
    )
    .map(conn =>
      conn.parent.id === currentNode.id ? conn.child : conn.parent
    );

  const currentCenter = getNodeCenter(currentNode);

  return connectedNodes
    .filter(node => {
      const nodeCenter = getNodeCenter(node);
      return direction === 'up'
        ? nodeCenter.y < currentCenter.y
        : nodeCenter.y > currentCenter.y;
    })
    .sort((a, b) => {
      const aCenter = getNodeCenter(a);
      const bCenter = getNodeCenter(b);
      const aDist = Math.abs(aCenter.y - currentCenter.y);
      const bDist = Math.abs(bCenter.y - currentCenter.y);
      return aDist - bDist;
    })[0]?.id;
};


const handleMouseUp = () => {
  store.isDragging = false;
  store.activeNode = null;
  isPanning.value = false;
};

const handleCanvasMouseDown = (e) => {
  if (e.button === 0 && !store.isDragging) {
    isPanning.value = true;
    lastPanPosition.value = { x: e.clientX - panX.value, y: e.clientY - panY.value };
  }
};

const handleKeyDown = (e) => {
  if (store.isTransitioning) return;

  if (e.key === 'Escape' && isClusterVizFocused.value) {
    unfocusClusterViz();
    return;
  }

  const currentNode = store.nodes.find(n => n.id === focusedNodeId.value);
  if (!currentNode) return;

  const connections = store.connections;
  let targetNodeId = null;

  switch (e.key) {
    case 'ArrowUp':
      targetNodeId = findNodeInDirection(currentNode, connections, 'up');
      break;
    case 'ArrowDown':
      targetNodeId = findNodeInDirection(currentNode, connections, 'down');
      break;
    case 'ArrowRight':
      targetNodeId = currentNode.parentId;
      break;
    case 'ArrowLeft':
      targetNodeId = connections
        .find(conn => conn.parent.id === currentNode.id)?.child.id;
      break;
  }

  if (targetNodeId) {
    centerOnNode(targetNodeId);
  }
};

const handleClusterVizClick = (e: MouseEvent) => {
  if (!isClusterVizFocused.value) {
    e.stopPropagation();

    store.isTransitioning = true;
    isClusterVizFocused.value = true;
    isPanning.value = false;
    store.isDragging = false;
  }
};


const unfocusClusterViz = () => {
  // First step: Start unfocus transition
  store.isTransitioning = true;

  // Second step: Unfocus
  isClusterVizFocused.value = false;
  focusedTopicId.value = null;

  // Third step: After transition, re-enable canvas and reset
  setTimeout(() => {
    store.isTransitioning = false;
    autoFitNodes();
  }, 700); // Match the transition duration
};

// Event Handlers
const calculateNodesBounds = () => {
  if (!store.nodes.length) return null;

  const bounds = store.nodes.reduce((acc, node) => {
    const nodeWidth = store.CARD_WIDTH;
    const nodeHeight = store.CARD_HEIGHT;

    return {
      minX: Math.min(acc.minX, node.x),
      maxX: Math.max(acc.maxX, node.x + nodeWidth),
      minY: Math.min(acc.minY, node.y),
      maxY: Math.max(acc.maxY, node.y + nodeHeight)
    };
  }, {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  });

  return bounds;
};

// Function to auto-center and zoom to fit all nodes
const autoFitNodes = () => {
  if (!canvasRef.value || !autoZoomEnabled.value || store.isDragging || isPanning.value) return;

  const bounds = calculateNodesBounds();
  if (!bounds) return;

  const rect = canvasRef.value.getBoundingClientRect();
  const padding = 100; // Padding around the nodes

  // Calculate required zoom to fit all nodes
  const contentWidth = bounds.maxX - bounds.minX + (padding * 2);
  const contentHeight = bounds.maxY - bounds.minY + (padding * 2);
  const scaleX = rect.width / contentWidth;
  const scaleY = rect.height / contentHeight;
  const newZoom = Math.min(scaleX, scaleY, 1); // Cap zoom at 1 to prevent too much zoom

  // Calculate center point of all nodes
  const centerX = (bounds.minX + bounds.maxX) / 2;
  const centerY = (bounds.minY + bounds.maxY) / 2;

  isAutoZooming.value = true;
  store.isTransitioning = true;

  // Animate to new position and zoom
  zoom.value = newZoom;
  panX.value = (rect.width / 2) - (centerX * newZoom);
  panY.value = (rect.height / 2) - (centerY * newZoom);

  setTimeout(() => {
    isAutoZooming.value = false;
    store.isTransitioning = false;
  }, 300);
};


defineExpose({
  autoFitNodes,
  isWorkspaceOverview,
  returnToOverview
});

// Function to reset inactivity timer
const resetInactivityTimer = () => {
  if (inactivityTimer.value) {
    clearTimeout(inactivityTimer.value);
  }

  lastActivityTimestamp.value = Date.now();

  inactivityTimer.value = setTimeout(() => {
    if (Date.now() - lastActivityTimestamp.value >= AUTO_CENTER_DELAY) {
      autoFitNodes();
    }
  }, AUTO_CENTER_DELAY);
};


const handleMouseMove = (e) => {
  if (isClusterVizFocused.value) return;
  resetInactivityTimer();

  if (store.isDragging && store.activeNode) {
    // Handle node dragging
    const canvasRect = canvasRef.value.getBoundingClientRect();

    // Calculate the new position in canvas space
    const canvasX = (e.clientX - canvasRect.left - panX.value) / zoom.value;
    const canvasY = (e.clientY - canvasRect.top - panY.value) / zoom.value;

    // Update node position accounting for the initial click offset
    store.updateNodePosition(store.activeNode, {
      x: canvasX - store.dragOffset.x,
      y: canvasY - store.dragOffset.y
    });
  } else if (isPanning.value) {
    // Handle canvas panning
    const dx = e.clientX - lastPanPosition.value.x;
    const dy = e.clientY - lastPanPosition.value.y;
    panX.value = dx;
    panY.value = dy;
  }
};

const handleDragStart = (e, node) => {
  store.isDragging = true;
  store.activeNode = node.id;

  const canvasRect = canvasRef.value.getBoundingClientRect();

  // Calculate the initial click position in canvas space
  const canvasX = (e.clientX - canvasRect.left - panX.value) / zoom.value;
  const canvasY = (e.clientY - canvasRect.top - panY.value) / zoom.value;

  // Calculate offset from the node's position
  store.dragOffset = {
    x: canvasX - node.x,
    y: canvasY - node.y
  };
};

const handleTopicSelect = (topicId: string) => {
  focusedTopicId.value = topicId;
  centerOnNode(topicId);
};

// Active State Checks
const isNodeFocused = (nodeId) => focusedNodeId.value === nodeId;

const isConnectionActive = (connection) => {
  if (!focusedNodeId.value) return false;
  return connection.parent.id === focusedNodeId.value ||
    connection.child.id === focusedNodeId.value;
};

// Lifecycle
onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
  canvasRef.value?.focus();

  if (store.nodes.length) {
    centerOnNode(store.nodes[0].id);
  }
});

onBeforeUnmount(() => {
  window.removeEventListener('keydown', handleKeyDown);
});
</script>

<style scoped>
/* GPU Acceleration */
.transform-gpu {
  transform: translate3d(0, 0, 0);
  backface-visibility: hidden;
  perspective: 1000px;
  overflow: hidden;
}

/* Layout & Positioning */
.fixed {
  overflow: hidden;
  z-index: 40;
}

.absolute {
  overflow: visible;
}

/* Basic Transitions */
.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 500ms;
}

.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 300ms;
}

/* Focus States */
div:focus {
  outline: none;
}

div:focus-visible {
  outline: none;
  box-shadow: inset 0 0 0 2px rgba(37, 99, 235, 0.1);
}

/* Canvas Controls */
.canvas-control {
  position: fixed;
  padding: 0.375rem 0.75rem;
  background-color: rgb(var(--color-base-200) / 0.9);
  backdrop-filter: blur(4px);
  border-radius: 9999px;
  border: 1px solid rgb(var(--color-base-300));
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
}

.canvas-control:hover {
  background-color: rgb(var(--color-base-300) / 0.9);
}

/* Transform Utilities */
.will-change-transform {
  will-change: transform;
}

.transform-smooth {
  transition: transform 0.3s ease-out;
}

/* Container Styles */
.canvas-container {
  position: relative;
  width: 100%;
  height: 100%;
  touch-action: none;
  user-select: none;
}

/* SVG Layer */
.svg-layer {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 1;
}

/* Node Layer */
.node-layer {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2;
}

/* Animation States */
.enter-active,
.leave-active {
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.enter-from,
.leave-to {
  opacity: 0;
  transform: scale(0.95);
}

/* Performance Optimizations */
.hardware-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
}


.media-drop-overlay {
  pointer-events: none;
  z-index: 100;
}

/* Add these to ensure drag events are captured properly */
.fixed {
  touch-action: none;
}

[draggable="true"] {
  cursor: move;
}

/* Transition for Overview and Detailed Views */
.transition-transform-overview {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 500ms;
}
</style>
=== END FILE: ./src/components/canvas/InfiniteCanvas.vue ===


=== START FILE: ./src/components/canvas/spline/SplineConnector.vue ===
=== TYPE: vue ===

<template>
  <g>
    <!-- Main dashed path -->
    <path :d="pathData" :stroke="isActive ? '#2563eb' : '#94a3b8'" :stroke-width="strokeWidth" fill="none"
      :stroke-dasharray="dashPattern" class="transition-all duration-200" opacity="0.4" />

    <!-- Particles with scaled radius -->
    <g v-for="particle in particles" :key="particle.id">
      <circle :cx="particle.x" :cy="particle.y" :r="particleRadius" :fill="isActive ? '#2563eb' : '#94a3b8'">
        <animate attributeName="opacity" values="1;0.3;1" :dur="particle.duration" repeatCount="indefinite" />
      </circle>
    </g>


    <!-- Hidden path for text alignment -->
    <path :id="`connection-path-${startNode.id}-${endNode.id}`" :d="isLeftBranch ? reversedPathData : pathData"
      fill="none" stroke="none" />

    <!-- Label Container -->
    <g class="label-container">
      <text class="text-container">
        <textPath :href="`#connection-path-${startNode.id}-${endNode.id}`" startOffset="50%" text-anchor="middle"
          :side="isLeftBranch ? 'right' : 'left'" :class="{ 'reversed': isLeftBranch }">
          <tspan :dy="-12" class="label-text" :style="labelStyle">
            <tspan @dblclick.stop.prevent="handleLabelDoubleClick" class="label-background" v-if="!isEditing">
              {{ getLabelText() }}
            </tspan>
          </tspan>
        </textPath>
      </text>

      <!-- Edit Input -->
      <foreignObject v-if="isEditing" :x="calculateLabelPosition().x" :y="calculateLabelPosition().y"
        :width="300 / Math.min(1, zoomLevel)" :height="50 / Math.min(1, zoomLevel)" @dblclick.stop.prevent>
        <div xmlns="http://www.w3.org/2000/svg" class="flex items-center justify-center w-full h-full">
          <input ref="inputRef" v-model="labelInput" @blur="handleLabelBlur" @keydown="handleKeyDown"
            class="bg-base-100 border border-base-300 rounded px-3 py-2 text-center w-full" :style="inputStyle" />
        </div>
      </foreignObject>
    </g>
  </g>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue';

const props = defineProps({
  startNode: {
    type: Object,
    required: true
  },
  endNode: {
    type: Object,
    required: true
  },
  cardWidth: {
    type: Number,
    required: true
  },
  cardHeight: {
    type: Number,
    required: true
  },
  isActive: {
    type: Boolean,
    default: false
  },
  zoomLevel: {
    type: Number,
    default: 1
  }
});

// State
const isEditing = ref(false);
const labelInput = ref('');
const customLabel = ref('');
const inputRef = ref(null);
const particles = ref([]);
let animationFrame = null;

// Constants

const baseStroke = 1.5;
const baseFontSize = 14;
const baseParticleRadius = 3;
const baseParticleSpeed = 0.002;
const numParticles = 4;

const strokeWidth = computed(() => {
  const scale = 1 / Math.pow(props.zoomLevel, 1.2); // More aggressive scaling
  return baseStroke * Math.min(scale, 4); // Increased max scale
});

// Enhanced scaling for dash pattern
const dashPattern = computed(() => {
  const scale = 1 / Math.pow(props.zoomLevel, 1.2);
  const dash = 4 * Math.min(scale, 4);
  const gap = 6 * Math.min(scale, 4);
  return `${dash} ${gap}`;
});

// Enhanced scaling for particles
const particleRadius = computed(() => {
  const scale = 1 / Math.pow(props.zoomLevel, 1.2);
  return baseParticleRadius * Math.min(scale, 4);
});

// First, update the animateParticles function to correctly calculate control points
const animateParticles = () => {
  const { startPoint, endPoint } = calculateConnectionPoints();
  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  // Use the same curve calculations as the main path
  const controlPointDistance = Math.min(distance * 0.8, 200);
  const verticalOffset = Math.min(Math.abs(dy), 100) * (dy < 0 ? -1 : 1);
  
  const controlPoint1 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y + verticalOffset
  };

  const controlPoint2 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y - verticalOffset
  };

  // Get current base speed based on zoom level
  const baseSpeed = getParticleSpeed();

  particles.value = particles.value.map(particle => {
    // Update particle speed based on current zoom level while maintaining relative randomness
    const relativeSpeedFactor = particle.speed / (particle.speed - (Math.random() * particle.speed * 0.5));
    const newSpeed = baseSpeed + (Math.random() * baseSpeed * 0.5);
    particle.speed = newSpeed * relativeSpeedFactor;

    // Update progress with new speed
    particle.progress += particle.speed;
    if (particle.progress > 1) {
      particle.progress = 0;
    }

    // Get point on curve using the updated control points
    const t = particle.progress;
    const t1 = 1 - t;
    const point = {
      x: Math.pow(t1, 3) * startPoint.x +
         3 * Math.pow(t1, 2) * t * controlPoint1.x +
         3 * t1 * Math.pow(t, 2) * controlPoint2.x +
         Math.pow(t, 3) * endPoint.x,
      y: Math.pow(t1, 3) * startPoint.y +
         3 * Math.pow(t1, 2) * t * controlPoint1.y +
         3 * t1 * Math.pow(t, 2) * controlPoint2.y +
         Math.pow(t, 3) * endPoint.y
    };

    return {
      ...particle,
      x: point.x,
      y: point.y
    };
  });

  animationFrame = requestAnimationFrame(animateParticles);
};

// Update the getParticleSpeed function to adjust for the longer curve
const getParticleSpeed = () => {
  const scale = 1 / Math.max(0.3, props.zoomLevel);
  // Reduce base speed since the curve is longer
  return (baseParticleSpeed * 0.7) * Math.min(scale, 2);
};

// Adjust the number of particles and their initialization
const initializeParticles = () => {
  const newParticles = [];
  const baseSpeed = getParticleSpeed();
  
  // Increase number of particles since the curve is longer
  const adjustedNumParticles = Math.ceil(numParticles * 1.5);

  for (let i = 0; i < adjustedNumParticles; i++) {
    newParticles.push({
      id: i,
      progress: i / adjustedNumParticles,
      speed: baseSpeed + (Math.random() * baseSpeed * 0.5),
      duration: `${0.8 + Math.random() * 0.4}s`
    });
  }
  particles.value = newParticles;
};

const fontSize = computed(() => {
  const scaleFactor = 1 / Math.min(1, props.zoomLevel);
  return Math.max(baseFontSize * scaleFactor, baseFontSize);
});

const isLeftBranch = computed(() => {
  return props.endNode.type === 'left-branch';
});

const labelStyle = computed(() => ({
  fontSize: `${fontSize.value}px`,
  fontWeight: 500
}));

const inputStyle = computed(() => ({
  fontSize: `${fontSize.value}px`,
  fontWeight: 500,
  transform: `scale(${1 / props.zoomLevel})`,
  transformOrigin: 'center'
}));

// Path calculations
const calculateConnectionPoints = () => {
  const messageIndex = props.endNode.branchMessageIndex || 0;
  const messageYOffset = messageIndex * 120 + 40;
  const startOffset = 1;

  const startPoint = {
    x: isLeftBranch.value
      ? props.startNode.x - startOffset
      : props.startNode.x + props.cardWidth + startOffset,
    y: props.startNode.y + messageYOffset
  };

  const endPoint = {
    x: props.endNode.x + (isLeftBranch.value ? props.cardWidth : 0),
    y: props.endNode.y + props.cardHeight / 2
  };

  return { startPoint, endPoint };
};
// Find the pathData computed property and replace it with this enhanced version
const pathData = computed(() => {
  const { startPoint, endPoint } = calculateConnectionPoints();

  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  // Increase the control point distance significantly
  const controlPointDistance = Math.min(distance * 0.8, 200);
  
  // Add vertical offset to control points to create more curve
  const verticalOffset = Math.min(Math.abs(dy), 100) * (dy < 0 ? -1 : 1);
  
  const controlPoint1 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y + verticalOffset
  };

  const controlPoint2 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y - verticalOffset
  };

  return `M ${startPoint.x} ${startPoint.y} 
          C ${controlPoint1.x} ${controlPoint1.y},
            ${controlPoint2.x} ${controlPoint2.y},
            ${endPoint.x} ${endPoint.y}`;
});

// Also update the reversedPathData computed property for consistency
const reversedPathData = computed(() => {
  const { startPoint, endPoint } = calculateConnectionPoints();

  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  // Use the same enhanced curving logic
  const controlPointDistance = Math.min(distance * 0.8, 200);
  const verticalOffset = Math.min(Math.abs(dy), 100) * (dy < 0 ? -1 : 1);

  const controlPoint1 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y - verticalOffset
  };

  const controlPoint2 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y + verticalOffset
  };

  return `M ${endPoint.x} ${endPoint.y} 
          C ${controlPoint1.x} ${controlPoint1.y},
            ${controlPoint2.x} ${controlPoint2.y},
            ${startPoint.x} ${startPoint.y}`;
});

// Update the getPointOnCurve function to match the new curving logic
const getPointOnCurve = (t, startPoint, endPoint) => {
  const dx = endPoint.x - startPoint.x;
  const dy = endPoint.y - startPoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  const controlPointDistance = Math.min(distance * 0.8, 200);
  const verticalOffset = Math.min(Math.abs(dy), 100) * (dy < 0 ? -1 : 1);
  
  const controlPoint1 = {
    x: startPoint.x + (isLeftBranch.value ? -controlPointDistance : controlPointDistance),
    y: startPoint.y + verticalOffset
  };

  const controlPoint2 = {
    x: endPoint.x + (isLeftBranch.value ? controlPointDistance : -controlPointDistance),
    y: endPoint.y - verticalOffset
  };

  const t1 = 1 - t;
  return {
    x: Math.pow(t1, 3) * startPoint.x +
      3 * Math.pow(t1, 2) * t * controlPoint1.x +
      3 * t1 * Math.pow(t, 2) * controlPoint2.x +
      Math.pow(t, 3) * endPoint.x,
    y: Math.pow(t1, 3) * startPoint.y +
      3 * Math.pow(t1, 2) * t * controlPoint1.y +
      3 * t1 * Math.pow(t, 2) * controlPoint2.y +
      Math.pow(t, 3) * endPoint.y
  };
};

onMounted(() => {
  initializeParticles();
  animateParticles();
});

onUnmounted(() => {
  if (animationFrame) {
    cancelAnimationFrame(animationFrame);
  }
});

// Label position calculation
const calculateLabelPosition = () => {
  const { startPoint, endPoint } = calculateConnectionPoints();
  const midX = startPoint.x + (endPoint.x - startPoint.x) / 2;
  const midY = startPoint.y + (endPoint.y - startPoint.y) / 2;

  return {
    x: midX - (150 / Math.min(1, props.zoomLevel)),
    y: midY - (25 / Math.min(1, props.zoomLevel))
  };
};

// Label text handling
const getLabelText = () => {
  if (customLabel.value) {
    return customLabel.value;
  }

  const messageIndex = props.endNode.branchMessageIndex;
  const message = props.startNode.messages?.[messageIndex];

  if (message?.content) {
    const words = message.content.split(' ').slice(0, 3).join(' ');
    return words.length > 20 ? words.substring(0, 20) + '...' : words;
  }

  return `Branch ${messageIndex + 1}`;
};

const handleLabelDoubleClick = (event) => {
  event.stopPropagation();
  event.preventDefault();

  if (!isEditing.value) {
    isEditing.value = true;
    labelInput.value = customLabel.value || getLabelText();
    nextTick(() => {
      inputRef.value?.focus();
    });
  }
};

const handleLabelBlur = () => {
  if (labelInput.value.trim()) {
    customLabel.value = labelInput.value.trim();
  }
  isEditing.value = false;
};

const handleKeyDown = (event) => {
  if (event.key === 'Enter') {
    handleLabelBlur();
  } else if (event.key === 'Escape') {
    isEditing.value = false;
  }
};
</script>

<style scoped>
.text-container {
  pointer-events: none;
}

.label-text {
  pointer-events: none;
  fill: var(--color-base-content);
  opacity: 0.8;
}

.label-background {
  pointer-events: all;
  cursor: pointer;
  fill: currentColor;
  background: var(--color-base-100);
  padding: 4px 12px;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.label-background:hover {
  background: var(--color-base-200);
}

input {
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 2px var(--color-primary/0.2);
}

textPath.reversed {
  transform: scale(1, -1);
}
</style>
=== END FILE: ./src/components/canvas/spline/SplineConnector.vue ===


=== START FILE: ./src/components/canvas/node/BranchNode.vue ===
=== TYPE: vue ===

<template>
  <div class="branch-node" :data-node-id="node.id" :class="{
    'selected': isSelected,
    'streaming': node.streamingContent,
    'active': isStreaming,
    'fading-out': !node.streamingContent && isStreaming,
    'draggable': isDraggable
  }" @click="$emit('select')" @mousedown="handleMouseDown" @mousemove="handleMouseMove" @mouseup="handleMouseUp">
    <Card :class="[
      'node-card max-w-2xl w-[42rem]',
      'backdrop-blur transition-all duration-300'
    ]" :style="{
      ...nodeStyles,
      backgroundColor: `${threadColor}05`,
      '--tw-backdrop-blur': '8px',
      borderColor: `${threadColor}20`
    }">
      <!-- Model Avatars -->
      <div class="absolute -top-4 left-1/2 transform -translate-x-1/2 flex -space-x-2 px-2">
        <div v-if="lastModel" class="relative group w-9 h-9">
          <img :src="getAvatarUrl(lastModel)" alt="Provider Avatar"
            class="w-9 h-9 rounded-full border-2 border-base-100 shadow-md object-cover" />
          <div
            class="avatar-overlay transition-opacity duration-200 opacity-0 absolute inset-0 rounded-full bg-black/30 group-hover:opacity-100">
          </div>
          <div class="absolute bottom-full mb-2 hidden group-hover:block z-50"
            style="left: 50%; transform: translateX(-50%);">
            <div class="bg-base-100 border rounded-md shadow-lg px-2 py-1 text-xs whitespace-nowrap text-base-content">
              {{ lastModel.name }}
            </div>
          </div>
        </div>
      </div>

      <div class="p-4">
        <div class="flex items-center justify-between mb-4">
          <!-- Header Content -->
          <div class="flex items-center gap-3">
            <button @click.stop="isExpanded = !isExpanded" class="p-2 rounded-full hover:bg-white/10 transition-colors"
              :style="{ color: threadColor }">
              <ChevronDown class="w-5 h-5 transition-transform duration-200" :class="{ '-rotate-90': !isExpanded }" />
            </button>

            <div class="flex flex-col">
              <!-- Title Section -->
              <div class="flex items-center gap-2">
                <template v-if="isEditing">
                  <input ref="titleInputRef" v-model="titleInput" @blur="handleTitleUpdate"
                    @keyup.enter="handleTitleUpdate" class="bg-base-100 px-2 py-1 rounded border text-base-content"
                    placeholder="Enter title..." />
                </template>
                <template v-else>
                  <span class="text-lg font-semibold truncate max-w-lg text-base-content">
                    {{ node.title || "Untitled Thread" }}
                  </span>
                  <button @click.stop="startEditing" class="p-1 rounded-full hover:bg-white/10 flex-shrink-0">
                    <Edit2 class="w-4 h-4 text-base-content/60" />
                  </button>
                </template>
              </div>

              <!-- Message Count -->
              <div class="flex items-center gap-2 mt-1">
                <MessageCircle class="w-4 h-4 text-base-content/60" />
                <span class="text-sm text-base-content/60">
                  {{ node.messages?.length || 0 }} messages
                </span>
              </div>
            </div>
          </div>

          <!-- Delete Button -->
          <button v-if="node.type !== 'main'"
            class="p-2 rounded-full hover:bg-destructive/10 text-base-content/60 hover:text-destructive flex-shrink-0"
            @click.stop="$emit('delete')">
            <X class="w-5 h-5" />
          </button>
        </div>

        <!-- Slot for media content -->
        <slot></slot>

        <!-- Messages -->
        <div v-if="isExpanded && node.messages" class="space-y-4">
          <div v-for="(msg, i) in displayMessages" :key="i" class="relative group message-container"
            :style="getMessageStyles(i)">
            <MessageTimestamp :timestamp="msg.timestamp" :side="node.type === 'branch' ? 'left' : 'right'" />

            <!-- Branch Buttons -->
            <div
              class="absolute inset-y-0 -left-12 flex items-center opacity-0 group-hover:opacity-100 transition-all duration-200 ease-in-out z-20">
              <button @click.stop="createBranch(i, 'left')"
                class="p-2 rounded-full hover:bg-white/10 transition-colors group/btn" :style="{ color: threadColor }"
                title="Branch left">
                <div class="relative">
                  <GitBranch class="w-5 h-5 transform -scale-x-100" />
                  <div
                    class="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap opacity-0 group-hover/btn:opacity-100 transition-opacity duration-200 text-xs bg-base-300/90 backdrop-blur px-2 py-1 rounded">
                    Branch left
                  </div>
                </div>
              </button>
            </div>

            <div
              class="absolute inset-y-0 -right-12 flex items-center opacity-0 group-hover:opacity-100 transition-all duration-200 ease-in-out z-20">
              <button @click.stop="createBranch(i, 'right')"
                class="p-2 rounded-full hover:bg-white/10 transition-colors group/btn" :style="{ color: threadColor }"
                title="Branch right">
                <div class="relative">
                  <GitBranch class="w-5 h-5" />
                  <div
                    class="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap opacity-0 group-hover/btn:opacity-100 transition-opacity duration-200 text-xs bg-base-300/90 backdrop-blur px-2 py-1 rounded">
                    Branch right
                  </div>
                </div>
              </button>
            </div>

            <div class="p-4 relative z-10">
              <!-- Message Header -->
              <div class="flex items-center justify-between mb-2">
                <Badge :variant="msg.role === 'user' ? 'default' : msg.isStreaming ? 'outline' : 'secondary'"
                  class="text-xs">
                  {{ msg.role === 'user' ? 'You' : msg.isStreaming ? 'AI Typing...' : 'AI' }}
                </Badge>

                <div class="flex items-center gap-2" v-if="!msg.isStreaming">
                  <button @click.stop="expandMessage(i)" class="p-1.5 rounded-full hover:bg-white/10">
                    <component :is="expandedMessages.has(i) ? Maximize2 : Minimize2"
                      class="w-4 h-4 text-base-content/60" />
                  </button>
                </div>
              </div>

              <!-- Message Content -->
              <div class="text-sm break-words overflow-hidden" :class="{
                'line-clamp-2': expandedMessages.has(i),
                'whitespace-pre-wrap': !msg.isStreaming,
                'whitespace-normal': msg.isStreaming
              }">
                <MessageContent :content="msg.content" :is-streaming="msg.isStreaming" />
              </div>

              <!-- Message Actions -->
              <div class="mt-3 flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <button v-if="msg.isStreaming"
                    class="flex items-center gap-2 text-sm text-red-500 hover:underline opacity-0 group-hover:opacity-100 transition-opacity"
                    @click.stop="stopStreaming">
                    <XCircle class="w-4 h-4" />
                    Stop
                  </button>

                  <button v-else-if="msg.role === 'assistant'"
                    class="flex items-center gap-2 text-sm hover:underline opacity-0 group-hover:opacity-100 transition-opacity"
                    :style="{ color: threadColor }" @click.stop="$emit('resend', i - 1)">
                    <RotateCw class="w-4 h-4" />
                    Resend
                  </button>
                </div>

                <!-- Model Badge -->
                <div v-if="msg.role === 'assistant'"
                  class="model-badge opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-2 px-3 py-1 rounded-full text-xs bg-base-100/90 border border-base-200">
                  <img :src="getAvatarUrl(getModelInfo(msg.modelId))" alt="Model Avatar"
                    class="w-4 h-4 rounded-full object-cover" />
                  <span class="text-base-content">
                    {{ getModelInfo(msg.modelId)?.name || 'Unknown Model' }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Collapsed View -->
        <div v-else-if="node.messages?.length" class="mt-2 text-sm text-base-content/60">
          <div class="line-clamp-2 break-words overflow-hidden">
            Last message:
            {{ node.streamingContent || node.messages[node.messages.length - 1]?.content }}
          </div>
        </div>
      </div>

      <MessageInput :is-loading="isLoading" @send="handleMessageSend" @stop="stopStreaming" />
    </Card>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, nextTick, onBeforeUnmount, watch } from 'vue';
import type { PropType } from 'vue';
import {
  ChevronDown, MessageCircle, Edit2, X,
  Maximize2, Minimize2, XCircle, RotateCw
} from 'lucide-vue-next';

import MessageInput from '../../messages/MessageInput.vue';
import { useCanvasStore } from '../../../stores/canvasStore';
import Card from '../../ui/Card.vue';
import Badge from '../../ui/Badge.vue';
import MessageContent from '../../messages/MessageContent.vue';
import MessageTimestamp from '../../messages/MessageTimestamp.vue';
import type { Message, Node } from '../../../types/message';
import anthropic from '@/assets/anthropic.jpeg'
import openai from '@/assets/openai.jpeg'
import google from '@/assets/google.jpeg'
import meta from '@/assets/meta.jpeg'
import mistral from '@/assets/mistral.jpeg'
import unknownAvatar from '@/assets/unknown.jpeg'
import ollama from '@/assets/ollama.jpeg'
import { GitBranch } from 'lucide-vue-next';

interface ModelInfo {
  id: string;
  name: string;
  source: 'ollama' | 'openrouter';
  provider?: string;
}

interface ExtendedMessage extends Message {
  modelId?: string;
}

interface ExtendedNode extends Node {
  messages: ExtendedMessage[];
  streamingContent: string | null
}

const props = defineProps({
  node: {
    type: Object as PropType<ExtendedNode>,
    required: true
  },
  isSelected: Boolean,
  selectedModel: {
    type: String,
    required: true
  },
  openRouterApiKey: {
    type: String,
    required: true
  },
  zoom: {
    type: Number,
    required: true
  },
  modelRegistry: {
    type: Object as PropType<Map<string, ModelInfo>>,
    required: true
  },
});


const emit = defineEmits(['select', 'drag-start', 'create-branch', 'update-title', 'delete', 'resend']);

// UI states
const isExpanded = ref(true);
const isEditing = ref(false);
const titleInput = ref('');
const expandedMessages = ref(new Set<number>());
const titleInputRef = ref<HTMLElement | null>(null);
const isDraggable = ref(false);
const isDragging = ref(false);
const dragStartPosition = ref({ x: 0, y: 0 });
const DRAG_THRESHOLD = 5; // Pixels to move before initiating drag
const isStreaming = ref(false);
const fadeTimeout = ref<number | null>(null);
const lastModel = ref<ModelInfo | undefined>(undefined)

// Store
const store = useCanvasStore();

// Loading / streaming states
const isLoading = ref(false);
// We'll store a single AbortController for the current request
let abortController: AbortController | null = null;

// Watch for title changes
watch(
  () => props.node.title,
  (newTitle) => {
    titleInput.value = newTitle || '';
  },
  { immediate: true }
);

watch(() => props.node.streamingContent, (newVal) => {
  if (newVal) {
    // Clear any existing timeout
    if (fadeTimeout.value) {
      clearTimeout(fadeTimeout.value);
    }
    isStreaming.value = true;
  } else if (isStreaming.value) {
    // Only start fade out if we were streaming
    fadeTimeout.value = setTimeout(() => {
      isStreaming.value = false;
    }, 1000); // Match this to your transition duration
  }
});

const threadColor = computed(() => {
  const hues = [210, 330, 160, 280, 40, 190];
  // Simple pseudo-random approach based on the node ID
  const index = Math.abs(Math.floor(Number(props.node.id) * Math.sin(Number(props.node.id))) % hues.length);
  return `hsl(${hues[index]}, 85%, 45%)`;
});

const displayMessages = computed((): Message[] => {
  if (!props.node.messages) return [];
  return props.node.streamingContent
    ? [
      ...props.node.messages,
      {
        role: 'assistant',
        content: props.node.streamingContent,
        isStreaming: true,
        timestamp: new Date().toISOString()
      }
    ]
    : props.node.messages;
});

const providerAvatars: Record<string, string> = {
  Anthropic: anthropic,
  OpenAI: openai,
  Google: google,
  Meta: meta,
  Mistral: mistral,
  Unknown: unknownAvatar,
  ollama: ollama
};

function getAvatarUrl(model?: ModelInfo): string {
  if (!model) return providerAvatars['Unknown'];

  if (model.source === 'ollama') {
    return providerAvatars['ollama'];
  }

  // For openrouter models
  const avatar = model.provider ? providerAvatars[model.provider] : providerAvatars['Unknown'];
  return avatar || providerAvatars['Unknown'];
}

// The computed models no longer needs to be a set
const uniqueModels = computed(() => {
  if (!lastModel.value) return [];
  return [lastModel.value];
});


function getModelInfo(modelId?: string): ModelInfo | undefined {
  if (!modelId) return undefined;

  // First try to get from registry
  const registryModel = props.modelRegistry.get(modelId);
  if (registryModel) return registryModel;

  // Fallback: Parse from model ID if not in registry
  if (modelId.includes('/')) {
    const [provider, name] = modelId.split('/');
    return {
      id: modelId,
      name,
      source: 'openrouter',
      provider
    };
  }

  return {
    id: modelId,
    name: modelId,
    source: 'ollama'
  };
}

const nodeStyles = computed(() => ({
  '--border-color': threadColor.value,
  '--border-color-light': `${threadColor.value}50`
}));

/* ------------------
   Drag event handlers
------------------ */
const handleMouseDown = (e: MouseEvent) => {
  if (props.node.type !== 'main') {
    dragStartPosition.value = { x: e.clientX, y: e.clientY };
    isDraggable.value = true;
    isDragging.value = false; // Reset drag state on mouse down
  }
};

const handleMouseMove = (e: MouseEvent) => {
  if (!isDraggable.value) return;

  const dx = Math.abs(e.clientX - dragStartPosition.value.x);
  const dy = Math.abs(e.clientY - dragStartPosition.value.y);

  if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
    e.stopPropagation();
    isDraggable.value = false;
    isDragging.value = true; // Set dragging state when threshold is exceeded
    emit('drag-start', e, props.node);
  }
};

const handleMouseUp = () => {
  const wasDragging = isDragging.value;
  isDraggable.value = false;
  isDragging.value = false;

  // Only emit select if we weren't dragging
  if (!wasDragging) {
    emit('select');
  }
};
/* ------------------
   Title editing
------------------ */
const startEditing = () => {
  isEditing.value = true;
  titleInput.value = props.node.title || '';
  nextTick(() => {
    if (titleInputRef.value) {
      (titleInputRef.value as HTMLInputElement).focus();
      (titleInputRef.value as HTMLInputElement).select();
    }
  });
};

const handleTitleUpdate = () => {
  if (titleInput.value.trim()) {
    emit('update-title', props.node.id, titleInput.value.trim());
  }
  isEditing.value = false;
};

/* ------------------
   Branch creation
------------------ */
const createBranch = (messageIndex: number, direction: 'left' | 'right') => {
  const horizontalOffset = direction === 'left'
    ? -store.CARD_WIDTH - 100
    : store.CARD_WIDTH + 100;

  // Calculate new branch position
  const position = {
    x: props.node.x + horizontalOffset,
    y: props.node.y  // Let handleCreateBranch handle vertical positioning
  };

  // Create initial data for the new branch
  const initialData = {
    title: `Branch from "${props.node.title || 'Untitled Thread'}"`,
    messages: props.node.messages.slice(0, messageIndex + 1),
    branchMessageIndex: messageIndex,
    // This is crucial for connector positioning
    type: direction === 'left' ? 'left-branch' : 'right-branch'
  };

  emit('create-branch', props.node.id, messageIndex, position, initialData);
};

/* ------------------
   Message sending
------------------ */

async function handleMessageSend(message: string) {
  isLoading.value = true;
  try {
    const modelId = await store.sendMessage(props.node.id, message, props.selectedModel, props.openRouterApiKey);
    // Auto-generate title for new conversations
    if (props.node.messages.length === 2 && !props.node.title) {
      generateTitle();
    }
    if (modelId) {
      lastModel.value = getModelInfo(modelId);
    }
  } catch (error) {
    console.error('Error sending message:', error);
  } finally {
    isLoading.value = false;
  }
}

/* ------------------
   Title generator
------------------ */
async function generateTitle() {
  try {
    const messages = props.node.messages.slice(0, 3);
    const prompt = `Based on this conversation, suggest a concise and descriptive title (max 5 words):\n\n${messages
      .map((m) => `${m.role}: ${m.content}`)
      .join('\n')}`;

    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: props.selectedModel,
        prompt,
        system:
          'You are a helpful assistant. Respond only with the title - no explanations or additional text.',
        stream: false
      })
    });

    const data = await response.json();
    const generatedTitle = data.response.trim();
    emit('update-title', props.node.id, generatedTitle);
  } catch (error) {
    console.error('Error generating title:', error);
  }
}

/* ------------------
   Stop streaming
------------------ */
function stopStreaming() {
  if (abortController) {
    abortController.abort();
    store.setStreamingContent(props.node.id, null);
  }
}

/* ------------------
   Expand/collapse
------------------ */
const expandMessage = (index: number) => {
  const newSet = new Set(expandedMessages.value);
  if (newSet.has(index)) {
    newSet.delete(index);
  } else {
    newSet.add(index);
  }
  expandedMessages.value = newSet;
};

function getMessageStyles(index: number) {
  const isInherited =
    props.node.type === 'branch' &&
    props.node.branchMessageIndex !== null &&
    index <= props.node.branchMessageIndex;

  const baseColor = threadColor.value;
  const messageBackground = isInherited
    ? `linear-gradient(to right, ${baseColor}03, ${baseColor}08)`
    : `linear-gradient(to right, ${baseColor}08, ${baseColor}15)`;

  return {
    background: messageBackground,
    borderLeft: `4px ${isInherited ? 'dashed' : 'solid'} ${baseColor}`,
    borderRadius: '0.5rem',
    position: 'relative' as const,
    transition: 'box-shadow 0.3s ease',
    ...(isInherited && {
      boxShadow: `inset 0 0 0 1px ${baseColor}10`
    })
  };
}

onMounted(() => {
  if (!props.node.title) {
    isEditing.value = true;
  }
  // Initialize last model using all the messages
  if (props.node.messages && props.node.messages.length > 0) {
    let lastMessage = props.node.messages[props.node.messages.length - 1];
    if (lastMessage.modelId) {
      lastModel.value = getModelInfo(lastMessage.modelId);
    }
  }
});

onBeforeUnmount(() => {
  isDraggable.value = false;
  isDragging.value = false;
  if (fadeTimeout.value) {
    clearTimeout(fadeTimeout.value);
  }
});
</script>

<style scoped>
.branch-node {
  position: absolute;
  transition: transform 0.2s ease;
  user-select: none;
}

.draggable:active {
  cursor: grabbing;
}

.node-card {
  backdrop-filter: blur(8px);
  margin: 4px;
  transition: all 0.3s ease;
  position: relative;
}

.node-card:hover {
  box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1);
}

.selected .node-card {
  ring: 2px;
  ring-color: rgb(59 130 246);
}

/* Base streaming states */
.streaming .node-card::before,
.streaming .node-card::after {
  content: '';
  position: absolute;
  border-radius: inherit;
  background: linear-gradient(90deg,
      #ff1493 0%,
      #ff6347 15%,
      #ffd700 30%,
      #32cd32 45%,
      #4169e1 60%,
      #9400d3 75%,
      #ff1493 90%,
      #ff6347 100%);
  background-size: 200% 100%;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  animation: flowBorder 3s linear infinite;
  opacity: 0;
  transition: opacity 1s ease-in-out;
  z-index: 0;
}

.streaming .node-card::before {
  inset: -2px;
  /* Reduced from -4px */
  padding: 2px;
  /* Reduced from 4px */
  filter: blur(3px);
  /* Slightly reduced blur */
}

.streaming .node-card::after {
  inset: -1px;
  /* Reduced from -2px */
  padding: 1px;
  /* Reduced from 2px */
  filter: blur(1px);
  /* Reduced blur for sharper inner border */
}

/* Animation states */
.branch-node.active .node-card::before,
.branch-node.active .node-card::after {
  opacity: 1;
}

.branch-node.fading-out .node-card::before,
.branch-node.fading-out .node-card::after {
  opacity: 0;
}

@keyframes flowBorder {
  0% {
    background-position: 100% 0;
  }

  100% {
    background-position: -100% 0;
  }
}

/* Fix for child content rotation in streaming */
.streaming .node-card>* {
  position: relative;
  z-index: 1;
}

.model-badge {
  animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-container {
  position: relative;
  transition: all 0.2s ease-in-out;
}

.message-container:hover {
  transform: translateX(0);
}

.branch-button {
  transform: translateX(20px);
  opacity: 0;
  transition: all 0.2s ease-in-out;
}

.message-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: -12px;
  right: -12px;
  bottom: 0;
  z-index: -1;
}

/* Ensure branch buttons have enough hover area */
.message-container .absolute {
  padding: 0.5rem;
  margin: -0.5rem;
}

.message-container:hover .branch-button {
  transform: translateX(0);
  opacity: 1;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

.avatar-overlay {
  border-radius: 9999px;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}


.cluster-viz-container {
  transform-origin: bottom left;
}

.cluster-viz-minimized {
  cursor: pointer;
}

.cluster-viz-focused {
  backdrop-filter: blur(8px);
  background: rgba(0, 0, 0, 0.5);
}
</style>
=== END FILE: ./src/components/canvas/node/BranchNode.vue ===


=== START FILE: ./src/components/canvas/node/MediaBranchNode.vue ===
=== TYPE: vue ===

<template>
    <div class="media-branch-node" :class="{ 'processing': isProcessing }">
        <BranchNode 
            :node="node" 
            :is-selected="isSelected" 
            :selected-model="selectedModel"
            :open-router-api-key="openRouterApiKey" 
            :zoom="zoom" 
            :model-registry="modelRegistry"
            @select="$emit('select')" 
            @drag-start="(e, node) => $emit('drag-start', e, node)"
            @create-branch="(parentId, index, pos, data) => $emit('create-branch', parentId, index, pos, data)"
            @update-title="(id, title) => $emit('update-title', id, title)"
            @resend="messageIndex => $emit('resend', messageIndex)" 
            @delete="$emit('delete')"
            @send="handleMessageSend">
            <template #default>
                <!-- Media preview content -->
                <div v-if="mediaContent" class="media-preview p-4 border-b border-base-300">
                    <!-- Image preview -->
                    <img v-if="isImage" 
                         :src="mediaUrl" 
                         class="max-w-full h-auto rounded-lg"
                         :alt="mediaContent.filename" />

                    <!-- Video preview -->
                    <video v-else-if="isVideo" controls class="max-w-full h-auto rounded-lg">
                        <source :src="mediaUrl" :type="mediaContent.mime_type">
                        Your browser does not support the video tag.
                    </video>

                    <!-- Analysis status -->
                    <div v-if="isProcessing" class="mt-4 text-sm text-base-content/60">
                        Processing media...
                    </div>
                </div>

                <!-- Chat messages will be rendered by BranchNode -->
            </template>
        </BranchNode>
    </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import BranchNode from './BranchNode.vue';
import type { PropType } from 'vue';
import type { Node } from '../../../types/message';

// Enhanced types to support media chat
interface MediaContent {
    media_id: string;
    filename: string;
    mime_type: string;
    analysis: string;
    type: 'image' | 'video';
    previewUrl?: string;
}

interface MediaNode extends Node {
    mediaContent?: MediaContent;
}

interface ModelInfo {
    id: string;
    name: string;
    source: 'ollama' | 'openrouter' | 'custom';
    provider?: string;
}

// Props
const props = defineProps({
    node: {
        type: Object as PropType<MediaNode>,
        required: true
    },
    isSelected: {
        type: Boolean,
        required: true
    },
    selectedModel: {
        type: String,
        required: true
    },
    openRouterApiKey: {
        type: String,
        required: true
    },
    zoom: {
        type: Number,
        required: true
    },
    modelRegistry: {
        type: Object as PropType<Map<string, ModelInfo>>,
        required: true
    }
});

// Emits
const emit = defineEmits<{
    (e: 'select'): void;
    (e: 'drag-start', event: MouseEvent, node: MediaNode): void;
    (e: 'create-branch', parentId: string, messageIndex: number, position: { x: number, y: number }, initialData: any): void;
    (e: 'update-title', id: string, title: string): void;
    (e: 'resend', messageIndex: number): void;
    (e: 'delete'): void;
}>();

// State
const isProcessing = ref(false);
const mediaContent = computed(() => props.node.mediaContent);
const isImage = computed(() => mediaContent.value?.mime_type.startsWith('image/'));
const isVideo = computed(() => mediaContent.value?.mime_type.startsWith('video/'));
const mediaUrl = computed(() => 
    mediaContent.value
        ? mediaContent.value.previewUrl || `http://127.0.0.1:5000/media/${mediaContent.value.media_id}`
        : null
);

// Enhanced media processing with chat support
const processMedia = async (file: File, apiType: string, apiKey?: string) => {
    isProcessing.value = true;

    try {
        // Create immediate preview URL
        const previewUrl = URL.createObjectURL(file);

        // Set initial media content with preview URL
        props.node.mediaContent = {
            media_id: 'preview',
            filename: file.name,
            mime_type: file.type,
            analysis: 'Analyzing...',
            type: file.type.startsWith('image/') ? 'image' : 'video',
            previewUrl
        };

        // Prepare and send to backend
        const formData = new FormData();
        formData.append('file', file);
        const modelType = props.selectedModel.includes('gemini') ? 'gemini' :
            props.selectedModel.includes('/') ? 'openrouter' : 'ollama';

        formData.append('api_type', modelType);
        formData.append('model', props.selectedModel);

        if (apiKey) {
            formData.append('api_key', apiKey);
        }

        const response = await fetch('http://127.0.0.1:5000/process-media', {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to process media');
        }

        const result = await response.json();

        // Update media content with result and keep preview URL
        props.node.mediaContent = {
            ...result,
            previewUrl
        };

        // Add initial analysis message
        if (!props.node.messages) {
            props.node.messages = [];
        }

        props.node.messages.push({
            role: 'assistant',
            content: result.analysis,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('Error processing media:', error);
        throw error;
    } finally {
        isProcessing.value = false;
    }
};

// New method to handle follow-up messages
const handleMessageSend = async (message: string) => {
    if (!props.node.mediaContent?.media_id) {
        console.error('No media ID found');
        return;
    }

    try {
        // Add user message to the chat
        props.node.messages.push({
            role: 'user',
            content: message,
            timestamp: new Date().toISOString()
        });

        // Send follow-up request to backend
        const response = await fetch('http://127.0.0.1:5000/chat-follow-up', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                media_id: props.node.mediaContent.media_id,
                message: message,
                api_key: props.openRouterApiKey
            })
        });

        if (!response.ok) {
            throw new Error('Failed to get response');
        }

        const result = await response.json();

        // Add AI response to the chat
        props.node.messages.push({
            role: 'assistant',
            content: result.response,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('Error in chat follow-up:', error);
        // Add error message to chat
        props.node.messages.push({
            role: 'assistant',
            content: 'Sorry, I encountered an error processing your message.',
            timestamp: new Date().toISOString()
        });
    }
};

// Expose methods
defineExpose({
    processMedia
});
</script>

<style scoped>
.media-branch-node {
    position: relative;
}

.media-branch-node.processing::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.2rem;
}

.media-preview {
    position: relative;
    overflow: hidden;
    border-radius: 0.5rem;
}

.media-preview img,
.media-preview video {
    max-height: 400px;
    object-fit: contain;
    width: 100%;
}
</style>
=== END FILE: ./src/components/canvas/node/MediaBranchNode.vue ===


=== START FILE: ./src/components/canvas/node/WebBranchNode.vue ===
=== TYPE: vue ===

<template>
    <div class="web-branch-node">
        <BranchNode :node="node" :is-selected="isSelected" :selected-model="selectedModel"
            :open-router-api-key="openRouterApiKey" :zoom="zoom" :model-registry="modelRegistry"
            @select="$emit('select')" @drag-start="(e, node) => $emit('drag-start', e, node)"
            @create-branch="(parentId, index, pos, data) => $emit('create-branch', parentId, index, pos, data)"
            @update-title="(id, title) => $emit('update-title', id, title)"
            @resend="messageIndex => $emit('resend', messageIndex)" @delete="$emit('delete')">
            <template #default>
                <!-- Web preview content -->
                <div class="web-preview p-4 border-b border-base-300">
                    <div class="web-container bg-white rounded-lg overflow-hidden" style="height: 400px;">
                        <iframe 
                            :src="node.url" 
                            class="w-full h-full"
                            frameborder="0"
                            sandbox="allow-scripts allow-same-origin allow-popups"
                            loading="lazy"
                        ></iframe>
                    </div>
                    <div class="mt-2 text-sm text-base-content opacity-75">
                        <a :href="node.url" target="_blank" rel="noopener noreferrer" 
                           class="hover:underline flex items-center gap-2">
                            <ExternalLink class="w-4 h-4" />
                            {{ node.url }}
                        </a>
                    </div>
                </div>
            </template>
        </BranchNode>
    </div>
</template>

<script setup lang="ts">
import { ExternalLink } from 'lucide-vue-next';
import BranchNode from './BranchNode.vue';
import type { PropType } from 'vue';
import type { Node } from '../../../types/message';

interface WebNode extends Node {
    url: string;
}

interface ModelInfo {
    id: string;
    name: string;
    source: 'ollama' | 'openrouter' | 'custom';
    provider?: string;
}

// Props
const props = defineProps({
    node: {
        type: Object as PropType<WebNode>,
        required: true
    },
    isSelected: {
        type: Boolean,
        required: true
    },
    selectedModel: {
        type: String,
        required: true
    },
    openRouterApiKey: {
        type: String,
        required: true
    },
    zoom: {
        type: Number,
        required: true
    },
    modelRegistry: {
        type: Object as PropType<Map<string, ModelInfo>>,
        required: true
    }
});

// Events
const emit = defineEmits<{
    (e: 'select'): void;
    (e: 'drag-start', event: MouseEvent, node: WebNode): void;
    (e: 'create-branch', parentId: string, messageIndex: number, position: { x: number, y: number }, initialData: any): void;
    (e: 'update-title', id: string, title: string): void;
    (e: 'resend', messageIndex: number): void;
    (e: 'delete'): void;
}>();
</script>

<style scoped>
.web-branch-node {
    position: relative;
}

.web-preview {
    position: relative;
    overflow: hidden;
    border-radius: 0.5rem;
}

.web-container {
    position: relative;
    width: 100%;
    box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
}

.web-container::before {
    content: '';
    display: block;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
}

.web-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: white;
}
</style>
=== END FILE: ./src/components/canvas/node/WebBranchNode.vue ===


=== START FILE: ./src/components/manager/TaskManager.vue ===
=== TYPE: vue ===

<script setup lang="ts">
import { ref, onMounted, computed, watch } from 'vue';
import { Plus, X, ChevronDown, ChevronUp, Trash2 } from 'lucide-vue-next';

interface Task {
  id: string;
  title: string;
  description: string;
  status: 'todo' | 'in-progress' | 'done';
  type: 'feature' | 'bug';
  dateCreated: string;
  dateUpdated: string;
}

const tasks = ref<Task[]>([]);
const showNewTaskForm = ref(false);
const newTask = ref({
  title: '',
  description: '',
  type: 'feature' as const
});
const expandedTaskId = ref<string | null>(null);
const filterStatus = ref<Task['status'] | 'all'>('all');
const filterType = ref<Task['type'] | 'all'>('all');

const addTask = () => {
  if (!newTask.value.title.trim()) return;
  
  const now = new Date().toISOString();
  tasks.value.unshift({
    id: crypto.randomUUID(),
    title: newTask.value.title,
    description: newTask.value.description,
    status: 'todo',
    type: newTask.value.type,
    dateCreated: now,
    dateUpdated: now
  });
  
  newTask.value = {
    title: '',
    description: '',
    type: 'feature'
  };
  showNewTaskForm.value = false;
};

const cancelNewTask = () => {
  newTask.value = {
    title: '',
    description: '',
    type: 'feature'
  };
  showNewTaskForm.value = false;
};

const deleteTask = (taskId: string) => {
  tasks.value = tasks.value.filter(task => task.id !== taskId);
  if (expandedTaskId.value === taskId) {
    expandedTaskId.value = null;
  }
};

const updateTaskStatus = (task: Task, status: Task['status']) => {
  task.status = status;
  task.dateUpdated = new Date().toISOString();
};

const toggleExpand = (taskId: string) => {
  expandedTaskId.value = expandedTaskId.value === taskId ? null : taskId;
};

const filteredTasks = computed(() => {
  return tasks.value.filter(task => {
    const statusMatch = filterStatus.value === 'all' || task.status === filterStatus.value;
    const typeMatch = filterType.value === 'all' || task.type === filterType.value;
    return statusMatch && typeMatch;
  });
});

const getStatusColor = (status: Task['status']) => {
  switch (status) {
    case 'todo': return 'bg-blue-500/10 text-blue-500';
    case 'in-progress': return 'bg-yellow-500/10 text-yellow-500';
    case 'done': return 'bg-green-500/10 text-green-500';
  }
};

onMounted(() => {
  const savedTasks = localStorage.getItem('projectTasks');
  if (savedTasks) tasks.value = JSON.parse(savedTasks);
});

watch(tasks, (newTasks) => {
  localStorage.setItem('projectTasks', JSON.stringify(newTasks));
}, { deep: true });
</script>

<template>
  <div class="space-y-6">
    <!-- Header with New Task Button -->
    <div class="flex justify-between items-center">
      <div class="flex gap-2 text-sm">
        <select v-model="filterStatus" class="select select-sm select-bordered">
          <option value="all">All Status</option>
          <option value="todo">Todo</option>
          <option value="in-progress">In Progress</option>
          <option value="done">Done</option>
        </select>
        <select v-model="filterType" class="select select-sm select-bordered">
          <option value="all">All Types</option>
          <option value="feature">Features</option>
          <option value="bug">Bugs</option>
        </select>
      </div>
      
      <button 
        v-if="!showNewTaskForm"
        class="btn btn-sm btn-primary"
        @click="showNewTaskForm = true"
      >
        <Plus class="w-4 h-4" />
        New Task
      </button>
    </div>

    <!-- New Task Form (Collapsible) -->
    <div 
      v-if="showNewTaskForm"
      class="border border-base-300 rounded-lg p-4 space-y-3 bg-base-200/50"
    >
      <div class="flex justify-between items-center">
        <h3 class="font-medium">Create New Task</h3>
        <button 
          class="btn btn-ghost btn-sm btn-square"
          @click="cancelNewTask"
        >
          <X class="w-4 h-4" />
        </button>
      </div>
      
      <input
        v-model="newTask.title"
        type="text"
        placeholder="Task title..."
        class="input input-sm input-bordered w-full"
        @keyup.enter="addTask"
      />
      
      <textarea
        v-model="newTask.description"
        placeholder="Description (optional)"
        class="textarea textarea-bordered textarea-sm w-full h-20 resize-none"
      />
      
      <div class="flex gap-2">
        <select v-model="newTask.type" class="select select-sm select-bordered flex-1">
          <option value="feature">Feature</option>
          <option value="bug">Bug</option>
        </select>
        <button 
          class="btn btn-sm btn-primary"
          @click="addTask"
        >
          Create Task
        </button>
      </div>
    </div>

    <!-- Tasks List -->
    <div class="space-y-2">
      <div 
        v-for="task in filteredTasks" 
        :key="task.id" 
        class="border border-base-300 rounded-lg overflow-hidden hover:border-base-content/20 transition-colors"
      >
        <!-- Task Header -->
        <div 
          class="flex items-center justify-between p-3 cursor-pointer"
          @click="toggleExpand(task.id)"
        >
          <div class="flex items-center gap-3 min-w-0">
            <span 
              class="px-2 py-0.5 rounded-full text-xs capitalize"
              :class="getStatusColor(task.status)"
            >
              {{ task.status }}
            </span>
            <span 
              class="px-2 py-0.5 rounded-full text-xs capitalize"
              :class="task.type === 'bug' ? 'bg-red-500/10 text-red-500' : 'bg-purple-500/10 text-purple-500'"
            >
              {{ task.type }}
            </span>
            <span class="truncate">{{ task.title }}</span>
          </div>
          <component 
            :is="expandedTaskId === task.id ? ChevronUp : ChevronDown" 
            class="w-4 h-4 opacity-50"
          />
        </div>
        
        <!-- Task Details -->
        <div 
          v-if="expandedTaskId === task.id"
          class="p-3 pt-0 space-y-3 text-sm"
        >
          <p class="text-base-content/70 whitespace-pre-wrap">
            {{ task.description || 'No description provided.' }}
          </p>
          
          <div class="flex items-center gap-2">
            <select 
              v-model="task.status" 
              class="select select-sm select-bordered"
              @change="updateTaskStatus(task, $event.target.value)"
            >
              <option value="todo">Todo</option>
              <option value="in-progress">In Progress</option>
              <option value="done">Done</option>
            </select>
            
            <button 
              class="btn btn-ghost btn-sm text-error"
              @click="deleteTask(task.id)"
              title="Delete task"
            >
              <Trash2 class="w-4 h-4" />
            </button>
            
            <div class="flex-1" />
            
            <div class="text-xs text-base-content/50">
              Updated {{ new Date(task.dateUpdated).toLocaleString() }}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
=== END FILE: ./src/components/manager/TaskManager.vue ===


=== START FILE: ./src/components/logo/TangentLogo.vue ===
=== TYPE: vue ===

// TangentLogo.vue
<template>
  <div
    class="w-[180px] h-[36px] relative perspective-[1000px] rounded-lg overflow-hidden"
  >
    <div
      ref="gridRef"
      class="w-full h-full grid relative gap-0"
      :style="{
        gridTemplateColumns: `repeat(${COLS}, 1fr)`,
        gridTemplateRows: `repeat(${ROWS}, 1fr)`
      }"
    >
      <div
        v-for="(_, i) in cells"
        :key="i"
        class="relative transition-transform duration-1000 ease-in-out cell"
        :style="{
          transformStyle: 'preserve-3d',
          border: 'none',
          backgroundColor: 'transparent'
        }"
      >
        <div
          class="absolute w-full h-full overflow-hidden front"
          :style="{
            backfaceVisibility: 'hidden',
            backgroundColor: 'transparent'
          }"
        >
          <div
            class="w-[180px] h-[36px] relative"
            :style="{
              transform: `translate(${-(i % COLS) * (180 / COLS)}px, ${-Math.floor(i / COLS) * (36 / ROWS)}px)`
            }"
          >
            <LogoSVG />
          </div>
        </div>
        <div
          class="absolute w-full h-full overflow-hidden back"
          :style="{
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)',
            backgroundColor: 'transparent'
          }"
        >
          <div
            class="absolute w-[180px] h-[36px]"
            :style="{
              transform: `translate(${-(i % COLS) * (180 / COLS)}px, ${-Math.floor(i / COLS) * (36 / ROWS)}px)`
            }"
          >
            <div class="font-sans text-[24px] font-bold w-full h-full ps-4 flex items-center justify-center text-foreground">
              TANGENT
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue';
import LogoSVG from './LogoSVG.vue';

const COLS = 15;
const ROWS = 5;
const cells = Array.from({ length: ROWS * COLS });

const isShowingFront = ref(true);
const gridRef = ref<HTMLDivElement | null>(null);

const flipCell = (cell: HTMLElement, delay: number) => {
  setTimeout(() => {
    if (cell) {
      cell.style.transform = isShowingFront.value ? 'rotateY(180deg)' : 'rotateY(0deg)';
    }
  }, delay);
};

const animateFlip = () => {
  if (!gridRef.value) return;
  const cells = Array.from(gridRef.value.querySelectorAll('.cell'));

  // Organize cells into columns
  const columns: HTMLElement[][] = Array.from({ length: COLS }, () => []);
  cells.forEach((cell, index) => {
    const col = index % COLS;
    columns[col].push(cell as HTMLElement);
  });

  const delayBetweenColumns = 50;
  const middle = Math.floor(COLS / 2);
  let columnOrder = [middle];
  
  for (let offset = 1; offset <= middle; offset++) {
    if (middle - offset >= 0) columnOrder.push(middle - offset);
    if (middle + offset < COLS) columnOrder.push(middle + offset);
  }

  if (!isShowingFront.value) {
    columnOrder = columnOrder.reverse();
  }

  columnOrder.forEach((colIndex, index) => {
    setTimeout(() => {
      columns[colIndex].forEach((cell) => {
        flipCell(cell, 0);
      });
    }, index * delayBetweenColumns);
  });

  setTimeout(() => {
    isShowingFront.value = !isShowingFront.value;
  }, columnOrder.length * delayBetweenColumns + 500);
};

let intervalId: number;

onMounted(() => {
  intervalId = window.setInterval(animateFlip, 5000);
});

onBeforeUnmount(() => {
  clearInterval(intervalId);
});
</script>
=== END FILE: ./src/components/logo/TangentLogo.vue ===


=== START FILE: ./src/components/logo/LogoSVG.vue ===
=== TYPE: vue ===

// LogoSVG.vue
<template>
  <svg viewBox="0 0 200 45" class="absolute inset-0">
    <!-- Dynamic wave patterns -->
    <path
      d="M 20 22.5 C 40 22.5, 45 12, 65 12 S 90 33, 110 33 S 135 12, 155 12 S 180 22.5, 200 22.5"
      fill="none"
      class="stroke-foreground dark:stroke-foreground"
      stroke-width="1"
    />

    <!-- Fractal-like pattern -->
    <path
      d="M 100 22.5 C 105 22.5, 110 18, 120 18 S 135 27, 145 27 S 155 18, 165 18"
      fill="none"
      class="stroke-cyan-500 dark:stroke-cyan-400"
      stroke-width="1"
    />
    <path
      d="M 100 22.5 C 95 22.5, 90 27, 80 27 S 65 18, 55 18 S 45 27, 35 27"
      fill="none"
      class="stroke-rose-500 dark:stroke-rose-400"
      stroke-width="1"
    />

    <!-- Geometric accents -->
    <path
      v-for="i in 8"
      :key="`right-${i}`"
      :d="`M ${100 + i * 10} 22.5 L ${105 + i * 10} 15 L ${110 + i * 10} 22.5`"
      fill="none"
      class="stroke-emerald-500/30 dark:stroke-emerald-400/30"
      stroke-width="0.5"
    />
    <path
      v-for="i in 8"
      :key="`left-${i}`"
      :d="`M ${100 - i * 10} 22.5 L ${95 - i * 10} 30 L ${90 - i * 10} 22.5`"
      fill="none"
      class="stroke-purple-500/30 dark:stroke-purple-400/30"
      stroke-width="0.5"
    />

    <!-- Dynamic circles -->
    <circle
      v-for="i in 5"
      :key="`right-circle-${i}`"
      :cx="100 + i * 20"
      :cy="22.5 + Math.sin(i * 1.5) * 5"
      :r="1.2 - i * 0.15"
      class="fill-cyan-500 dark:fill-cyan-400"
    />
    <circle
      v-for="i in 5"
      :key="`left-circle-${i}`"
      :cx="100 - i * 20"
      :cy="22.5 + Math.cos(i * 1.5) * 5"
      :r="1.2 - i * 0.15"
      class="fill-rose-500 dark:fill-rose-400"
    />

    <!-- Central focal point -->
    <path
      d="M 95 22.5 L 105 22.5 M 100 17.5 L 100 27.5"
      class="stroke-foreground dark:stroke-foreground"
      stroke-width="1.5"
    />
    <circle
      cx="100"
      cy="22.5"
      r="2.5"
      class="fill-foreground dark:fill-foreground"
    />

    <!-- Abstract mathematical symbols -->
    <path
      d="M 160 15 A 5 5 0 0 1 170 15 A 5 5 0 0 1 160 15"
      fill="none"
      class="stroke-emerald-500/50 dark:stroke-emerald-400/50"
      stroke-width="0.75"
    />
    <path
      d="M 30 30 A 5 5 0 0 0 40 30 A 5 5 0 0 0 30 30"
      fill="none"
      class="stroke-purple-500/50 dark:stroke-purple-400/50"
      stroke-width="0.75"
    />
  </svg>
</template>
=== END FILE: ./src/components/logo/LogoSVG.vue ===


=== START FILE: ./src/components/theme/ThemeToggle.vue ===
=== TYPE: vue ===

<template>
  <div class="relative inline-block">
    <!-- Theme Dropdown -->
    <div class="relative">
      <button @click="isOpen = !isOpen"
        class="flex items-center gap-2 px-3 py-2 rounded-lg bg-background/80 backdrop-blur border shadow-sm hover:bg-muted/80 transition-all duration-200">
        <div class="flex items-center gap-2">
          <div class="flex -space-x-1">
            <div class="w-4 h-4 rounded-full border-2 border-background shadow-sm"
              :style="{ backgroundColor: getThemeColors(currentTheme).primary }" />
            <div class="w-4 h-4 rounded-full border-2 border-background shadow-sm"
              :style="{ backgroundColor: getThemeColors(currentTheme).secondary }" />
          </div>
          <span class="text-sm font-medium">{{ currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1) }}</span>
        </div>
        <ChevronDown class="w-4 h-4 transition-transform duration-200" :class="{ 'rotate-180': isOpen }" />
      </button>

      <!-- Dropdown Menu -->
      <div v-if="isOpen"
        class="absolute left-0 mt-2 w-64 max-h-[60vh] overflow-y-auto rounded-lg border bg-background/95 backdrop-blur shadow-lg z-[100]">
        <div class="p-2" @click.stop>
          <input v-model="search" type="text" placeholder="Search themes..."
            class="w-full px-3 py-2 text-sm rounded-md bg-muted/50 border-0 focus:ring-1 focus:ring-primary" />
        </div>

        <div class="py-1">
          <button v-for="theme in filteredThemes" :key="theme" @click="selectTheme(theme)"
            class="w-full px-3 py-2 flex items-center gap-3 hover:bg-muted/50 transition-colors group"
            :class="{ 'bg-primary/5': theme === currentTheme }">
            <!-- Theme Preview -->
            <div class="flex items-center gap-1.5">
              <div class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200"
                :style="{ backgroundColor: getThemeColors(theme).primary }" />
              <div class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200"
                :style="{ backgroundColor: getThemeColors(theme).secondary }" />
              <div class="w-3 h-3 rounded-full transition-transform group-hover:scale-110 duration-200"
                :style="{ backgroundColor: getThemeColors(theme).accent }" />
            </div>

            <span class="text-sm">{{ theme.charAt(0).toUpperCase() + theme.slice(1) }}</span>

            <Check v-if="theme === currentTheme" class="w-4 h-4 ml-auto text-primary" />
          </button>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { ChevronDown, Check } from 'lucide-vue-next';

type ThemeColors = {
  primary: string;
  secondary: string;
  accent: string;
};

type ThemeName =
  | "light" | "dark" | "cupcake" | "bumblebee" | "emerald" | "corporate"
  | "synthwave" | "retro" | "cyberpunk" | "valentine" | "halloween" | "garden"
  | "forest" | "aqua" | "lofi" | "pastel" | "fantasy" | "wireframe" | "black"
  | "luxury" | "dracula" | "cmyk" | "autumn" | "business" | "acid" | "lemonade"
  | "night" | "coffee" | "winter";

type ThemeColorMap = {
  [K in ThemeName]: ThemeColors;
};

const themes: ThemeName[] = [
  "light", "dark", "cupcake", "bumblebee", "emerald", "corporate",
  "synthwave", "retro", "cyberpunk", "valentine", "halloween",
  "garden", "forest", "aqua", "lofi", "pastel", "fantasy",
  "wireframe", "black", "luxury", "dracula", "cmyk", "autumn",
  "business", "acid", "lemonade", "night", "coffee", "winter"
];

const themeColors: ThemeColorMap = {
  // Light themes
  light: { primary: '#570DF8', secondary: '#F000B8', accent: '#37CDBE' },
  cupcake: { primary: '#65C3C8', secondary: '#EF9FBC', accent: '#EEAF3A' },
  bumblebee: { primary: '#F9D72F', secondary: '#E0A82E', accent: '#181830' },
  emerald: { primary: '#66CC8A', secondary: '#377CFB', accent: '#EA5234' },
  corporate: { primary: '#4B6BFB', secondary: '#7B92B2', accent: '#EA5234' },
  garden: { primary: '#5c7f67', secondary: '#be123c', accent: '#9CA384' },
  lofi: { primary: '#0D0D0D', secondary: '#1A1919', accent: '#4A4A4A' },
  pastel: { primary: '#d1c1d7', secondary: '#f6cbd1', accent: '#b4e9d6' },
  fantasy: { primary: '#6D0A0A', secondary: '#A65D03', accent: '#2D5A27' },
  wireframe: { primary: '#B8B8B8', secondary: '#CDCDCD', accent: '#DEDEDE' },
  lemonade: { primary: '#519903', secondary: '#E9E92E', accent: '#94CE58' },

  // Dark themes
  dark: { primary: '#793EF9', secondary: '#F471B5', accent: '#1FB2A5' },
  synthwave: { primary: '#E779C1', secondary: '#58C7F3', accent: '#F3CC30' },
  retro: { primary: '#EF9995', secondary: '#2CB67D', accent: '#7D5BA6' },
  cyberpunk: { primary: '#FF7598', secondary: '#75D1F0', accent: '#F7D51D' },
  valentine: { primary: '#E96D7B', secondary: '#A12E45', accent: '#F0AFC0' },
  halloween: { primary: '#F28C18', secondary: '#6B21A8', accent: '#37CDBE' },
  forest: { primary: '#1EB854', secondary: '#1DB88E', accent: '#1EA885' },
  aqua: { primary: '#09ECF3', secondary: '#0771DE', accent: '#07ABE3' },
  black: { primary: '#333333', secondary: '#666666', accent: '#999999' },
  luxury: { primary: '#DAA520', secondary: '#B8860B', accent: '#FFD700' },
  dracula: { primary: '#FF79C6', secondary: '#BD93F9', accent: '#50FA7B' },
  cmyk: { primary: '#00BCD4', secondary: '#FF4081', accent: '#FFEB3B' },
  autumn: { primary: '#8B4513', secondary: '#A0522D', accent: '#CD853F' },
  business: { primary: '#1C4E80', secondary: '#7C909A', accent: '#A6B0B5' },
  acid: { primary: '#FF00FF', secondary: '#00FF00', accent: '#FFFF00' },
  night: { primary: '#38BDF8', secondary: '#818CF8', accent: '#C084FC' },
  coffee: { primary: '#6F4E37', secondary: '#C6A880', accent: '#DAC3B3' },
  winter: { primary: '#0EA5E9', secondary: '#84CC16', accent: '#10B981' }
};

const isOpen = ref(false);
const search = ref('');
const currentTheme = ref<ThemeName>(
  (localStorage.getItem('theme') as ThemeName) || 'light'
);

const getThemeColors = (theme: ThemeName): ThemeColors => {
  return themeColors[theme];
};

const filteredThemes = computed(() => {
  const searchTerm = search.value.toLowerCase();
  return themes.filter(theme =>
    theme.toLowerCase().includes(searchTerm)
  );
});

const selectTheme = (theme: ThemeName) => {
  currentTheme.value = theme;
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('theme', theme);
  isOpen.value = false;
};

onMounted(() => {
  const savedTheme = localStorage.getItem('theme') as ThemeName || 'light';
  currentTheme.value = savedTheme;
  document.documentElement.setAttribute('data-theme', savedTheme);
});
</script>

<style scoped>
div::-webkit-scrollbar {
  width: 6px;
}

div::-webkit-scrollbar-track {
  background: transparent;
}

div::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.dark div::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.2);
}
</style>
=== END FILE: ./src/components/theme/ThemeToggle.vue ===


=== START FILE: ./src/vite-env.d.ts ===
=== TYPE: ts ===

/// <reference types="vite/client" />

=== END FILE: ./src/vite-env.d.ts ===


=== START FILE: ./src/router/index.ts ===
=== TYPE: ts ===

import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'
import InfiniteCanvas from '../components/canvas/InfiniteCanvas.vue'

const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: InfiniteCanvas
  },
  {
    path: '/canvas/:id',
    name: 'SpecificCanvas',
    component: InfiniteCanvas,
    props: true
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router
=== END FILE: ./src/router/index.ts ===


